[{"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self):\n        self.clients = [boto3.client('sqs', region_name='us-east-1'), boto3.client('s3')]\n        self.http = urllib3.PoolManager()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def list_s3_objects(self, bucket_name):\n        s3 = boto3.client(\"s3\")\n        response = s3.list_objects_v2(Bucket=bucket_name)\n        return response.get('Contents', [])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def extract_uuid(self, file_name):\n        return file_name[7:-4]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def delete_sqs_message(self, queue_url, receipt_handle):\n        sqs = self.clients[0]\n        sqs.delete_message(QueueUrl=queue_url, ReceiptHandle=receipt_handle)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def is_expected_image_present(self, objects, expected_image):\n        for object in objects:\n            if expected_image in object['Key']:\n                return True\n        return False", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def preprocess_latex(latex_src, rem):\n  \"\"\"\n  latex_src: string of LaTeX source code to pre-process\n  rem: string of formatting element which we want to remove from latex_src. includes opening curly brace. ex. \\mathrm{\n  \"\"\"\n  final_string = latex_src\n  format_index = latex_src.find(rem)\n  while format_index != -1:\n    # iterate through string until you find the right closing curly brace to remove\n    index = format_index + len(rem)\n    closing_brace = -1\n    num_opening = 0\n    while index < len(final_string):\n      if final_string[index:index+1] == \"{\":\n        num_opening += 1\n      elif final_string[index:index+1] == \"}\":\n        if num_opening == 0:\n          closing_brace = index\n          break\n        else:\n          num_opening -= 1\n      index += 1\n\n    # entering this if statement means something went wrong.\n    # nothing is removed in this case\n    if closing_brace == -1:\n      return final_string\n\n    final_string = final_string[:format_index]+final_string[format_index+len(rem):closing_brace]+final_string[closing_brace+1:]\n    format_index = final_string.find(rem)\n  \n  return final_string", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def sympy_to_zss(expr):\n    if isinstance(expr, sp.Symbol) or isinstance(expr, sp.Number):\n        return Node(str(expr))\n    else:\n        full_class_str = str(expr.func)\n        class_name = full_class_str.split('.')[-1].rstrip(\"'>\")\n        node = Node(class_name)\n        for arg in expr.args:\n            child_node = sympy_to_zss(arg)\n            node.addkid(child_node)\n    return node", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def source_to_zss(latex_expr):\n    try:\n        sympy_expr = parse_latex(latex_expr)\n        zss_tree = sympy_to_zss(sympy_expr)\n        return zss_tree\n    except:\n        return Node(\"ERROR\")", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def custom_edit_distance(query_tree, other_tree):\n    return distance(query_tree, other_tree, get_children=Node.get_children,\n        insert_cost=lambda node: 10, remove_cost=lambda node: 10, update_cost=lambda a, b: 1)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def mathpix_imgpath_to_latex(image_path) :\n\n    # Hardcoded CDS account response headers (placeholders for now)\n    headers = {\n        \"app_id\": \"mathsearch_ff86f3_059645\",\n        \"app_key\": os.environ.get(\"APP_KEY\")\n    }\n\n    # Declare api request payload (refer to https://docs.mathpix.com/?python#introduction for description)\n    data = {\n        \"formats\": [\"latex_styled\"], \n        \"rm_fonts\": True, \n        \"rm_spaces\": False,\n        \"idiomatic_braces\": True\n    }\n\n    #print(f\"type after buffered reader stuff {type(io.BufferedReader(io.BytesIO(image)))}\")\n    # assume that image is stored in bytes\n    response = requests.post(\"https://api.mathpix.com/v3/text\",\n                                files={\"file\": open(image_path,\"rb\")}  ,\n                                data={\"options_json\": json.dumps(data)},\n                                headers=headers)\n       \n    # Check if the request was successful\n    if response.status_code == 200 :\n        print(\"Successful API call!!\")\n        response_data = response.json()\n        #print(json.dumps(response_data, indent=4, sort_keys=True))  # Print formatted JSON response\n        return response_data.get(\"latex_styled\", \"\")  # Get the LaTeX representation from the response, safely access the key\n    else:\n        print(\"Failed to get LaTeX on API call. Status code:\", response.status_code)\n        return \"\"", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def downloadDirectoryFroms3(bucketName, remoteDirectoryName):\n    s3_resource = boto3.resource('s3')\n    bucket = s3_resource.Bucket(bucketName) \n    for obj in bucket.objects.filter(Prefix = remoteDirectoryName):\n        if not os.path.exists(os.path.dirname(obj.key)):\n            os.makedirs(os.path.dirname(obj.key))\n        bucket.download_file(obj.key, obj.key) # save to same path", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def download_files(pdf_name, query_name, png_converted_pdf_path, pdfs_from_bucket_path):\n    \"\"\"\n    Returns path to PDF and query image after downloading PDF and query from the S3 bucket\n    \"\"\"\n    local_pdf = pdfs_from_bucket_path + \"/\" + pdf_name + \".pdf\"\n    local_target = png_converted_pdf_path+\"_\"+ pdf_name + \"/\" + \"query.png\"\n    print(\"local_pdf\",local_pdf)\n    print(\"pdf_name\",pdf_name)\n    print(\"local_target\", local_target)\n\n    # download and preprocess pdf to png\n    s3.download_file(\n        Bucket=BUCKET, Key=\"inputs/\"+pdf_name, Filename=local_pdf\n    )\n    \n    images = pdf2image.convert_from_path(local_pdf, dpi = 500)\n    \n    # create directory to put the converted pngs into\n    subprocess.run(f'mkdir -p {png_converted_pdf_path}_{pdf_name}', shell=True)\n    for i in range(len(images)):\n        pdf_image = png_converted_pdf_path + \"_\" + pdf_name + \"/\"+ str(i) + \".png\"\n        images[i].save(pdf_image)\n    \n    # download query png\n    s3.download_file(\n        Bucket=BUCKET, Key=\"inputs/\"+query_name, Filename=local_target\n    )\n\n    # return paths to the pdf and query that we downloaded\n    return local_pdf, f\"{png_converted_pdf_path}_{pdf_name}\", local_target", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def draw_bounding_box(image_path_in, bounding_boxes, image_path_out):\n  \"\"\"\"\n  image_path_in : path to PNG which represents page from pdf\n  bounding_boxes: list of list of bounding boxes\n  \"\"\"\n  model_width, model_height = 640,640\n  image = Image.open(image_path_in).convert('RGB')\n  draw = ImageDraw.Draw(image)\n  width, height = image.size\n  x_ratio, y_ratio = width/model_width, height/model_height\n  SKYBLUE = (55,161,253)\n\n  # create rectangle for each bounding box on this page\n  for bb in bounding_boxes:\n    x1, y1, x2, y2 = bb\n    x1, x2 = int(x_ratio*x1), int(x_ratio*x2)\n    y1, y2 = int(y_ratio*y1), int(y_ratio*y2)\n    draw.rectangle(xy=(x1, y1, x2, y2), outline=SKYBLUE, width=6)\n  \n  # save img as pdf\n  image.save(image_path_out[:-4]+\".pdf\")", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def final_output(pdf_name, bounding_boxes):\n  \"\"\"\n  bounding_boxes : dict with keys page numbers, and values list of bounding boxes \n  \"\"\"\n  IMG_IN_DIR = f\"/tmp/converted_pdfs_{pdf_name}/\"\n  IMG_OUT_DIR = \"/tmp/img_out/\"\n  subprocess.run([\"rm\", \"-rf\", IMG_OUT_DIR])\n  subprocess.run([\"mkdir\", \"-p\", IMG_OUT_DIR])\n  \n  PDF_IN_DIR = \"/tmp/pdfs_from_bucket/\"\n  PDF_OUT_DIR = \"/tmp/pdf_out/\"\n  subprocess.run([\"rm\", \"-rf\", PDF_OUT_DIR])\n  subprocess.run([\"mkdir\", \"-p\", PDF_OUT_DIR])\n\n  pdf_in = PDF_IN_DIR + pdf_name + \".pdf\"\n  pdf_out = PDF_OUT_DIR + pdf_name[:-4]+\".pdf\"\n  pdf_no_ext = pdf_name[:-4]\n\n  result_pages = list(bounding_boxes.keys())\n  print(result_pages)\n  # call draw_bounding_boxes for each png page, save to IMG_OUT_DIR\n  for i in result_pages:\n    image_path_in = IMG_IN_DIR + str(i) + \".png\"\n    image_path_out = IMG_OUT_DIR + pdf_no_ext + \"_\"+ str(i) + \".png\"\n    # pass in list of bounding boxes for each page\n    draw_bounding_box(image_path_in, bounding_boxes[i], image_path_out)\n    #s3.upload_file(image_path_out[:-4]+\".pdf\", OUTPUT_BUCKET, str(i) + \".pdf\")\n  print(\"drew bounding boxes!\")\n\n  # merge the rendered images (with bounding boxes) to the pdf, and upload to S3\n  with open(pdf_in, 'rb') as file:\n    with open(pdf_out, 'wb') as pdf_out_file:\n      pdf = PyPDF2.PdfReader(file)\n      output = PyPDF2.PdfWriter()\n      for i, page in enumerate(pdf.pages):\n        if str(i) in result_pages:\n          new_page = PyPDF2.PdfReader(IMG_OUT_DIR + pdf_no_ext + \"_\"+ str(i) + \".pdf\").pages[0]\n          new_page.scale_by(0.36)\n          output.add_page(new_page)\n        else:\n          output.add_page(page)\n      output.write(pdf_out_file)\n    \n    try:\n      s3.upload_file(pdf_out, OUTPUT_BUCKET, pdf_name[:-4]+\".pdf\")\n      print(f\"merged final pdf, uploaded {pdf_out} to {OUTPUT_BUCKET}\")\n    except:\n      raise Exception(\"Upload failed\")", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_tree_similarity(yolo_result, query_path):\n  # list containing all formatting elements we want to remove\n\n  query_text = mathpix_imgpath_to_latex(query_path)\n  print(f\"query_text: {query_text}\")\n\n  # ADD code to pre-process query string (from ML subteam)\n      \n  equations_list = []\n  for dict_elem, page_num in yolo_result:\n    eqn_num = 1\n    for img_array in dict_elem[\"cropped_ims\"]:\n      try:\n        image = Image.fromarray(np.array(img_array, dtype=np.uint8))\n        byte_stream = io.BytesIO()\n        image.save(byte_stream, format='PNG')  # Save the image to a byte stream\n        byte_stream.seek(0)\n        byte_stream.save('temp_premathpix_img')\n        latex_string = mathpix_imgpath_to_latex('temp_premathpix_img') # query_bool was previously false\n        os.remove('temp_premathpix_img')\n        print(f\"{eqn_num} on {page_num}: {latex_string}\")\n        equations_list.append((latex_string, page_num, eqn_num))\n      except Exception as e:\n        print(f\"Failed to process image or convert to LaTeX: {e}\")\n      eqn_num += 1\n\n  # equations_list = []\n  # for dict_elem, page_num in yolo_result:\n  #   eqn_num = 1\n  #   for img_elem in dict_elem[\"cropped_ims\"]:\n  #     print(f\"img_elem {img_elem}\")\n  #     print(f\"type of img_elem {type(img_elem)}\")\n\n  #     #byte_elem = np.array(byte_elem).tobytes()\n  #     byte_elem = bytes(img_elem)\n  #     print(f\"type of byte_elem {type(byte_elem)}\")\n  #     #print(img_elem)\n  #     latex_string = image_to_latex_convert(byte_elem, query_bool=False)\n  #     print(f\"{eqn_num} on {page_num}: {latex_string}\")\n\n  #     # ENTER CODE FROM ML SUB-TEAM to edit the latex string\n  #     # editing the escape_chars and preprocess_latex function\n  #     equations_list.append((latex_string, page_num, eqn_num))\n  #     eqn_num += 1 # increment equation num\n    \n  print(\"Finished all MathPix API calls!\")\n  \n  # create ZSS tree of query  \n  zss_query = source_to_zss(query_text)\n  \n  # now parse all LaTeX source code into ZSS tree and compute edit distance with query for every equation\n  # each element in tree_dist is (latex_string, edit_dist_from_query, page_num, eqn_num)\n  tree_dists = []\n  for eqn, page_num, eqn_num in equations_list:\n    zss_tree = source_to_zss(eqn)\n    dist = custom_edit_distance(zss_query, zss_tree)\n    tree_dists.append((eqn, dist, page_num, eqn_num))\n\n  # sort equations by second element in tuple i.e. edit_dist_from_query\n  # return equations with (top_n-1) smallest edit distances\n  top_n = 6 \n  sorted(tree_dists, key=lambda x: x[1])\n  return tree_dists[:top_n]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def lambda_handler(event, context):\n  try:\n      print(\"Running backend...\")\n      handler = dataHandler.DataHandler()\n      objects = handler.list_s3_objects(\"mathsearch-intermediary\")\n\n      body = json.loads(event['Records'][0]['body'])\n      receipt_handle = event['Records'][0]['receiptHandle']\n      file = body['Records'][0]['s3']['object']['key']\n      print(\"File name: \", file)\n\n      uuid = handler.extract_uuid(file)\n      expected_image = f'{uuid}_image'\n\n      if handler.is_expected_image_present(objects, expected_image):\n          print('Found image, run ML model')\n      \n          # clear tmp folder before running the ML model\n          subprocess.call('rm -rf /tmp/*', shell=True)\n\n          # folders which we download S3 bucket PDF to\n          png_converted_pdf_path = \"/tmp/converted_pdfs\"\n          pdfs_from_bucket_path = \"/tmp/pdfs_from_bucket\"\n          yolo_crops_path = \"/tmp/crops/\"\n\n          # create the pdfs_from_bucket directory if it doesn't exist\n          subprocess.run(f'mkdir -p {pdfs_from_bucket_path}', shell=True, cwd=\"/tmp\")\n          subprocess.run(f'mkdir -p {yolo_crops_path}', shell=True, cwd=\"/tmp\")\n\n          pdf_name = uuid+\"_pdf\"\n          query_name = uuid+\"_image\"\n          local_pdf, png_pdf_path, local_target = download_files(pdf_name, query_name, png_converted_pdf_path, pdfs_from_bucket_path)\n\n          ## CALL TO SAGEMAKER TO RUN YOLO\n          sm_client = boto3.client(service_name=\"sagemaker\")\n          ENDPOINT_NAME = \"mathsearch-yolov8-production-v1\"\n          endpoint_created = False\n          # start_time = time.time()\n          response = sm_client.list_endpoints()\n          for ep in response['Endpoints']:\n              print(f\"Endpoint Status = {ep['EndpointStatus']}\")\n              if ep['EndpointName']==ENDPOINT_NAME and ep['EndpointStatus']=='InService':\n                  endpoint_created = True\n\n          # return error if endpoint not created successfully\n          if not endpoint_created:\n            return {\n              'statusCode': 400,\n              'body': json.dumps('Error with Sagemaker Endpoint'),\n              'error': str(\"Error with Sagemaker Endpoint\")\n            }\n\n          predictor = PyTorchPredictor(endpoint_name=ENDPOINT_NAME,\n                            deserializer=JSONDeserializer())\n\n          print(\"Sending to Sagemaker...\")\n          yolo_result = []\n          os.chdir(png_converted_pdf_path+\"_\"+ pdf_name)\n          infer_start_time = time.time()\n          for file in os.listdir(png_pdf_path):\n            # don't need to run SageMaker on query.png\n            if file == \"query.png\": continue\n\n            print(f\"Processing {file}\")\n            \n            orig_image = cv2.imread(file)\n            model_height, model_width = 640, 640\n\n            resized_image = cv2.resize(orig_image, (model_height, model_width))\n            payload = cv2.imencode('.png', resized_image)[1].tobytes()\n\n            page_num = file.split(\".\")[0]\n            yolo_result.append((predictor.predict(payload), page_num))\n          infer_end_time = time.time()\n          print(f\"Sagemaker Inference Time = {infer_end_time - infer_start_time:0.4f} seconds\")\n\n          print(\"Sagemaker results received!\")\n          print(f\"Length of Sagemaker results: {len(yolo_result[0])}\")\n          print(yolo_result)\n\n          top5_eqns = parse_tree_similarity(yolo_result=yolo_result, query_path=local_target)\n          print(\"MathPix API calls completed, and tree similarity generated!\")\n\n          page_nums_5 = sorted([page_num for (latex_string, edit_dist, page_num, eqn_num) in top5_eqns])\n          top_5_eqns_info = [(page_num, eqn_num) for (latex_string, edit_dist, page_num, eqn_num) in top5_eqns]\n\n          # get bboxes for top5 equations\n          bboxes_dict = {}\n          for dict_elem, page_num in yolo_result:\n            # don't draw bounding boxes on pages that don't have top 5 equation\n            if page_num not in page_nums_5:\n              continue\n\n            count = 1\n            for bboxes in dict_elem[\"boxes\"]:\n              # only collect bounding boxes from top 5 equation\n              if (page_num, count) in top_5_eqns_info:\n                if page_num in bboxes_dict.keys():\n                  bboxes_dict[page_num].append(bboxes[:4])\n                else:\n                  bboxes_dict[page_num] = [bboxes[:4]]\n              count += 1\n            \n          # return JSON with the following keys\n          # id: UUID\n          # pdf : path / pdf name\n          # pages : list of page numbers sorted in order of most to least similar to query []\n          # bbox: list of tuples (page_num, [list of equation label + four coordinates of bounding box])\n          pages = sorted(page_nums_5)\n          json_result = {\"statusCode\" : 200, \"body\": \"Successfully queried and processed your document!\", \n                        \"id\": uuid, \"pdf\": pdf_name, \"pages\": pages, \"bbox\": bboxes}\n            \n          # draws the bounding boxes for the top 5 equations and converts pages back to PDF\n          # final PDF with bounding boxes saved in directory pdf_out\n          final_output(pdf_name, bboxes_dict)\n          print(f\"final json_result {json_result}\")\n      \n      # Dequeue from SQS\n      handler.delete_sqs_message(QUEUE_URL, receipt_handle)\n\n      # Upload json_result to OUTPUT_BUCKET\n      with open(f\"/tmp/{uuid}_results.json\", \"w\") as outfile: \n        json.dump(json_result, outfile)\n\n      s3.upload_file(f\"/tmp/{uuid}_results.json\", OUTPUT_BUCKET, f\"{uuid}_results.json\")\n      return json_result\n       \n  except:\n    exception = traceback.format_exc()\n    print(f\"Error: {exception}\")\n    return {\n        'statusCode': 400,\n        'body': json.dumps(f'Error processing the document.'),\n        'error': exception\n    }", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def levenshtein_distance(query_string, latex_list, top_n):\n  # elem of latex_list is (latex string, page num, eqn num)\n  ranked_list = []\n  n = len(latex_list)\n  for i in range(n):\n    latex1 = latex_list[i][0] # string is first element \n  \n    similarity_score = Levenshtein.distance(latex1, query_string)\n    ranked_list.append((latex_list[i][0], latex_list[i][1], latex_list[i][2], similarity_score))\n  \n  # Sort based on similarity score\n  ranked_list.sort(key=lambda x: x[3])\n  return ranked_list[:top_n]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def image_to_latex_convert(image, query_bool):\n\n    # Hardcoded CDS account response headers (placeholders for now)\n    headers = {\n        \"app_id\": \"mathsearch_ff86f3_059645\",\n        \"app_key\": os.environ.get(\"APP_KEY\")\n    }\n      \n    # Declare api request payload (refer to https://docs.mathpix.com/?python#introduction for description)\n    data = {\n        \"formats\": [\"latex_styled\"], \n        \"rm_fonts\": True, \n        \"rm_spaces\": False,\n        \"idiomatic_braces\": True\n    }\n\n    #print(f\"type of img sent to mathpix {type(image)}, {query_bool}\")\n    #print(f\"type after buffered reader stuff {type(io.BufferedReader(io.BytesIO(image)))}\")\n    # assume that image is stored in bytes\n    response = requests.post(\"https://api.mathpix.com/v3/text\",\n                                files={\"file\": image},\n                                data={\"options_json\": json.dumps(data)},\n                                headers=headers)\n       \n    # Check if the request was successful\n    if response.status_code == 200:\n        #print(\"Successful API call!!\")\n        response_data = response.json()\n        #print(json.dumps(response_data, indent=4, sort_keys=True))  # Print formatted JSON response\n        return response_data.get(\"latex_styled\", \"\")  # Get the LaTeX representation from the response, safely access the key\n    else:\n        print(\"Failed to get LaTeX on API call. Status code:\", response.status_code)\n        return \"\"", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def downloadDirectoryFroms3(bucketName, remoteDirectoryName):\n    s3_resource = boto3.resource('s3')\n    bucket = s3_resource.Bucket(bucketName) \n    for obj in bucket.objects.filter(Prefix = remoteDirectoryName):\n        if not os.path.exists(os.path.dirname(obj.key)):\n            os.makedirs(os.path.dirname(obj.key))\n        bucket.download_file(obj.key, obj.key) # save to same path", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def download_files(pdf_name, query_name, png_converted_pdf_path, pdfs_from_bucket_path):\n    \"\"\"\n    Returns path to PDF and query image after downloading PDF and query from the S3 bucket\n    \"\"\"\n    local_pdf = pdfs_from_bucket_path + \"/\" + pdf_name + \".pdf\"\n    local_target = png_converted_pdf_path+\"_\"+ pdf_name + \"/\" + \"query.png\"\n    print(\"local_pdf\",local_pdf)\n    print(\"pdf_name\",pdf_name)\n    print(\"local_target\", local_target)\n\n    # download and preprocess pdf to png\n    s3.download_file(\n        Bucket=BUCKET, Key=\"inputs/\"+pdf_name, Filename=local_pdf\n    )\n    \n    images = pdf2image.convert_from_path(local_pdf, dpi=500)\n    \n    # create directory to put the converted pngs into\n    subprocess.run(f'mkdir -p {png_converted_pdf_path}_{pdf_name}', shell=True)\n    for i in range(len(images)):\n        pdf_image = png_converted_pdf_path + \"_\" + pdf_name + \"/\"+ str(i) + \".png\"\n        images[i].save(pdf_image)\n    \n    # download query png\n    s3.download_file(\n        Bucket=BUCKET, Key=\"inputs/\"+query_name, Filename=local_target\n    )\n\n    # return paths to the pdf and query that we downloaded\n    return local_pdf, f\"{png_converted_pdf_path}_{pdf_name}\", local_target", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def draw_bounding_box(image_path_in, bounding_boxes):\n  \"\"\"\"\n  image_path_in : path to PNG which represents page from pdf\n  bounding_boxes: list of list of bounding boxes\n  \"\"\"\n  model_width, model_height = 640,640\n  image = Image.open(image_path_in).convert('RGB')\n  draw = ImageDraw.Draw(image)\n  width, height = image.size\n  x_ratio, y_ratio = width/model_width, height/model_height\n  #SKYBLUE = (55,161,253)\n  GREEN = (32,191,95)\n  YELLOW = (255,225,101)\n\n  # create rectangle for each bounding box on this page\n  for bb, rank in bounding_boxes:\n    x1, y1, x2, y2 = bb\n    x1, x2 = int(x_ratio*x1), int(x_ratio*x2)\n    y1, y2 = int(y_ratio*y1), int(y_ratio*y2)\n    if rank == 0: \n      draw.rectangle(xy=(x1, y1, x2, y2), outline=GREEN, width=8)\n    else:\n      draw.rectangle(xy=(x1, y1, x2, y2), outline=YELLOW, width=8)\n  \n  return image", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def final_output(pdf_name, png_pdf_path, bounding_boxes):\n  \"\"\"\n  bounding_boxes : dict with keys page numbers, and values (list of bounding boxes, eqn rank)\n  \"\"\"\n  IMG_IN_DIR = f\"/tmp/converted_pdfs_{pdf_name}/\"\n  IMG_OUT_DIR = \"/tmp/img_out/\"\n  subprocess.run([\"rm\", \"-rf\", IMG_OUT_DIR])\n  subprocess.run([\"mkdir\", \"-p\", IMG_OUT_DIR])\n  \n  PDF_IN_DIR = \"/tmp/pdfs_from_bucket/\"\n  PDF_OUT_DIR = \"/tmp/pdf_out/\"\n  subprocess.run([\"rm\", \"-rf\", PDF_OUT_DIR])\n  subprocess.run([\"mkdir\", \"-p\", PDF_OUT_DIR])\n\n  pdf_in = PDF_IN_DIR + pdf_name + \".pdf\"\n  #pdf_out = PDF_OUT_DIR + pdf_name\n  pdf_out = PDF_OUT_DIR + pdf_name[:-4]+\".pdf\"\n  #pdf_no_ext = pdf_name[:-4]\n\n  result_pages = list(bounding_boxes.keys())\n  #print(\"bounding boxes dict: \", bounding_boxes)\n\n  # call \"draw_bounding_boxes\" for each png page, save to IMG_OUT_DIR\n  # merge the rendered images (with bounding boxes) to the pdf, and upload to S3\n  paths = sorted(os.listdir(png_pdf_path))\n  pdf = FPDF()\n  for i in range(len(paths)-1):\n    #print(f\"adding {paths[i]}\")\n    if str(i) in result_pages:  \n      img = draw_bounding_box(paths[i], bounding_boxes[str(i)])\n      img.save(paths[i])\n    \n    pdf.add_page()\n    pdf.image(paths[i], 0, 0, 210, 297) # A4 paper sizing\n  pdf.output(pdf_out, \"F\")\n\n  # RESIZE_FACTOR = 0.25\n  # RESAMPLE_ALGO = Image.Resampling.LANCZOS\n  # pages = []\n  # with open(pdf_in, 'rb') as file: \n  #   pdf = PyPDF2.PdfReader(file)\n  #   for i, page in enumerate(pdf.pages):\n  #       image_path_in = IMG_IN_DIR + str(i) + \".png\"\n  #       if str(i) in result_pages:  \n  #         # pass in list of bounding boxes for each page\n  #         img = draw_bounding_box(image_path_in, bounding_boxes[str(i)])\n  #       else:\n  #         img = Image.open(image_path_in).convert('RGB')\n        \n  #       w, h = img.size\n  #       resized_image = img.resize((int(w*RESIZE_FACTOR), int(h*RESIZE_FACTOR)), resample=RESAMPLE_ALGO)\n  #       pages.append(resized_image)\n\n  # pages[0].save(pdf_out, save_all=True, append_images=pages[1:], format=\"PDF\")\n  \n  try:\n    s3.upload_file(pdf_out, OUTPUT_BUCKET, pdf_name[:-4]+\".pdf\")\n    print(f\"merged final pdf, uploaded {pdf_out} to {OUTPUT_BUCKET}\")\n  except:\n    raise Exception(\"Upload failed\")", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def rank_eqn_similarity(yolo_result, query_path, pdf_name):\n  with open(query_path, \"rb\") as f:\n    data = f.read()\n    query_text = image_to_latex_convert(data, query_bool=True)\n  query_text = query_text.replace(\" \", \"\")\n  print(f\"query_text: {query_text}\")\n      \n  equations_list = []\n  for dict_elem, page_num in yolo_result:\n    eqn_num = 1\n    \n    total_eqns = 0\n    skipped_eqns = 0\n    for bboxes in dict_elem[\"boxes\"]:\n      total_eqns += 1\n      # crop from original iamge, and send that to MathPix\n      x1, y1, x2, y2, _, label = bboxes\n\n      # skip in-line equations (not skipping everything, but not sure if its correct)\n      if label > 0.0:\n        eqn_num += 1\n        skipped_eqns += 1\n        continue\n      \n      IMG_OUT_DIR = f\"/tmp/cropped_imgs_{pdf_name}/\"\n      subprocess.run([\"rm\", \"-rf\", IMG_OUT_DIR])\n      subprocess.run([\"mkdir\", \"-p\", IMG_OUT_DIR])\n\n      crop_path = IMG_OUT_DIR + \"_p\"+ str(page_num) + \"_e\" + str(eqn_num) + \".png\"\n      page_png_path = f\"/tmp/converted_pdfs_{pdf_name}/\" + str(page_num) + \".png\"\n      model_width, model_height = 640,640\n      image = Image.open(page_png_path).convert('RGB')\n      width, height = image.size\n      x_ratio, y_ratio = width/model_width, height/model_height\n\n      # CROP original PNG with yolo bounding box coordinates\n      x1, x2 = int(x_ratio*x1), int(x_ratio*x2)\n      y1, y2 = int(y_ratio*y1), int(y_ratio*y2)\n      cropped_image = image.crop((x1, y1, x2, y2))\n      cropped_image.save(crop_path)\n      \n      latex_string = image_to_latex_convert(open(crop_path, \"rb\"), query_bool=False)\n      latex_string = latex_string.replace(\" \", \"\")\n      print(f\"{eqn_num} on {page_num}: {latex_string}\")\n      equations_list.append((latex_string, page_num, eqn_num))\n      eqn_num += 1\n    print(f\"page {page_num}: skipped {skipped_eqns} in-line eqns, out of {total_eqns}.\")\n    \n  print(\"Finished all MathPix API calls!\")\n\n  # sort equations by second element in tuple i.e. edit_dist_from_query\n  # return equations with top_n smallest edit distances\n  top_n = 5\n  sorted_lst = levenshtein_distance(query_string=query_text, latex_list=equations_list, top_n=top_n)\n  print(\"most similar eqns: \", sorted_lst)\n  return sorted_lst", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def lambda_handler(event, context):\n  try:\n      print(\"Running backend...\")\n      handler = dataHandler.DataHandler()\n      objects = handler.list_s3_objects(\"mathsearch-intermediary\")\n\n      body = json.loads(event['Records'][0]['body'])\n      receipt_handle = event['Records'][0]['receiptHandle']\n      file = body['Records'][0]['s3']['object']['key']\n      print(\"File name: \", file)\n\n      uuid = handler.extract_uuid(file)\n      expected_image = f'{uuid}_image'\n\n      if handler.is_expected_image_present(objects, expected_image):\n          print('Found image, run ML model')\n      \n          # clear tmp folder before running the ML model\n          subprocess.call('rm -rf /tmp/*', shell=True)\n\n          # folders which we download S3 bucket PDF to\n          png_converted_pdf_path = \"/tmp/converted_pdfs\"\n          pdfs_from_bucket_path = \"/tmp/pdfs_from_bucket\"\n          yolo_crops_path = \"/tmp/crops/\"\n\n          # create the pdfs_from_bucket directory if it doesn't exist\n          subprocess.run(f'mkdir -p {pdfs_from_bucket_path}', shell=True, cwd=\"/tmp\")\n          subprocess.run(f'mkdir -p {yolo_crops_path}', shell=True, cwd=\"/tmp\")\n\n          pdf_name = uuid+\"_pdf\"\n          query_name = uuid+\"_image\"\n          local_pdf, png_pdf_path, local_target = download_files(pdf_name, query_name, png_converted_pdf_path, pdfs_from_bucket_path)\n\n          ## CALL TO SAGEMAKER TO RUN YOLO\n          sm_client = boto3.client(service_name=\"sagemaker\")\n          ENDPOINT_NAME = \"mathsearch-yolov8-production-v1\"\n          endpoint_created = False\n          # start_time = time.time()\n          response = sm_client.list_endpoints()\n          for ep in response['Endpoints']:\n              print(f\"Endpoint Status = {ep['EndpointStatus']}\")\n              if ep['EndpointName']==ENDPOINT_NAME and ep['EndpointStatus']=='InService':\n                  endpoint_created = True\n\n          # return error if endpoint not created successfully\n          if not endpoint_created:\n            return {\n              'statusCode': 400,\n              'body': json.dumps('Error with Sagemaker Endpoint'),\n              'error': str(\"Error with Sagemaker Endpoint\")\n            }\n\n          predictor = PyTorchPredictor(endpoint_name=ENDPOINT_NAME,\n                            deserializer=JSONDeserializer())\n\n          print(\"Sending to Sagemaker...\")\n          yolo_result = []\n          os.chdir(png_converted_pdf_path+\"_\"+ pdf_name)\n          infer_start_time = time.time()\n          for file in os.listdir(png_pdf_path):\n            # don't need to run SageMaker on query.png\n            if file == \"query.png\": continue\n\n            print(f\"Processing {file}\")\n            \n            orig_image = cv2.imread(file)\n            model_height, model_width = 640, 640\n\n            resized_image = cv2.resize(orig_image, (model_height, model_width))\n            payload = cv2.imencode('.png', resized_image)[1].tobytes()\n\n            page_num = file.split(\".\")[0]\n            yolo_result.append((predictor.predict(payload), page_num))\n          infer_end_time = time.time()\n          print(f\"Sagemaker Inference Time = {infer_end_time - infer_start_time:0.4f} seconds\")\n\n          print(\"Sagemaker results received!\")\n          print(f\"Length of Sagemaker results: {len(yolo_result[0])}\")\n          print(yolo_result)\n\n          top5_eqns = rank_eqn_similarity(yolo_result=yolo_result, query_path=local_target, pdf_name=pdf_name)\n          print(\"MathPix API calls completed, and tree similarity generated!\")\n\n          page_nums_5 = sorted(set(([page_num for (latex_string, page_num, eqn_num, dist) in top5_eqns])))\n          top5_eqns_info = [(page_num, eqn_num) for (latex_string, page_num, eqn_num, dist) in top5_eqns]\n          #print(\"top_5_eqns_info \", top_5_eqns_info)\n\n          # sort by page number\n          bboxes_dict = {}\n          for dict_elem, page_num in yolo_result:\n            # don't draw bounding boxes on pages that don't have top 5 equation\n            if page_num not in page_nums_5:\n              continue\n            count = 1\n            for bboxes in dict_elem[\"boxes\"]:\n              # only collect bounding boxes from top 5 equation\n              if (page_num, count) in top5_eqns_info:\n                rank = top5_eqns_info.index((page_num, count))\n                if page_num in bboxes_dict.keys():\n                  bboxes_dict[page_num].append((bboxes[:4], rank))\n                else:\n                  bboxes_dict[page_num] = [(bboxes[:4], rank)]\n              count += 1\n\n          # draws the bounding boxes for the top 5 equations and converts pages back to PDF\n          # final PDF with bounding boxes saved in directory pdf_out\n          final_output(pdf_name, png_pdf_path, bboxes_dict)\n\n          # return JSON with the following keys\n          # id: UUID\n          # pdf : path / pdf name\n          # pages : list of page numbers sorted in order of most to least similar to query []\n          # bbox: list of tuples (page_num, [list of equation label + four coordinates of bounding box])\n          pages = [int(p)+1 for p in page_nums_5]\n          json_result = {\"statusCode\" : 200, \"body\": \"Successfully queried and processed your document!\", \n                        \"id\": uuid, \"pdf\": pdf_name, \"pages\": pages, \"bbox\": bboxes}\n            \n          print(f\"final json_result {json_result}\")\n      \n      # Dequeue from SQS\n      handler.delete_sqs_message(QUEUE_URL, receipt_handle)\n\n      # Upload json_result to OUTPUT_BUCKET\n      with open(f\"/tmp/{uuid}_results.json\", \"w\") as outfile: \n        json.dump(json_result, outfile)\n\n      s3.upload_file(f\"/tmp/{uuid}_results.json\", OUTPUT_BUCKET, f\"{uuid}_results.json\")\n      return json_result\n       \n  except:\n    exception = traceback.format_exc()\n    print(f\"Error: {exception}\")\n    return {\n        'statusCode': 400,\n        'body': json.dumps(f'Error processing the document.'),\n        'error': exception\n    }", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def img_input(file_name, name):\n    '''\n    Convert an image to RGB.\n\n    Args:\n        file_name: path to file\n        name: id for image\n\n    Returns:\n        (name, image): (id of image, image as RGB)\n    '''\n    image = Image.open(str(Path(file_name)))\n    image = image.convert('RGB')\n\n    return (name, image)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def augment(name, img):\n    '''\n    Add random croppings and a rotation to an latex-rendered-image.\n\n    Args:\n        name - id of image\n        img - image as a numpy array\n\n    Returns:\n        None\n\n    Raises:\n        None\n    '''\n\n    temp_path = path / name\n\n    if not temp_path.exists():\n        os.mkdir(temp_path)\n    else:\n        return\n\n    a = to_tensor(img)\n    dims = a.shape\n\n    new_dims = (int(dims[1] * proportionality),\n                int(dims[2] * proportionality))\n\n    temp_path_folder = temp_path / 'transformed'\n\n    if not temp_path_folder.exists():\n        os.mkdir(temp_path_folder)\n\n    img.save(temp_path / 'original_file.jpeg')\n\n    img_left = torch.rot90(a, dims=[1, 2])\n\n    to_pil(img_left).save(temp_path_folder / 'left_rotate.jpeg')\n\n    img_right = torch.rot90(a, k=3, dims=[1, 2])\n    to_pil(img_right).save(temp_path_folder / 'right_rotate.jpeg')\n\n    # random crop\n    for i in range(5):\n        random_crop_func = T.RandomCrop(size=new_dims)\n        test = random_crop_func(a)\n        to_pil(test).save(temp_path_folder / f'{i}_randomcrop.jpeg')\n\n    blurs = [blur(img) for _ in range(5)]\n\n    for i, j in enumerate(blurs):\n        j.save(temp_path_folder / f'{i}_blur.jpeg')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, angles):\n        self.angles = angles", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __call__(self, x):\n        angle = random.choice(self.angles)\n        return TF.rotate(x, angle)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def crop(dir, dir_save):\n    '''\n    Crops a directory of image rendered latex.\n\n    Args:\n        dir: input directory\n        dir_save: output directory\n\n    Returns:\n        None\n\n    Raises:\n        None\n    '''\n    for filename in tqdm(os.listdir(dir)):\n        f = os.path.join(dir, filename)\n\n        if os.path.isfile(f):\n            img = Image.open(f)\n            # img.show()\n\n            img = img.convert(\"RGBA\")\n            pixdata = img.load()\n            width, height = img.size\n\n            # find right\n            for x in range(width):\n                for y in range(height):\n                    if pixdata[x, y] == (0, 0, 0, 255):\n                        right = x\n                        break\n            # find left\n            for x in reversed(range(width)):\n                for y in range(height):\n                    if pixdata[x, y] == (0, 0, 0, 255):\n                        left = x\n                        break\n            # find bottom\n            for y in range(height):\n                for x in range(width):\n                    if pixdata[x, y] == (0, 0, 0, 255):\n                        bottom = y\n                        break\n            # find top\n            for y in reversed(range(height)):\n                for x in range(width):\n                    if pixdata[x, y] == (0, 0, 0, 255):\n                        top = y\n                        break\n            # print(left,top,right,bottom)\n            img = img.crop((left-220, top-110, right+220, bottom+110))\n\n            img.save(dir_save+filename, \"PNG\")", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def remove_files(data_dir):\n\tfor f in os.listdir(data_dir):\n\t\tos.remove(os.path.join(data_dir, f))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def hello_world():\n    return 'Hello World! - emerald@mathsearch port:3000 temp:1'", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def allowed_file(filename):\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def upload_file():\n    if request.method == 'POST':\n        # check if the post request has the file part\n        if 'file' not in request.files:\n            flash('No file part')\n            return redirect(request.url)\n        file = request.files['file']\n        # If the user does not select a file, the browser submits an\n        # empty file without a filename.\n        if file.filename == '':\n            flash('No selected file')\n            return redirect(request.url)\n        if file and allowed_file(file.filename):\n            filename = secure_filename(file.filename)\n            # file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n            file.save(app.config['UPLOAD_FOLDER'], filename)\n            return redirect(url_for('download_file', name=filename))\n    return '''\n    <!doctype html>\n    <title>Upload new File</title>\n    <h1>Upload new File</h1>\n    <form method=post enctype=multipart/form-data>\n      <input type=file name=file>\n      <input type=submit value=Upload>\n    </form>\n    '''", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def hello_world():\n    return 'Warning: go to http://18.207.249.45/upload instead'", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def download():\n\n    # url = request.args.get('c')\n    # wget.download(url,app.config['UPLOAD_FOLDER']+\"/file.pdf\")\n\n\n    # url = request.args.get('c')\n    # print(url)\n    # r = requests.get(url,allow_redirects=True)\n    # print(r)\n    # open(UPLOAD_FOLDER+\"/file1.pdf\",\"wb\").write(r.content)\n\n\n    # with open(app.config['UPLOAD_FOLDER']+\"/file1.pdf\", \"wb\") as file:\n    #     response = requests.get(url)\n    #     file.write(response.content)\n\n    return \"success\"", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def upload_form():\n    return render_template('upload.html')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def upload_file():\n    if request.method == 'POST':\n        # check if the post request has the file part\n        if 'file' not in request.files:\n            flash('No file part')\n            return redirect(request.url)\n        file = request.files['file']\n        if file.filename == '':\n            flash('No file selected for uploading')\n            return redirect(request.url)\n        if file and allowed_file(file.filename):\n            filename = secure_filename(file.filename)\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n            flash('File successfully uploaded')\n            return redirect('/')\n        else:\n            flash('Allowed file types are txt, pdf, png, jpg, jpeg, gif')\n            return redirect(request.url)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def hello_world():\n    return 'Hello World! - emerald@mathsearch'", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def hello_world():\n    return 'Warning: go to http://18.207.249.45/upload instead'", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def download():\n\n    # url = request.args.get('c')\n    # wget.download(url,app.config['UPLOAD_FOLDER']+\"/file.pdf\")\n\n\n    # url = request.args.get('c')\n    # print(url)\n    # r = requests.get(url,allow_redirects=True)\n    # print(r)\n    # open(UPLOAD_FOLDER+\"/file1.pdf\",\"wb\").write(r.content)\n\n\n    # with open(app.config['UPLOAD_FOLDER']+\"/file1.pdf\", \"wb\") as file:\n    #     response = requests.get(url)\n    #     file.write(response.content)\n\n    return \"success\"", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def upload_form():\n    return render_template('upload.html')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def upload_file():\n    if request.method == 'POST':\n        # check if the post request has the file part\n        if 'file' not in request.files:\n            flash('No file part')\n            return redirect(request.url)\n        file = request.files['file']\n        if file.filename == '':\n            flash('No file selected for uploading')\n            return redirect(request.url)\n        if file and allowed_file(file.filename):\n            filename = secure_filename(file.filename)\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n            flash('File successfully uploaded')\n            return redirect('/')\n        else:\n            flash('Allowed file types are txt, pdf, png, jpg, jpeg, gif')\n            return redirect(request.url)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def add_cors_headers(response):\n\tresponse.headers.add('Access-Control-Allow-Origin', '*')\n\tresponse.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')\n\t# response.headers.add('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE')\n\treturn response", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def start():\n\treturn 'visit:\\nhttp://18.207.249.45/coord\\nhttp://18.207.249.45/model\\n\\noptional:\\nhttp://18.207.249.45/upload'", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def download():\n\ts3_bucket = request.args.get('b')\n\ts3_object = request.args.get('o')\n\twith open(\"/home/ubuntu/yolov5/input_info/names.txt\", \"w\") as f:\n\t\tf.write(s3_bucket+\"\\n\"+s3_object)\n\treturn s3_bucket+\"\\n\"+s3_object+\"\\nPassed data info successfully!\"", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def allowed_file(filename):\n\treturn '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def upload_form():\n\treturn render_template('upload.html')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def upload_file():\n\tif request.method == 'POST':\n\t\t# check if the post request has the file part\n\t\tif 'file' not in request.files:\n\t\t\tflash('No file part')\n\t\t\treturn redirect(request.url)\n\t\tfile = request.files['file']\n\t\tif file.filename == '':\n\t\t\tflash('No file selected for uploading')\n\t\t\treturn redirect(request.url)\n\t\tif file and allowed_file(file.filename):\n\t\t\tfilename = secure_filename(file.filename)\n\t\t\tfile.save(os.path.join(UPLOAD_FOLDER, filename))\n\t\t\tflash('File successfully uploaded')\n\t\t\treturn redirect('/')\n\t\telse:\n\t\t\tflash('Allowed file types are txt, pdf, png, jpg, jpeg, gif')\n\t\t\treturn redirect(request.url)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def print_test():\n\treturn \"ok-update 5/6\"", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run_model():\n\tprint(\"/run called\")\n\tdata = request.json\n\tuuid = data[\"uuid\"]\n\tprint(\"before\",data[\"pdf_path\"])\n\tprint(\"before\",data[\"image_path\"])\n\tpdf_path = data[\"pdf_path\"][7:]\n\timage_path = data[\"image_path\"][7:]\n\tprint(pdf_path)\n\tprint(image_path)\n\tmessage = uuid + \" \" + pdf_path + \" \" + image_path\n\t# import time\n\t# os.chdir('/home/ubuntu/yolov5')\n\t# sys.path.append('/home/ubuntu/yolov5')\n\t# import main\n\t# main.main()\n\t# time.sleep(3)\n\t# return \"running model...\\n\\nVisit:\\nhttp://18.207.249.45/coord\\nhttp://18.207.249.45/model\\n\\noptional:\\nhttp://18.207.249.45/upload\"\n\tstart = time.time()\n\t# venv_py = \"/home/ubuntu/MathSearch/ml-model/venv/bin/python3\"\n\tvenv_py = \"/opt/conda/bin/python3\"\n\tpython_file = \"/home/ubuntu/MathSearch/ml-model/yolov5/main.py\"\n\tsubprocess.call([venv_py, python_file, pdf_path, image_path])\n\tend = time.time()\n\treturn message + \"\\nimporting ok\\naccessing yolov5/main.py ok\" + \"\\n\" + \"ML model finished running.\\nTime used: \" + str(end - start)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def get_similarity(img_1_path, img_2_path):\n  \"\"\"Computes similarity measure between 2 images. \n\n  Args:\n    img1_name: string address to 1st image\n    img2_name: string address to 2nd image\n\n  Returns:\n    Float cosine similarity from VGG embedding\n\n  Raises:\n      None\n  \"\"\"\n  img1 = torch.from_numpy(np.array(Image.open(img_1_path).convert(mode='RGB'))).permute(2, 0, 1).unsqueeze(0).float()\n  img2 = torch.from_numpy(np.array(Image.open(img_2_path).convert(mode='RGB'))).permute(2, 0, 1).unsqueeze(0).float()\n  one = feature_extrator.forward(img1).detach().flatten()\n  two = feature_extrator.forward(img2).detach().flatten()\n  return np.dot(one, two)/(np.linalg.norm(one)*np.linalg.norm(two))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "  def __init__(self, model):\n    super(FeatureExtractor, self).__init__()\n\t\t# Extract VGG-16 Feature Layers\n    self.features = list(model.features)\n    self.features = nn.Sequential(*self.features)\n\t\t# Extract VGG-16 Average Pooling Layer\n    self.pooling = model.avgpool\n\t\t# Convert the image into one-dimensional vector\n    self.flatten = nn.Flatten()\n\t\t# Extract the first part of fully-connected layer from VGG16\n    self.fc = model.classifier[0]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "  def forward(self, x):\n    \"\"\"Computes embedding layer of an image. \n\n    Args:\n      x: torch tensor representing image.\n\n    Returns:\n      Embedding tensor.\n\n    Raises:\n      None\n    \"\"\"\n\t\t# It will take the input 'x' until it returns the feature vector called 'out'\n    out = self.features(x)\n    out = self.pooling(out)\n    out = self.flatten(out)\n    out = self.fc(out) \n    return out ", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def show(imgs):\n    fix, axs = plt.subplots(ncols=len(imgs), squeeze=False)\n    for i, img in enumerate(imgs):\n        img = T.ToPILImage()(img.to('cpu'))\n        axs[0, i].imshow(np.asarray(img))\n        axs[0, i].set(xticklabels=[], yticklabels=[], xticks=[], yticks=[])\n\n    plt.savefig('test.png')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def hit_rate(topNPredicted, total, gt):\n    \"\"\"\n    Measures the fraction of images for which the correct answer is included in the recommendation list\n\n    Args:\n      topNPredicted (Dict): topNRecommendations for every image, where each key is an imageID and its respective value is the top N recommendations\n        Example: {\n          0: [1, 9, 20], 1: [3, 5, 30]\n        }\n      total (int): Length of dataset\n      gt (List): Groundtruth data\n\n    Returns:\n      Hit rate\n\n    \"\"\"\n    hits = 0\n\n    for user in gt:\n        userID = user[0]\n        imageID = user[1]\n        recommendations = topNPredicted[userID]\n        if imageID in recommendations:\n            hits += 1\n\n    return hits / total", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def mean_reciprocal_rank(topNPredicted, total, gt):\n    \"\"\"\n    Measures how far down the ranking the first relevant document is\n    MRR --> 1 means relevant results are close to the top of search results\n    MRR --> 0 indicates poorer search quality, with the right answer farther down in the search results\n\n    Args:\n      topNPredicted (Dict): topNRecommendations for every image, where each key is an imageID and its respective value is the top N recommendations\n        Example: {\n          0: [1, 9, 20], 1: [3, 5, 30]\n        }\n      total (int): Length of dataset\n      gt (List): Groundtruth data\n\n    Returns:\n      Mean Reciprocal Rank\n\n    \"\"\"\n    sum_reciprocal = 0\n    for user in gt:\n        userID = user[0]\n        imageID = user[1]\n        recommendations = topNPredicted[userID]\n        if imageID in recommendations:\n            rank = recommendations.index(imageID)\n            sum_reciprocal += 1 / (rank)\n        else:\n            raise NotImplementedError(\"Need to figure what to count if doesn't exist!\")\n\n    return sum_reciprocal / total", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def mAP(y_true, y_pred):\n    \"\"\"\n    Measures average over each ground truth label assigned to each sample\n    of the ratio of true vs. total labels with lower score\n\n    Args:\n      y_true (ndarray) of shape (n_samples, n_labels): True binary labels in binary indicator format; One hot encoded\n      y_pred (ndarray) of shape (n_samples, n_labels): Target scores, can either be probability estimates of the positive class, confidence values, or non-thresholded measure of decisions\n    \"\"\"\n    return label_ranking_average_precision_score(y_true, y_pred)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def get_similarity(img_1_path, img_2_path):\n      img1 = torch.from_numpy(np.array(Image.open(img_1_path).convert(mode='RGB'))).permute(2, 0, 1).unsqueeze(0).float()\n      img2 = torch.from_numpy(np.array(Image.open(img_2_path).convert(mode='RGB'))).permute(2, 0, 1).unsqueeze(0).float()\n      one = feature_extrator.forward(img1).detach().flatten()\n      two = feature_extrator.forward(img2).detach().flatten()\n      return np.dot(one, two)/(np.linalg.norm(one)*np.linalg.norm(two))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def manually_create_db():\n  # Get list of files written to YOLO output, except for target_file_name\n  dir_list = [str(x) for x in os.listdir('/home/ubuntu/MathSearch/ml-model/yolov5/ranking/dcopy/exp/crops/equation')]\n\n  # Construct tbl of generated crops for similarity detection model \n  img_database = pd.DataFrame(columns = ['image_name', 'image_source', 'coo_1', 'coo_2', 'coo_3', 'coo_4'])\n\n  for f in dir_list:\n    img_source, rem  = f.split(\"__\")\n    eq_number = img_source.split(\"_\")[1]\n\n    eq_number = 1 if eq_number == '' else eq_number\n\n    df = pd.read_csv('/home/ubuntu/MathSearch/ml-model/yolov5/ranking/img_database.csv', delim_whitespace=True, header=None) \n    # new_row = {'image_name': f, 'image_source': img_source, 'coo_1':df.iloc[int(eq_number) - 1, 1],  \n    # 'coo_2':df.iloc[int(eq_number) - 1, 2], 'coo_3': df.iloc[int(eq_number) - 1, 3], 'coo_4': df.iloc[int(eq_number) - 1, 4]} \n    \n    new_row = {'image_name': f, 'image_source': img_source, 'coo_1':\"\",  \n    'coo_2':\"\", 'coo_3': \"\", 'coo_4': \"\"} \n    \n    print(new_row)\n    img_database = img_database.append(new_row, ignore_index = True) \n\n  img_database.to_csv(\"/home/ubuntu/MathSearch/ml-model/yolov5/ranking/img_database.csv\") ", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "  def __init__(self, model):\n    super(FeatureExtractor, self).__init__()\n\t\t# Extract VGG-16 Feature Layers\n    self.features = list(model.features)\n    self.features = nn.Sequential(*self.features)\n\t\t# Extract VGG-16 Average Pooling Layer\n    self.pooling = model.avgpool\n\t\t# Convert the image into one-dimensional vector\n    self.flatten = nn.Flatten()\n\t\t# Extract the first part of fully-connected layer from VGG16\n    self.fc = model.classifier[0]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "  def forward(self, x):\n\t\t# It will take the input 'x' until it returns the feature vector called 'out'\n    out = self.features(x)\n    out = self.pooling(out)\n    out = self.flatten(out)\n    out = self.fc(out) \n    return out ", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run(\n    data=ROOT / '../datasets/mnist',  # dataset dir\n    weights=ROOT / 'yolov5s-cls.pt',  # model.pt path(s)\n    batch_size=128,  # batch size\n    imgsz=224,  # inference size (pixels)\n    device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n    workers=8,  # max dataloader workers (per RANK in DDP mode)\n    verbose=False,  # verbose output\n    project=ROOT / 'runs/val-cls',  # save to project/name\n    name='exp',  # save to project/name\n    exist_ok=False,  # existing project/name ok, do not increment\n    half=False,  # use FP16 half-precision inference\n    dnn=False,  # use OpenCV DNN for ONNX inference\n    model=None,\n    dataloader=None,\n    criterion=None,\n    pbar=None,\n):\n    # Initialize/load model and set device\n    training = model is not None\n    if training:  # called by train.py\n        device, pt, jit, engine = next(model.parameters()).device, True, False, False  # get model device, PyTorch model\n        half &= device.type != 'cpu'  # half precision only supported on CUDA\n        model.half() if half else model.float()\n    else:  # called directly\n        device = select_device(device, batch_size=batch_size)\n\n        # Directories\n        save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n        save_dir.mkdir(parents=True, exist_ok=True)  # make dir\n\n        # Load model\n        model = DetectMultiBackend(weights, device=device, dnn=dnn, fp16=half)\n        stride, pt, jit, engine = model.stride, model.pt, model.jit, model.engine\n        imgsz = check_img_size(imgsz, s=stride)  # check image size\n        half = model.fp16  # FP16 supported on limited backends with CUDA\n        if engine:\n            batch_size = model.batch_size\n        else:\n            device = model.device\n            if not (pt or jit):\n                batch_size = 1  # export.py models default to batch-size 1\n                LOGGER.info(f'Forcing --batch-size 1 square inference (1,3,{imgsz},{imgsz}) for non-PyTorch models')\n\n        # Dataloader\n        data = Path(data)\n        test_dir = data / 'test' if (data / 'test').exists() else data / 'val'  # data/test or data/val\n        dataloader = create_classification_dataloader(path=test_dir,\n                                                      imgsz=imgsz,\n                                                      batch_size=batch_size,\n                                                      augment=False,\n                                                      rank=-1,\n                                                      workers=workers)\n\n    model.eval()\n    pred, targets, loss, dt = [], [], 0, (Profile(), Profile(), Profile())\n    n = len(dataloader)  # number of batches\n    action = 'validating' if dataloader.dataset.root.stem == 'val' else 'testing'\n    desc = f\"{pbar.desc[:-36]}{action:>36}\" if pbar else f\"{action}\"\n    bar = tqdm(dataloader, desc, n, not training, bar_format=TQDM_BAR_FORMAT, position=0)\n    with torch.cuda.amp.autocast(enabled=device.type != 'cpu'):\n        for images, labels in bar:\n            with dt[0]:\n                images, labels = images.to(device, non_blocking=True), labels.to(device)\n\n            with dt[1]:\n                y = model(images)\n\n            with dt[2]:\n                pred.append(y.argsort(1, descending=True)[:, :5])\n                targets.append(labels)\n                if criterion:\n                    loss += criterion(y, labels)\n\n    loss /= n\n    pred, targets = torch.cat(pred), torch.cat(targets)\n    correct = (targets[:, None] == pred).float()\n    acc = torch.stack((correct[:, 0], correct.max(1).values), dim=1)  # (top1, top5) accuracy\n    top1, top5 = acc.mean(0).tolist()\n\n    if pbar:\n        pbar.desc = f\"{pbar.desc[:-36]}{loss:>12.3g}{top1:>12.3g}{top5:>12.3g}\"\n    if verbose:  # all classes\n        LOGGER.info(f\"{'Class':>24}{'Images':>12}{'top1_acc':>12}{'top5_acc':>12}\")\n        LOGGER.info(f\"{'all':>24}{targets.shape[0]:>12}{top1:>12.3g}{top5:>12.3g}\")\n        for i, c in model.names.items():\n            aci = acc[targets == i]\n            top1i, top5i = aci.mean(0).tolist()\n            LOGGER.info(f\"{c:>24}{aci.shape[0]:>12}{top1i:>12.3g}{top5i:>12.3g}\")\n\n        # Print results\n        t = tuple(x.t / len(dataloader.dataset.samples) * 1E3 for x in dt)  # speeds per image\n        shape = (1, 3, imgsz, imgsz)\n        LOGGER.info(f'Speed: %.1fms pre-process, %.1fms inference, %.1fms post-process per image at shape {shape}' % t)\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}\")\n\n    return top1, top5, loss", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_opt():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--data', type=str, default=ROOT / '../datasets/mnist', help='dataset path')\n    parser.add_argument('--weights', nargs='+', type=str, default=ROOT / 'yolov5s-cls.pt', help='model.pt path(s)')\n    parser.add_argument('--batch-size', type=int, default=128, help='batch size')\n    parser.add_argument('--imgsz', '--img', '--img-size', type=int, default=224, help='inference size (pixels)')\n    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--workers', type=int, default=8, help='max dataloader workers (per RANK in DDP mode)')\n    parser.add_argument('--verbose', nargs='?', const=True, default=True, help='verbose output')\n    parser.add_argument('--project', default=ROOT / 'runs/val-cls', help='save to project/name')\n    parser.add_argument('--name', default='exp', help='save to project/name')\n    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n    parser.add_argument('--half', action='store_true', help='use FP16 half-precision inference')\n    parser.add_argument('--dnn', action='store_true', help='use OpenCV DNN for ONNX inference')\n    opt = parser.parse_args()\n    print_args(vars(opt))\n    return opt", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(opt):\n    check_requirements(exclude=('tensorboard', 'thop'))\n    run(**vars(opt))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run(\n        weights=ROOT / 'yolov5s-cls.pt',  # model.pt path(s)\n        source=ROOT / 'data/images',  # file/dir/URL/glob/screen/0(webcam)\n        data=ROOT / 'data/coco128.yaml',  # dataset.yaml path\n        imgsz=(224, 224),  # inference size (height, width)\n        device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n        view_img=False,  # show results\n        save_txt=False,  # save results to *.txt\n        nosave=False,  # do not save images/videos\n        augment=False,  # augmented inference\n        visualize=False,  # visualize features\n        update=False,  # update all models\n        project=ROOT / 'runs/predict-cls',  # save results to project/name\n        name='exp',  # save results to project/name\n        exist_ok=False,  # existing project/name ok, do not increment\n        half=False,  # use FP16 half-precision inference\n        dnn=False,  # use OpenCV DNN for ONNX inference\n        vid_stride=1,  # video frame-rate stride\n):\n    '''\n    Function to run inference on Yolov5.\n\n    Args are as detailed as above. \n\n    Returns:\n        None - prints results and may save to a txt file.\n\n\n    Raises:\n        None\n    '''\n    source = str(source)\n    save_img = not nosave and not source.endswith(\n        '.txt')  # save inference images\n    is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)\n    is_url = source.lower().startswith(('rtsp://', 'rtmp://', 'http://', 'https://'))\n    webcam = source.isnumeric() or source.endswith(\n        '.txt') or (is_url and not is_file)\n    screenshot = source.lower().startswith('screen')\n    if is_url and is_file:\n        source = check_file(source)  # download\n\n    # Directories\n    save_dir = increment_path(Path(project) / name,\n                              exist_ok=exist_ok)  # increment run\n    (save_dir / 'labels' if save_txt else save_dir).mkdir(parents=True,\n                                                          exist_ok=True)  # make dir\n\n    # Load model\n    device = select_device(device)\n    model = DetectMultiBackend(\n        weights, device=device, dnn=dnn, data=data, fp16=half)\n    stride, names, pt = model.stride, model.names, model.pt\n    imgsz = check_img_size(imgsz, s=stride)  # check image size\n\n    # Dataloader\n    bs = 1  # batch_size\n    if webcam:\n        view_img = check_imshow(warn=True)\n        dataset = LoadStreams(source, img_size=imgsz, transforms=classify_transforms(\n            imgsz[0]), vid_stride=vid_stride)\n        bs = len(dataset)\n    elif screenshot:\n        dataset = LoadScreenshots(\n            source, img_size=imgsz, stride=stride, auto=pt)\n    else:\n        dataset = LoadImages(source, img_size=imgsz, transforms=classify_transforms(\n            imgsz[0]), vid_stride=vid_stride)\n    vid_path, vid_writer = [None] * bs, [None] * bs\n\n    # Run inference\n    model.warmup(imgsz=(1 if pt else bs, 3, *imgsz))  # warmup\n    seen, windows, dt = 0, [], (Profile(), Profile(), Profile())\n    for path, im, im0s, vid_cap, s in dataset:\n        with dt[0]:\n            im = torch.Tensor(im).to(model.device)\n            im = im.half() if model.fp16 else im.float()  # uint8 to fp16/32\n            if len(im.shape) == 3:\n                im = im[None]  # expand for batch dim\n\n        # Inference\n        with dt[1]:\n            results = model(im)\n\n        # Post-process\n        with dt[2]:\n            pred = F.softmax(results, dim=1)  # probabilities\n\n        # Process predictions\n        for i, prob in enumerate(pred):  # per image\n            seen += 1\n            if webcam:  # batch_size >= 1\n                p, im0, frame = path[i], im0s[i].copy(), dataset.count\n                s += f'{i}: '\n            else:\n                p, im0, frame = path, im0s.copy(), getattr(dataset, 'frame', 0)\n\n            p = Path(p)  # to Path\n            save_path = str(save_dir / p.name)  # im.jpg\n            txt_path = str(save_dir / 'labels' / p.stem) + \\\n                ('' if dataset.mode == 'image' else f'_{frame}')  # im.txt\n\n            s += '%gx%g ' % im.shape[2:]  # print string\n            annotator = Annotator(im0, example=str(names), pil=True)\n\n            # Print results\n            top5i = prob.argsort(0, descending=True)[\n                :5].tolist()  # top 5 indices\n            s += f\"{', '.join(f'{names[j]} {prob[j]:.2f}' for j in top5i)}, \"\n\n            # Write results\n            text = '\\n'.join(f'{prob[j]:.2f} {names[j]}' for j in top5i)\n            if save_img or view_img:  # Add bbox to image\n                annotator.text((32, 32), text, txt_color=(255, 255, 255))\n            if save_txt:  # Write to file\n                with open(f'{txt_path}.txt', 'a') as f:\n                    f.write(text + '\\n')\n\n            # Stream results\n            im0 = annotator.result()\n            if view_img:\n                if platform.system() == 'Linux' and p not in windows:\n                    windows.append(p)\n                    # allow window resize (Linux)\n                    cv2.namedWindow(str(p), cv2.WINDOW_NORMAL |\n                                    cv2.WINDOW_KEEPRATIO)\n                    cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])\n                cv2.imshow(str(p), im0)\n                cv2.waitKey(1)  # 1 millisecond\n\n            # Save results (image with detections)\n            if save_img:\n                if dataset.mode == 'image':\n                    cv2.imwrite(save_path, im0)\n                else:  # 'video' or 'stream'\n                    if vid_path[i] != save_path:  # new video\n                        vid_path[i] = save_path\n                        if isinstance(vid_writer[i], cv2.VideoWriter):\n                            # release previous video writer\n                            vid_writer[i].release()\n                        if vid_cap:  # video\n                            fps = vid_cap.get(cv2.CAP_PROP_FPS)\n                            w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n                            h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n                        else:  # stream\n                            fps, w, h = 30, im0.shape[1], im0.shape[0]\n                        # force *.mp4 suffix on results videos\n                        save_path = str(Path(save_path).with_suffix('.mp4'))\n                        vid_writer[i] = cv2.VideoWriter(\n                            save_path, cv2.VideoWriter_fourcc(*'mp4v'), fps, (w, h))\n                    vid_writer[i].write(im0)\n\n        # Print time (inference-only)\n        LOGGER.info(f\"{s}{dt[1].dt * 1E3:.1f}ms\")\n\n    # Print results\n    t = tuple(x.t / seen * 1E3 for x in dt)  # speeds per image\n    LOGGER.info(\n        f'Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {(1, 3, *imgsz)}' % t)\n    if save_txt or save_img:\n        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else ''\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n    if update:\n        # update model (to fix SourceChangeWarning)\n        strip_optimizer(weights[0])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_opt():\n    '''\n    Parsing arguments added along to the file if using a CLI.\n    '''\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--weights', nargs='+', type=str,\n                        default=ROOT / 'yolov5s-cls.pt', help='model path(s)')\n    parser.add_argument('--source', type=str, default=ROOT /\n                        'data/images', help='file/dir/URL/glob/screen/0(webcam)')\n    parser.add_argument('--data', type=str, default=ROOT /\n                        'data/coco128.yaml', help='(optional) dataset.yaml path')\n    parser.add_argument('--imgsz', '--img', '--img-size', nargs='+',\n                        type=int, default=[224], help='inference size h,w')\n    parser.add_argument('--device', default='',\n                        help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--view-img', action='store_true', help='show results')\n    parser.add_argument('--save-txt', action='store_true',\n                        help='save results to *.txt')\n    parser.add_argument('--nosave', action='store_true',\n                        help='do not save images/videos')\n    parser.add_argument('--augment', action='store_true',\n                        help='augmented inference')\n    parser.add_argument('--visualize', action='store_true',\n                        help='visualize features')\n    parser.add_argument('--update', action='store_true',\n                        help='update all models')\n    parser.add_argument('--project', default=ROOT /\n                        'runs/predict-cls', help='save results to project/name')\n    parser.add_argument('--name', default='exp',\n                        help='save results to project/name')\n    parser.add_argument('--exist-ok', action='store_true',\n                        help='existing project/name ok, do not increment')\n    parser.add_argument('--half', action='store_true',\n                        help='use FP16 half-precision inference')\n    parser.add_argument('--dnn', action='store_true',\n                        help='use OpenCV DNN for ONNX inference')\n    parser.add_argument('--vid-stride', type=int, default=1,\n                        help='video frame-rate stride')\n    opt = parser.parse_args()\n    opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # expand\n    print_args(vars(opt))\n    return opt", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(opt):\n    check_requirements(exclude=('tensorboard', 'thop'))\n    run(**vars(opt))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def train(opt, device):\n    '''\n    Main function for training Yolov5.\n\n    Args:\n        opt - options to pass for training.\n        device - device to train on\n\n    Returns:\n        None - saves checkpoints to save_dir folder in the options passed and logs reuslts\n    '''\n    init_seeds(opt.seed + 1 + RANK, deterministic=True)\n    save_dir, data, bs, epochs, nw, imgsz, pretrained = \\\n        opt.save_dir, Path(opt.data), opt.batch_size, opt.epochs, min(os.cpu_count() - 1, opt.workers), \\\n        opt.imgsz, str(opt.pretrained).lower() == 'true'\n    cuda = device.type != 'cpu'\n\n    # Directories\n    wdir = save_dir / 'weights'\n    wdir.mkdir(parents=True, exist_ok=True)  # make dir\n    last, best = wdir / 'last.pt', wdir / 'best.pt'\n\n    # Save run settings\n    yaml_save(save_dir / 'opt.yaml', vars(opt))\n\n    # Logger\n    logger = GenericLogger(\n        opt=opt, console_logger=LOGGER) if RANK in {-1, 0} else None\n\n    # Download Dataset\n    with torch_distributed_zero_first(LOCAL_RANK), WorkingDirectory(ROOT):\n        data_dir = data if data.is_dir() else (DATASETS_DIR / data)\n        if not data_dir.is_dir():\n            LOGGER.info(\n                f'\\nDataset not found \u26a0\ufe0f, missing path {data_dir}, attempting download...')\n            t = time.time()\n            if str(data) == 'imagenet':\n                subprocess.run(\n                    f\"bash {ROOT / 'data/scripts/get_imagenet.sh'}\", shell=True, check=True)\n            else:\n                url = f'https://github.com/ultralytics/yolov5/releases/download/v1.0/{data}.zip'\n                download(url, dir=data_dir.parent)\n            s = f\"Dataset download success \u2705 ({time.time() - t:.1f}s), saved to {colorstr('bold', data_dir)}\\n\"\n            LOGGER.info(s)\n\n    # Dataloaders\n    nc = len([x for x in (data_dir / 'train').glob('*')\n             if x.is_dir()])  # number of classes\n    trainloader = create_classification_dataloader(path=data_dir / 'train',\n                                                   imgsz=imgsz,\n                                                   batch_size=bs // WORLD_SIZE,\n                                                   augment=True,\n                                                   cache=opt.cache,\n                                                   rank=LOCAL_RANK,\n                                                   workers=nw)\n\n    # data/test or data/val\n    test_dir = data_dir / \\\n        'test' if (data_dir / 'test').exists() else data_dir / 'val'\n    if RANK in {-1, 0}:\n        testloader = create_classification_dataloader(path=test_dir,\n                                                      imgsz=imgsz,\n                                                      batch_size=bs // WORLD_SIZE * 2,\n                                                      augment=False,\n                                                      cache=opt.cache,\n                                                      rank=-1,\n                                                      workers=nw)\n\n    # Model\n    with torch_distributed_zero_first(LOCAL_RANK), WorkingDirectory(ROOT):\n        if Path(opt.model).is_file() or opt.model.endswith('.pt'):\n            model = attempt_load(opt.model, device='cpu', fuse=False)\n        elif opt.model in torchvision.models.__dict__:  # TorchVision models i.e. resnet50, efficientnet_b0\n            model = torchvision.models.__dict__[opt.model](\n                weights='IMAGENET1K_V1' if pretrained else None)\n        else:\n            # + hub.list('pytorch/vision')  # models\n            m = hub.list('ultralytics/yolov5')\n            raise ModuleNotFoundError(\n                f'--model {opt.model} not found. Available models are: \\n' + '\\n'.join(m))\n        if isinstance(model, DetectionModel):\n            LOGGER.warning(\n                \"WARNING \u26a0\ufe0f pass YOLOv5 classifier model with '-cls' suffix, i.e. '--model yolov5s-cls.pt'\")\n            # convert to classification model\n            model = ClassificationModel(\n                model=model, nc=nc, cutoff=opt.cutoff or 10)\n        reshape_classifier_output(model, nc)  # update class count\n    for m in model.modules():\n        if not pretrained and hasattr(m, 'reset_parameters'):\n            m.reset_parameters()\n        if isinstance(m, torch.nn.Dropout) and opt.dropout is not None:\n            m.p = opt.dropout  # set dropout\n    for p in model.parameters():\n        p.requires_grad = True  # for training\n    model = model.to(device)\n\n    # Info\n    if RANK in {-1, 0}:\n        model.names = trainloader.dataset.classes  # attach class names\n        model.transforms = testloader.dataset.torch_transforms  # attach inference transforms\n        model_info(model)\n        if opt.verbose:\n            LOGGER.info(model)\n        images, labels = next(iter(trainloader))\n        file = imshow_cls(\n            images[:25], labels[:25], names=model.names, f=save_dir / 'train_images.jpg')\n        logger.log_images(file, name='Train Examples')\n        logger.log_graph(model, imgsz)  # log model\n\n    # Optimizer\n    optimizer = smart_optimizer(\n        model, opt.optimizer, opt.lr0, momentum=0.9, decay=opt.decay)\n\n    # Scheduler\n    lrf = 0.01  # final lr (fraction of lr0)\n    # lf = lambda x: ((1 + math.cos(x * math.pi / epochs)) / 2) * (1 - lrf) + lrf  # cosine\n    def lf(x): return (1 - x / epochs) * (1 - lrf) + lrf  # linear\n    scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf)\n    # scheduler = lr_scheduler.OneCycleLR(optimizer, max_lr=lr0, total_steps=epochs, pct_start=0.1,\n    #                                    final_div_factor=1 / 25 / lrf)\n\n    # EMA\n    ema = ModelEMA(model) if RANK in {-1, 0} else None\n\n    # DDP mode\n    if cuda and RANK != -1:\n        model = smart_DDP(model)\n\n    # Train\n    t0 = time.time()\n    criterion = smartCrossEntropyLoss(\n        label_smoothing=opt.label_smoothing)  # loss function\n    best_fitness = 0.0\n    scaler = amp.GradScaler(enabled=cuda)\n    val = test_dir.stem  # 'val' or 'test'\n    LOGGER.info(f'Image sizes {imgsz} train, {imgsz} test\\n'\n                f'Using {nw * WORLD_SIZE} dataloader workers\\n'\n                f\"Logging results to {colorstr('bold', save_dir)}\\n\"\n                f'Starting {opt.model} training on {data} dataset with {nc} classes for {epochs} epochs...\\n\\n'\n                f\"{'Epoch':>10}{'GPU_mem':>10}{'train_loss':>12}{f'{val}_loss':>12}{'top1_acc':>12}{'top5_acc':>12}\")\n    for epoch in range(epochs):  # loop over the dataset multiple times\n        tloss, vloss, fitness = 0.0, 0.0, 0.0  # train loss, val loss, fitness\n        model.train()\n        if RANK != -1:\n            trainloader.sampler.set_epoch(epoch)\n        pbar = enumerate(trainloader)\n        if RANK in {-1, 0}:\n            pbar = tqdm(enumerate(trainloader), total=len(\n                trainloader), bar_format=TQDM_BAR_FORMAT)\n        for i, (images, labels) in pbar:  # progress bar\n            images, labels = images.to(\n                device, non_blocking=True), labels.to(device)\n\n            # Forward\n            with amp.autocast(enabled=cuda):  # stability issues when enabled\n                loss = criterion(model(images), labels)\n\n            # Backward\n            scaler.scale(loss).backward()\n\n            # Optimize\n            scaler.unscale_(optimizer)  # unscale gradients\n            torch.nn.utils.clip_grad_norm_(\n                model.parameters(), max_norm=10.0)  # clip gradients\n            scaler.step(optimizer)\n            scaler.update()\n            optimizer.zero_grad()\n            if ema:\n                ema.update(model)\n\n            if RANK in {-1, 0}:\n                # Print\n                tloss = (tloss * i + loss.item()) / \\\n                    (i + 1)  # update mean losses\n                mem = '%.3gG' % (torch.cuda.memory_reserved(\n                ) / 1E9 if torch.cuda.is_available() else 0)  # (GB)\n                pbar.desc = f\"{f'{epoch + 1}/{epochs}':>10}{mem:>10}{tloss:>12.3g}\" + ' ' * 36\n\n                # Test\n                if i == len(pbar) - 1:  # last batch\n                    top1, top5, vloss = validate.run(model=ema.ema,\n                                                     dataloader=testloader,\n                                                     criterion=criterion,\n                                                     pbar=pbar)  # test accuracy, loss\n                    fitness = top1  # define fitness as top1 accuracy\n\n        # Scheduler\n        scheduler.step()\n\n        # Log metrics\n        if RANK in {-1, 0}:\n            # Best fitness\n            if fitness > best_fitness:\n                best_fitness = fitness\n\n            # Log\n            metrics = {\n                \"train/loss\": tloss,\n                f\"{val}/loss\": vloss,\n                \"metrics/accuracy_top1\": top1,\n                \"metrics/accuracy_top5\": top5,\n                \"lr/0\": optimizer.param_groups[0]['lr']}  # learning rate\n            logger.log_metrics(metrics, epoch)\n\n            # Save model\n            final_epoch = epoch + 1 == epochs\n            if (not opt.nosave) or final_epoch:\n                ckpt = {\n                    'epoch': epoch,\n                    'best_fitness': best_fitness,\n                    # deepcopy(de_parallel(model)).half(),\n                    'model': deepcopy(ema.ema).half(),\n                    'ema': None,  # deepcopy(ema.ema).half(),\n                    'updates': ema.updates,\n                    'optimizer': None,  # optimizer.state_dict(),\n                    'opt': vars(opt),\n                    'git': GIT_INFO,  # {remote, branch, commit} if a git repo\n                    'date': datetime.now().isoformat()}\n\n                # Save last, best and delete\n                torch.save(ckpt, last)\n                if best_fitness == fitness:\n                    torch.save(ckpt, best)\n                del ckpt\n\n    # Train complete\n    if RANK in {-1, 0} and final_epoch:\n        LOGGER.info(f'\\nTraining complete ({(time.time() - t0) / 3600:.3f} hours)'\n                    f\"\\nResults saved to {colorstr('bold', save_dir)}\"\n                    f\"\\nPredict:         python classify/predict.py --weights {best} --source im.jpg\"\n                    f\"\\nValidate:        python classify/val.py --weights {best} --data {data_dir}\"\n                    f\"\\nExport:          python export.py --weights {best} --include onnx\"\n                    f\"\\nPyTorch Hub:     model = torch.hub.load('ultralytics/yolov5', 'custom', '{best}')\"\n                    f\"\\nVisualize:       https://netron.app\\n\")\n\n        # Plot examples\n        # first 25 images and labels\n        images, labels = (x[:25] for x in next(iter(testloader)))\n        pred = torch.max(ema.ema(images.to(device)), 1)[1]\n        file = imshow_cls(images, labels, pred, model.names,\n                          verbose=False, f=save_dir / 'test_images.jpg')\n\n        # Log results\n        meta = {\"epochs\": epochs, \"top1_acc\": best_fitness,\n                \"date\": datetime.now().isoformat()}\n        logger.log_images(\n            file, name='Test Examples (true-predicted)', epoch=epoch)\n        logger.log_model(best, epochs, metadata=meta)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_opt(known=False):\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--model', type=str,\n                        default='yolov5s-cls.pt', help='initial weights path')\n    parser.add_argument('--data', type=str, default='imagenette160',\n                        help='cifar10, cifar100, mnist, imagenet, ...')\n    parser.add_argument('--epochs', type=int, default=10,\n                        help='total training epochs')\n    parser.add_argument('--batch-size', type=int, default=64,\n                        help='total batch size for all GPUs')\n    parser.add_argument('--imgsz', '--img', '--img-size', type=int,\n                        default=224, help='train, val image size (pixels)')\n    parser.add_argument('--nosave', action='store_true',\n                        help='only save final checkpoint')\n    parser.add_argument('--cache', type=str, nargs='?', const='ram',\n                        help='--cache images in \"ram\" (default) or \"disk\"')\n    parser.add_argument('--device', default='',\n                        help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--workers', type=int, default=8,\n                        help='max dataloader workers (per RANK in DDP mode)')\n    parser.add_argument('--project', default=ROOT /\n                        'runs/train-cls', help='save to project/name')\n    parser.add_argument('--name', default='exp', help='save to project/name')\n    parser.add_argument('--exist-ok', action='store_true',\n                        help='existing project/name ok, do not increment')\n    parser.add_argument('--pretrained', nargs='?', const=True,\n                        default=True, help='start from i.e. --pretrained False')\n    parser.add_argument(\n        '--optimizer', choices=['SGD', 'Adam', 'AdamW', 'RMSProp'], default='Adam', help='optimizer')\n    parser.add_argument('--lr0', type=float, default=0.001,\n                        help='initial learning rate')\n    parser.add_argument('--decay', type=float,\n                        default=5e-5, help='weight decay')\n    parser.add_argument('--label-smoothing', type=float,\n                        default=0.1, help='Label smoothing epsilon')\n    parser.add_argument('--cutoff', type=int, default=None,\n                        help='Model layer cutoff index for Classify() head')\n    parser.add_argument('--dropout', type=float,\n                        default=None, help='Dropout (fraction)')\n    parser.add_argument('--verbose', action='store_true', help='Verbose mode')\n    parser.add_argument('--seed', type=int, default=0,\n                        help='Global training seed')\n    parser.add_argument('--local_rank', type=int, default=-1,\n                        help='Automatic DDP Multi-GPU argument, do not modify')\n    return parser.parse_known_args()[0] if known else parser.parse_args()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(opt):\n    # Checks\n    if RANK in {-1, 0}:\n        print_args(vars(opt))\n        check_git_status()\n        check_requirements()\n\n    # DDP mode\n    device = select_device(opt.device, batch_size=opt.batch_size)\n    if LOCAL_RANK != -1:\n        assert opt.batch_size != - \\\n            1, 'AutoBatch is coming soon for classification, please pass a valid --batch-size'\n        assert opt.batch_size % WORLD_SIZE == 0, f'--batch-size {opt.batch_size} must be multiple of WORLD_SIZE'\n        assert torch.cuda.device_count() > LOCAL_RANK, 'insufficient CUDA devices for DDP command'\n        torch.cuda.set_device(LOCAL_RANK)\n        device = torch.device('cuda', LOCAL_RANK)\n        dist.init_process_group(\n            backend=\"nccl\" if dist.is_nccl_available() else \"gloo\")\n\n    # Parameters\n    opt.save_dir = increment_path(\n        Path(opt.project) / opt.name, exist_ok=opt.exist_ok)  # increment run\n\n    # Train\n    train(opt, device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run(**kwargs):\n    # Usage: from yolov5 import classify; classify.train.run(data=mnist, imgsz=320, model='yolov5m')\n    opt = parse_opt(True)\n    for k, v in kwargs.items():\n        setattr(opt, k, v)\n    main(opt)\n    return opt", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def lf(x): return (1 - x / epochs) * (1 - lrf) + lrf  # linear", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def save_one_txt(predn, save_conf, shape, file):\n    # Save one txt result\n    gn = torch.tensor(shape)[[1, 0, 1, 0]]  # normalization gain whwh\n    for *xyxy, conf, cls in predn.tolist():\n        xywh = (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh\n        line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format\n        with open(file, 'a') as f:\n            f.write(('%g ' * len(line)).rstrip() % line + '\\n')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def save_one_json(predn, jdict, path, class_map):\n    # Save one JSON result {\"image_id\": 42, \"category_id\": 18, \"bbox\": [258.15, 41.29, 348.26, 243.78], \"score\": 0.236}\n    image_id = int(path.stem) if path.stem.isnumeric() else path.stem\n    box = xyxy2xywh(predn[:, :4])  # xywh\n    box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner\n    for p, b in zip(predn.tolist(), box.tolist()):\n        jdict.append({\n            'image_id': image_id,\n            'category_id': class_map[int(p[5])],\n            'bbox': [round(x, 3) for x in b],\n            'score': round(p[4], 5)})", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def process_batch(detections, labels, iouv):\n    \"\"\"\n    Return correct prediction matrix\n    Arguments:\n        detections (array[N, 6]), x1, y1, x2, y2, conf, class\n        labels (array[M, 5]), class, x1, y1, x2, y2\n    Returns:\n        correct (array[N, 10]), for 10 IoU levels\n    \"\"\"\n    correct = np.zeros((detections.shape[0], iouv.shape[0])).astype(bool)\n    iou = box_iou(labels[:, 1:], detections[:, :4])\n    correct_class = labels[:, 0:1] == detections[:, 5]\n    for i in range(len(iouv)):\n        x = torch.where((iou >= iouv[i]) & correct_class)  # IoU > threshold and classes match\n        if x[0].shape[0]:\n            matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()  # [label, detect, iou]\n            if x[0].shape[0] > 1:\n                matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 1], return_index=True)[1]]\n                # matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 0], return_index=True)[1]]\n            correct[matches[:, 1].astype(int), i] = True\n    return torch.tensor(correct, dtype=torch.bool, device=iouv.device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run(\n        data,\n        weights=None,  # model.pt path(s)\n        batch_size=32,  # batch size\n        imgsz=640,  # inference size (pixels)\n        conf_thres=0.001,  # confidence threshold\n        iou_thres=0.6,  # NMS IoU threshold\n        max_det=300,  # maximum detections per image\n        task='val',  # train, val, test, speed or study\n        device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n        workers=8,  # max dataloader workers (per RANK in DDP mode)\n        single_cls=False,  # treat as single-class dataset\n        augment=False,  # augmented inference\n        verbose=False,  # verbose output\n        save_txt=False,  # save results to *.txt\n        save_hybrid=False,  # save label+prediction hybrid results to *.txt\n        save_conf=False,  # save confidences in --save-txt labels\n        save_json=False,  # save a COCO-JSON results file\n        project=ROOT / 'runs/val',  # save to project/name\n        name='exp',  # save to project/name\n        exist_ok=False,  # existing project/name ok, do not increment\n        half=True,  # use FP16 half-precision inference\n        dnn=False,  # use OpenCV DNN for ONNX inference\n        model=None,\n        dataloader=None,\n        save_dir=Path(''),\n        plots=True,\n        callbacks=Callbacks(),\n        compute_loss=None,\n):\n    # Initialize/load model and set device\n    training = model is not None\n    if training:  # called by train.py\n        device, pt, jit, engine = next(model.parameters()).device, True, False, False  # get model device, PyTorch model\n        half &= device.type != 'cpu'  # half precision only supported on CUDA\n        model.half() if half else model.float()\n    else:  # called directly\n        device = select_device(device, batch_size=batch_size)\n\n        # Directories\n        save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n        (save_dir / 'labels' if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # make dir\n\n        # Load model\n        model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)\n        stride, pt, jit, engine = model.stride, model.pt, model.jit, model.engine\n        imgsz = check_img_size(imgsz, s=stride)  # check image size\n        half = model.fp16  # FP16 supported on limited backends with CUDA\n        if engine:\n            batch_size = model.batch_size\n        else:\n            device = model.device\n            if not (pt or jit):\n                batch_size = 1  # export.py models default to batch-size 1\n                LOGGER.info(f'Forcing --batch-size 1 square inference (1,3,{imgsz},{imgsz}) for non-PyTorch models')\n\n        # Data\n        data = check_dataset(data)  # check\n\n    # Configure\n    model.eval()\n    cuda = device.type != 'cpu'\n    is_coco = isinstance(data.get('val'), str) and data['val'].endswith(f'coco{os.sep}val2017.txt')  # COCO dataset\n    nc = 1 if single_cls else int(data['nc'])  # number of classes\n    iouv = torch.linspace(0.5, 0.95, 10, device=device)  # iou vector for mAP@0.5:0.95\n    niou = iouv.numel()\n\n    # Dataloader\n    if not training:\n        if pt and not single_cls:  # check --weights are trained on --data\n            ncm = model.model.nc\n            assert ncm == nc, f'{weights} ({ncm} classes) trained on different --data than what you passed ({nc} ' \\\n                              f'classes). Pass correct combination of --weights and --data that are trained together.'\n        model.warmup(imgsz=(1 if pt else batch_size, 3, imgsz, imgsz))  # warmup\n        pad, rect = (0.0, False) if task == 'speed' else (0.5, pt)  # square inference for benchmarks\n        task = task if task in ('train', 'val', 'test') else 'val'  # path to train/val/test images\n        dataloader = create_dataloader(data[task],\n                                       imgsz,\n                                       batch_size,\n                                       stride,\n                                       single_cls,\n                                       pad=pad,\n                                       rect=rect,\n                                       workers=workers,\n                                       prefix=colorstr(f'{task}: '))[0]\n\n    seen = 0\n    confusion_matrix = ConfusionMatrix(nc=nc)\n    names = model.names if hasattr(model, 'names') else model.module.names  # get class names\n    if isinstance(names, (list, tuple)):  # old format\n        names = dict(enumerate(names))\n    class_map = coco80_to_coco91_class() if is_coco else list(range(1000))\n    s = ('%22s' + '%11s' * 6) % ('Class', 'Images', 'Instances', 'P', 'R', 'mAP50', 'mAP50-95')\n    tp, fp, p, r, f1, mp, mr, map50, ap50, map = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0\n    dt = Profile(), Profile(), Profile()  # profiling times\n    loss = torch.zeros(3, device=device)\n    jdict, stats, ap, ap_class = [], [], [], []\n    callbacks.run('on_val_start')\n    pbar = tqdm(dataloader, desc=s, bar_format=TQDM_BAR_FORMAT)  # progress bar\n    for batch_i, (im, targets, paths, shapes) in enumerate(pbar):\n        callbacks.run('on_val_batch_start')\n        with dt[0]:\n            if cuda:\n                im = im.to(device, non_blocking=True)\n                targets = targets.to(device)\n            im = im.half() if half else im.float()  # uint8 to fp16/32\n            im /= 255  # 0 - 255 to 0.0 - 1.0\n            nb, _, height, width = im.shape  # batch size, channels, height, width\n\n        # Inference\n        with dt[1]:\n            preds, train_out = model(im) if compute_loss else (model(im, augment=augment), None)\n\n        # Loss\n        if compute_loss:\n            loss += compute_loss(train_out, targets)[1]  # box, obj, cls\n\n        # NMS\n        targets[:, 2:] *= torch.tensor((width, height, width, height), device=device)  # to pixels\n        lb = [targets[targets[:, 0] == i, 1:] for i in range(nb)] if save_hybrid else []  # for autolabelling\n        with dt[2]:\n            preds = non_max_suppression(preds,\n                                        conf_thres,\n                                        iou_thres,\n                                        labels=lb,\n                                        multi_label=True,\n                                        agnostic=single_cls,\n                                        max_det=max_det)\n\n        # Metrics\n        for si, pred in enumerate(preds):\n            labels = targets[targets[:, 0] == si, 1:]\n            nl, npr = labels.shape[0], pred.shape[0]  # number of labels, predictions\n            path, shape = Path(paths[si]), shapes[si][0]\n            correct = torch.zeros(npr, niou, dtype=torch.bool, device=device)  # init\n            seen += 1\n\n            if npr == 0:\n                if nl:\n                    stats.append((correct, *torch.zeros((2, 0), device=device), labels[:, 0]))\n                    if plots:\n                        confusion_matrix.process_batch(detections=None, labels=labels[:, 0])\n                continue\n\n            # Predictions\n            if single_cls:\n                pred[:, 5] = 0\n            predn = pred.clone()\n            scale_boxes(im[si].shape[1:], predn[:, :4], shape, shapes[si][1])  # native-space pred\n\n            # Evaluate\n            if nl:\n                tbox = xywh2xyxy(labels[:, 1:5])  # target boxes\n                scale_boxes(im[si].shape[1:], tbox, shape, shapes[si][1])  # native-space labels\n                labelsn = torch.cat((labels[:, 0:1], tbox), 1)  # native-space labels\n                correct = process_batch(predn, labelsn, iouv)\n                if plots:\n                    confusion_matrix.process_batch(predn, labelsn)\n            stats.append((correct, pred[:, 4], pred[:, 5], labels[:, 0]))  # (correct, conf, pcls, tcls)\n\n            # Save/log\n            if save_txt:\n                save_one_txt(predn, save_conf, shape, file=save_dir / 'labels' / f'{path.stem}.txt')\n            if save_json:\n                save_one_json(predn, jdict, path, class_map)  # append to COCO-JSON dictionary\n            callbacks.run('on_val_image_end', pred, predn, path, names, im[si])\n\n        # Plot images\n        if plots and batch_i < 3:\n            plot_images(im, targets, paths, save_dir / f'val_batch{batch_i}_labels.jpg', names)  # labels\n            plot_images(im, output_to_target(preds), paths, save_dir / f'val_batch{batch_i}_pred.jpg', names)  # pred\n\n        callbacks.run('on_val_batch_end', batch_i, im, targets, paths, shapes, preds)\n\n    # Compute metrics\n    stats = [torch.cat(x, 0).cpu().numpy() for x in zip(*stats)]  # to numpy\n    if len(stats) and stats[0].any():\n        tp, fp, p, r, f1, ap, ap_class = ap_per_class(*stats, plot=plots, save_dir=save_dir, names=names)\n        ap50, ap = ap[:, 0], ap.mean(1)  # AP@0.5, AP@0.5:0.95\n        mp, mr, map50, map = p.mean(), r.mean(), ap50.mean(), ap.mean()\n    nt = np.bincount(stats[3].astype(int), minlength=nc)  # number of targets per class\n\n    # Print results\n    pf = '%22s' + '%11i' * 2 + '%11.3g' * 4  # print format\n    LOGGER.info(pf % ('all', seen, nt.sum(), mp, mr, map50, map))\n    if nt.sum() == 0:\n        LOGGER.warning(f'WARNING \u26a0\ufe0f no labels found in {task} set, can not compute metrics without labels')\n\n    # Print results per class\n    if (verbose or (nc < 50 and not training)) and nc > 1 and len(stats):\n        for i, c in enumerate(ap_class):\n            LOGGER.info(pf % (names[c], seen, nt[c], p[i], r[i], ap50[i], ap[i]))\n\n    # Print speeds\n    t = tuple(x.t / seen * 1E3 for x in dt)  # speeds per image\n    if not training:\n        shape = (batch_size, 3, imgsz, imgsz)\n        LOGGER.info(f'Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {shape}' % t)\n\n    # Plots\n    if plots:\n        confusion_matrix.plot(save_dir=save_dir, names=list(names.values()))\n        callbacks.run('on_val_end', nt, tp, fp, p, r, f1, ap, ap50, ap_class, confusion_matrix)\n\n    # Save JSON\n    if save_json and len(jdict):\n        w = Path(weights[0] if isinstance(weights, list) else weights).stem if weights is not None else ''  # weights\n        anno_json = str(Path(data.get('path', '../coco')) / 'annotations/instances_val2017.json')  # annotations json\n        pred_json = str(save_dir / f\"{w}_predictions.json\")  # predictions json\n        LOGGER.info(f'\\nEvaluating pycocotools mAP... saving {pred_json}...')\n        with open(pred_json, 'w') as f:\n            json.dump(jdict, f)\n\n        try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb\n            check_requirements('pycocotools')\n            from pycocotools.coco import COCO\n            from pycocotools.cocoeval import COCOeval\n\n            anno = COCO(anno_json)  # init annotations api\n            pred = anno.loadRes(pred_json)  # init predictions api\n            eval = COCOeval(anno, pred, 'bbox')\n            if is_coco:\n                eval.params.imgIds = [int(Path(x).stem) for x in dataloader.dataset.im_files]  # image IDs to evaluate\n            eval.evaluate()\n            eval.accumulate()\n            eval.summarize()\n            map, map50 = eval.stats[:2]  # update results (mAP@0.5:0.95, mAP@0.5)\n        except Exception as e:\n            LOGGER.info(f'pycocotools unable to run: {e}')\n\n    # Return results\n    model.float()  # for training\n    if not training:\n        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else ''\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n    maps = np.zeros(nc) + map\n    for i, c in enumerate(ap_class):\n        maps[c] = ap[i]\n    return (mp, mr, map50, map, *(loss.cpu() / len(dataloader)).tolist()), maps, t", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_opt():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128.yaml', help='dataset.yaml path')\n    parser.add_argument('--weights', nargs='+', type=str, default=ROOT / 'yolov5s.pt', help='model path(s)')\n    parser.add_argument('--batch-size', type=int, default=32, help='batch size')\n    parser.add_argument('--imgsz', '--img', '--img-size', type=int, default=640, help='inference size (pixels)')\n    parser.add_argument('--conf-thres', type=float, default=0.001, help='confidence threshold')\n    parser.add_argument('--iou-thres', type=float, default=0.6, help='NMS IoU threshold')\n    parser.add_argument('--max-det', type=int, default=300, help='maximum detections per image')\n    parser.add_argument('--task', default='val', help='train, val, test, speed or study')\n    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--workers', type=int, default=8, help='max dataloader workers (per RANK in DDP mode)')\n    parser.add_argument('--single-cls', action='store_true', help='treat as single-class dataset')\n    parser.add_argument('--augment', action='store_true', help='augmented inference')\n    parser.add_argument('--verbose', action='store_true', help='report mAP by class')\n    parser.add_argument('--save-txt', action='store_true', help='save results to *.txt')\n    parser.add_argument('--save-hybrid', action='store_true', help='save label+prediction hybrid results to *.txt')\n    parser.add_argument('--save-conf', action='store_true', help='save confidences in --save-txt labels')\n    parser.add_argument('--save-json', action='store_true', help='save a COCO-JSON results file')\n    parser.add_argument('--project', default=ROOT / 'runs/val', help='save to project/name')\n    parser.add_argument('--name', default='exp', help='save to project/name')\n    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n    parser.add_argument('--half', action='store_true', help='use FP16 half-precision inference')\n    parser.add_argument('--dnn', action='store_true', help='use OpenCV DNN for ONNX inference')\n    opt = parser.parse_args()\n    opt.data = check_yaml(opt.data)  # check YAML\n    opt.save_json |= opt.data.endswith('coco.yaml')\n    opt.save_txt |= opt.save_hybrid\n    print_args(vars(opt))\n    return opt", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(opt):\n    check_requirements(exclude=('tensorboard', 'thop'))\n\n    if opt.task in ('train', 'val', 'test'):  # run normally\n        if opt.conf_thres > 0.001:  # https://github.com/ultralytics/yolov5/issues/1466\n            LOGGER.info(f'WARNING \u26a0\ufe0f confidence threshold {opt.conf_thres} > 0.001 produces invalid results')\n        if opt.save_hybrid:\n            LOGGER.info('WARNING \u26a0\ufe0f --save-hybrid will return high mAP from hybrid labels, not from predictions alone')\n        run(**vars(opt))\n\n    else:\n        weights = opt.weights if isinstance(opt.weights, list) else [opt.weights]\n        opt.half = torch.cuda.is_available() and opt.device != 'cpu'  # FP16 for fastest results\n        if opt.task == 'speed':  # speed benchmarks\n            # python val.py --task speed --data coco.yaml --batch 1 --weights yolov5n.pt yolov5s.pt...\n            opt.conf_thres, opt.iou_thres, opt.save_json = 0.25, 0.45, False\n            for opt.weights in weights:\n                run(**vars(opt), plots=False)\n\n        elif opt.task == 'study':  # speed vs mAP benchmarks\n            # python val.py --task study --data coco.yaml --iou 0.7 --weights yolov5n.pt yolov5s.pt...\n            for opt.weights in weights:\n                f = f'study_{Path(opt.data).stem}_{Path(opt.weights).stem}.txt'  # filename to save to\n                x, y = list(range(256, 1536 + 128, 128)), []  # x axis (image sizes), y axis\n                for opt.imgsz in x:  # img-size\n                    LOGGER.info(f'\\nRunning {f} --imgsz {opt.imgsz}...')\n                    r, _, t = run(**vars(opt), plots=False)\n                    y.append(r + t)  # results and times\n                np.savetxt(f, y, fmt='%10.4g')  # save\n            os.system('zip -r study.zip study_*.txt')\n            plot_val_study(x=x)  # plot", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def save_one_txt(predn, save_conf, shape, file):\n    # Save one txt result\n    gn = torch.tensor(shape)[[1, 0, 1, 0]]  # normalization gain whwh\n    for *xyxy, conf, cls in predn.tolist():\n        xywh = (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh\n        line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format\n        with open(file, 'a') as f:\n            f.write(('%g ' * len(line)).rstrip() % line + '\\n')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def save_one_json(predn, jdict, path, class_map, pred_masks):\n    # Save one JSON result {\"image_id\": 42, \"category_id\": 18, \"bbox\": [258.15, 41.29, 348.26, 243.78], \"score\": 0.236}\n    from pycocotools.mask import encode\n\n    def single_encode(x):\n        rle = encode(np.asarray(x[:, :, None], order=\"F\", dtype=\"uint8\"))[0]\n        rle[\"counts\"] = rle[\"counts\"].decode(\"utf-8\")\n        return rle\n\n    image_id = int(path.stem) if path.stem.isnumeric() else path.stem\n    box = xyxy2xywh(predn[:, :4])  # xywh\n    box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner\n    pred_masks = np.transpose(pred_masks, (2, 0, 1))\n    with ThreadPool(NUM_THREADS) as pool:\n        rles = pool.map(single_encode, pred_masks)\n    for i, (p, b) in enumerate(zip(predn.tolist(), box.tolist())):\n        jdict.append({\n            'image_id': image_id,\n            'category_id': class_map[int(p[5])],\n            'bbox': [round(x, 3) for x in b],\n            'score': round(p[4], 5),\n            'segmentation': rles[i]})", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def process_batch(detections, labels, iouv, pred_masks=None, gt_masks=None, overlap=False, masks=False):\n    \"\"\"\n    Return correct prediction matrix\n    Arguments:\n        detections (array[N, 6]), x1, y1, x2, y2, conf, class\n        labels (array[M, 5]), class, x1, y1, x2, y2\n    Returns:\n        correct (array[N, 10]), for 10 IoU levels\n    \"\"\"\n    if masks:\n        if overlap:\n            nl = len(labels)\n            index = torch.arange(nl, device=gt_masks.device).view(nl, 1, 1) + 1\n            gt_masks = gt_masks.repeat(nl, 1, 1)  # shape(1,640,640) -> (n,640,640)\n            gt_masks = torch.where(gt_masks == index, 1.0, 0.0)\n        if gt_masks.shape[1:] != pred_masks.shape[1:]:\n            gt_masks = F.interpolate(gt_masks[None], pred_masks.shape[1:], mode=\"bilinear\", align_corners=False)[0]\n            gt_masks = gt_masks.gt_(0.5)\n        iou = mask_iou(gt_masks.view(gt_masks.shape[0], -1), pred_masks.view(pred_masks.shape[0], -1))\n    else:  # boxes\n        iou = box_iou(labels[:, 1:], detections[:, :4])\n\n    correct = np.zeros((detections.shape[0], iouv.shape[0])).astype(bool)\n    correct_class = labels[:, 0:1] == detections[:, 5]\n    for i in range(len(iouv)):\n        x = torch.where((iou >= iouv[i]) & correct_class)  # IoU > threshold and classes match\n        if x[0].shape[0]:\n            matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()  # [label, detect, iou]\n            if x[0].shape[0] > 1:\n                matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 1], return_index=True)[1]]\n                # matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 0], return_index=True)[1]]\n            correct[matches[:, 1].astype(int), i] = True\n    return torch.tensor(correct, dtype=torch.bool, device=iouv.device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run(\n        data,\n        weights=None,  # model.pt path(s)\n        batch_size=32,  # batch size\n        imgsz=640,  # inference size (pixels)\n        conf_thres=0.001,  # confidence threshold\n        iou_thres=0.6,  # NMS IoU threshold\n        max_det=300,  # maximum detections per image\n        task='val',  # train, val, test, speed or study\n        device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n        workers=8,  # max dataloader workers (per RANK in DDP mode)\n        single_cls=False,  # treat as single-class dataset\n        augment=False,  # augmented inference\n        verbose=False,  # verbose output\n        save_txt=False,  # save results to *.txt\n        save_hybrid=False,  # save label+prediction hybrid results to *.txt\n        save_conf=False,  # save confidences in --save-txt labels\n        save_json=False,  # save a COCO-JSON results file\n        project=ROOT / 'runs/val-seg',  # save to project/name\n        name='exp',  # save to project/name\n        exist_ok=False,  # existing project/name ok, do not increment\n        half=True,  # use FP16 half-precision inference\n        dnn=False,  # use OpenCV DNN for ONNX inference\n        model=None,\n        dataloader=None,\n        save_dir=Path(''),\n        plots=True,\n        overlap=False,\n        mask_downsample_ratio=1,\n        compute_loss=None,\n        callbacks=Callbacks(),\n):\n    if save_json:\n        check_requirements(['pycocotools'])\n        process = process_mask_upsample  # more accurate\n    else:\n        process = process_mask  # faster\n\n    # Initialize/load model and set device\n    training = model is not None\n    if training:  # called by train.py\n        device, pt, jit, engine = next(model.parameters()).device, True, False, False  # get model device, PyTorch model\n        half &= device.type != 'cpu'  # half precision only supported on CUDA\n        model.half() if half else model.float()\n        nm = de_parallel(model).model[-1].nm  # number of masks\n    else:  # called directly\n        device = select_device(device, batch_size=batch_size)\n\n        # Directories\n        save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n        (save_dir / 'labels' if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # make dir\n\n        # Load model\n        model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)\n        stride, pt, jit, engine = model.stride, model.pt, model.jit, model.engine\n        imgsz = check_img_size(imgsz, s=stride)  # check image size\n        half = model.fp16  # FP16 supported on limited backends with CUDA\n        nm = de_parallel(model).model.model[-1].nm if isinstance(model, SegmentationModel) else 32  # number of masks\n        if engine:\n            batch_size = model.batch_size\n        else:\n            device = model.device\n            if not (pt or jit):\n                batch_size = 1  # export.py models default to batch-size 1\n                LOGGER.info(f'Forcing --batch-size 1 square inference (1,3,{imgsz},{imgsz}) for non-PyTorch models')\n\n        # Data\n        data = check_dataset(data)  # check\n\n    # Configure\n    model.eval()\n    cuda = device.type != 'cpu'\n    is_coco = isinstance(data.get('val'), str) and data['val'].endswith(f'coco{os.sep}val2017.txt')  # COCO dataset\n    nc = 1 if single_cls else int(data['nc'])  # number of classes\n    iouv = torch.linspace(0.5, 0.95, 10, device=device)  # iou vector for mAP@0.5:0.95\n    niou = iouv.numel()\n\n    # Dataloader\n    if not training:\n        if pt and not single_cls:  # check --weights are trained on --data\n            ncm = model.model.nc\n            assert ncm == nc, f'{weights} ({ncm} classes) trained on different --data than what you passed ({nc} ' \\\n                              f'classes). Pass correct combination of --weights and --data that are trained together.'\n        model.warmup(imgsz=(1 if pt else batch_size, 3, imgsz, imgsz))  # warmup\n        pad, rect = (0.0, False) if task == 'speed' else (0.5, pt)  # square inference for benchmarks\n        task = task if task in ('train', 'val', 'test') else 'val'  # path to train/val/test images\n        dataloader = create_dataloader(data[task],\n                                       imgsz,\n                                       batch_size,\n                                       stride,\n                                       single_cls,\n                                       pad=pad,\n                                       rect=rect,\n                                       workers=workers,\n                                       prefix=colorstr(f'{task}: '),\n                                       overlap_mask=overlap,\n                                       mask_downsample_ratio=mask_downsample_ratio)[0]\n\n    seen = 0\n    confusion_matrix = ConfusionMatrix(nc=nc)\n    names = model.names if hasattr(model, 'names') else model.module.names  # get class names\n    if isinstance(names, (list, tuple)):  # old format\n        names = dict(enumerate(names))\n    class_map = coco80_to_coco91_class() if is_coco else list(range(1000))\n    s = ('%22s' + '%11s' * 10) % ('Class', 'Images', 'Instances', 'Box(P', \"R\", \"mAP50\", \"mAP50-95)\", \"Mask(P\", \"R\",\n                                  \"mAP50\", \"mAP50-95)\")\n    dt = Profile(), Profile(), Profile()\n    metrics = Metrics()\n    loss = torch.zeros(4, device=device)\n    jdict, stats = [], []\n    # callbacks.run('on_val_start')\n    pbar = tqdm(dataloader, desc=s, bar_format=TQDM_BAR_FORMAT)  # progress bar\n    for batch_i, (im, targets, paths, shapes, masks) in enumerate(pbar):\n        # callbacks.run('on_val_batch_start')\n        with dt[0]:\n            if cuda:\n                im = im.to(device, non_blocking=True)\n                targets = targets.to(device)\n                masks = masks.to(device)\n            masks = masks.float()\n            im = im.half() if half else im.float()  # uint8 to fp16/32\n            im /= 255  # 0 - 255 to 0.0 - 1.0\n            nb, _, height, width = im.shape  # batch size, channels, height, width\n\n        # Inference\n        with dt[1]:\n            preds, protos, train_out = model(im) if compute_loss else (*model(im, augment=augment)[:2], None)\n\n        # Loss\n        if compute_loss:\n            loss += compute_loss((train_out, protos), targets, masks)[1]  # box, obj, cls\n\n        # NMS\n        targets[:, 2:] *= torch.tensor((width, height, width, height), device=device)  # to pixels\n        lb = [targets[targets[:, 0] == i, 1:] for i in range(nb)] if save_hybrid else []  # for autolabelling\n        with dt[2]:\n            preds = non_max_suppression(preds,\n                                        conf_thres,\n                                        iou_thres,\n                                        labels=lb,\n                                        multi_label=True,\n                                        agnostic=single_cls,\n                                        max_det=max_det,\n                                        nm=nm)\n\n        # Metrics\n        plot_masks = []  # masks for plotting\n        for si, (pred, proto) in enumerate(zip(preds, protos)):\n            labels = targets[targets[:, 0] == si, 1:]\n            nl, npr = labels.shape[0], pred.shape[0]  # number of labels, predictions\n            path, shape = Path(paths[si]), shapes[si][0]\n            correct_masks = torch.zeros(npr, niou, dtype=torch.bool, device=device)  # init\n            correct_bboxes = torch.zeros(npr, niou, dtype=torch.bool, device=device)  # init\n            seen += 1\n\n            if npr == 0:\n                if nl:\n                    stats.append((correct_masks, correct_bboxes, *torch.zeros((2, 0), device=device), labels[:, 0]))\n                    if plots:\n                        confusion_matrix.process_batch(detections=None, labels=labels[:, 0])\n                continue\n\n            # Masks\n            midx = [si] if overlap else targets[:, 0] == si\n            gt_masks = masks[midx]\n            pred_masks = process(proto, pred[:, 6:], pred[:, :4], shape=im[si].shape[1:])\n\n            # Predictions\n            if single_cls:\n                pred[:, 5] = 0\n            predn = pred.clone()\n            scale_boxes(im[si].shape[1:], predn[:, :4], shape, shapes[si][1])  # native-space pred\n\n            # Evaluate\n            if nl:\n                tbox = xywh2xyxy(labels[:, 1:5])  # target boxes\n                scale_boxes(im[si].shape[1:], tbox, shape, shapes[si][1])  # native-space labels\n                labelsn = torch.cat((labels[:, 0:1], tbox), 1)  # native-space labels\n                correct_bboxes = process_batch(predn, labelsn, iouv)\n                correct_masks = process_batch(predn, labelsn, iouv, pred_masks, gt_masks, overlap=overlap, masks=True)\n                if plots:\n                    confusion_matrix.process_batch(predn, labelsn)\n            stats.append((correct_masks, correct_bboxes, pred[:, 4], pred[:, 5], labels[:, 0]))  # (conf, pcls, tcls)\n\n            pred_masks = torch.as_tensor(pred_masks, dtype=torch.uint8)\n            if plots and batch_i < 3:\n                plot_masks.append(pred_masks[:15].cpu())  # filter top 15 to plot\n\n            # Save/log\n            if save_txt:\n                save_one_txt(predn, save_conf, shape, file=save_dir / 'labels' / f'{path.stem}.txt')\n            if save_json:\n                pred_masks = scale_image(im[si].shape[1:],\n                                         pred_masks.permute(1, 2, 0).contiguous().cpu().numpy(), shape, shapes[si][1])\n                save_one_json(predn, jdict, path, class_map, pred_masks)  # append to COCO-JSON dictionary\n            # callbacks.run('on_val_image_end', pred, predn, path, names, im[si])\n\n        # Plot images\n        if plots and batch_i < 3:\n            if len(plot_masks):\n                plot_masks = torch.cat(plot_masks, dim=0)\n            plot_images_and_masks(im, targets, masks, paths, save_dir / f'val_batch{batch_i}_labels.jpg', names)\n            plot_images_and_masks(im, output_to_target(preds, max_det=15), plot_masks, paths,\n                                  save_dir / f'val_batch{batch_i}_pred.jpg', names)  # pred\n\n        # callbacks.run('on_val_batch_end')\n\n    # Compute metrics\n    stats = [torch.cat(x, 0).cpu().numpy() for x in zip(*stats)]  # to numpy\n    if len(stats) and stats[0].any():\n        results = ap_per_class_box_and_mask(*stats, plot=plots, save_dir=save_dir, names=names)\n        metrics.update(results)\n    nt = np.bincount(stats[4].astype(int), minlength=nc)  # number of targets per class\n\n    # Print results\n    pf = '%22s' + '%11i' * 2 + '%11.3g' * 8  # print format\n    LOGGER.info(pf % (\"all\", seen, nt.sum(), *metrics.mean_results()))\n    if nt.sum() == 0:\n        LOGGER.warning(f'WARNING \u26a0\ufe0f no labels found in {task} set, can not compute metrics without labels')\n\n    # Print results per class\n    if (verbose or (nc < 50 and not training)) and nc > 1 and len(stats):\n        for i, c in enumerate(metrics.ap_class_index):\n            LOGGER.info(pf % (names[c], seen, nt[c], *metrics.class_result(i)))\n\n    # Print speeds\n    t = tuple(x.t / seen * 1E3 for x in dt)  # speeds per image\n    if not training:\n        shape = (batch_size, 3, imgsz, imgsz)\n        LOGGER.info(f'Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {shape}' % t)\n\n    # Plots\n    if plots:\n        confusion_matrix.plot(save_dir=save_dir, names=list(names.values()))\n    # callbacks.run('on_val_end')\n\n    mp_bbox, mr_bbox, map50_bbox, map_bbox, mp_mask, mr_mask, map50_mask, map_mask = metrics.mean_results()\n\n    # Save JSON\n    if save_json and len(jdict):\n        w = Path(weights[0] if isinstance(weights, list) else weights).stem if weights is not None else ''  # weights\n        anno_json = str(Path(data.get('path', '../coco')) / 'annotations/instances_val2017.json')  # annotations json\n        pred_json = str(save_dir / f\"{w}_predictions.json\")  # predictions json\n        LOGGER.info(f'\\nEvaluating pycocotools mAP... saving {pred_json}...')\n        with open(pred_json, 'w') as f:\n            json.dump(jdict, f)\n\n        try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb\n            from pycocotools.coco import COCO\n            from pycocotools.cocoeval import COCOeval\n\n            anno = COCO(anno_json)  # init annotations api\n            pred = anno.loadRes(pred_json)  # init predictions api\n            results = []\n            for eval in COCOeval(anno, pred, 'bbox'), COCOeval(anno, pred, 'segm'):\n                if is_coco:\n                    eval.params.imgIds = [int(Path(x).stem) for x in dataloader.dataset.im_files]  # img ID to evaluate\n                eval.evaluate()\n                eval.accumulate()\n                eval.summarize()\n                results.extend(eval.stats[:2])  # update results (mAP@0.5:0.95, mAP@0.5)\n            map_bbox, map50_bbox, map_mask, map50_mask = results\n        except Exception as e:\n            LOGGER.info(f'pycocotools unable to run: {e}')\n\n    # Return results\n    model.float()  # for training\n    if not training:\n        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else ''\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n    final_metric = mp_bbox, mr_bbox, map50_bbox, map_bbox, mp_mask, mr_mask, map50_mask, map_mask\n    return (*final_metric, *(loss.cpu() / len(dataloader)).tolist()), metrics.get_maps(nc), t", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_opt():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128-seg.yaml', help='dataset.yaml path')\n    parser.add_argument('--weights', nargs='+', type=str, default=ROOT / 'yolov5s-seg.pt', help='model path(s)')\n    parser.add_argument('--batch-size', type=int, default=32, help='batch size')\n    parser.add_argument('--imgsz', '--img', '--img-size', type=int, default=640, help='inference size (pixels)')\n    parser.add_argument('--conf-thres', type=float, default=0.001, help='confidence threshold')\n    parser.add_argument('--iou-thres', type=float, default=0.6, help='NMS IoU threshold')\n    parser.add_argument('--max-det', type=int, default=300, help='maximum detections per image')\n    parser.add_argument('--task', default='val', help='train, val, test, speed or study')\n    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--workers', type=int, default=8, help='max dataloader workers (per RANK in DDP mode)')\n    parser.add_argument('--single-cls', action='store_true', help='treat as single-class dataset')\n    parser.add_argument('--augment', action='store_true', help='augmented inference')\n    parser.add_argument('--verbose', action='store_true', help='report mAP by class')\n    parser.add_argument('--save-txt', action='store_true', help='save results to *.txt')\n    parser.add_argument('--save-hybrid', action='store_true', help='save label+prediction hybrid results to *.txt')\n    parser.add_argument('--save-conf', action='store_true', help='save confidences in --save-txt labels')\n    parser.add_argument('--save-json', action='store_true', help='save a COCO-JSON results file')\n    parser.add_argument('--project', default=ROOT / 'runs/val-seg', help='save results to project/name')\n    parser.add_argument('--name', default='exp', help='save to project/name')\n    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n    parser.add_argument('--half', action='store_true', help='use FP16 half-precision inference')\n    parser.add_argument('--dnn', action='store_true', help='use OpenCV DNN for ONNX inference')\n    opt = parser.parse_args()\n    opt.data = check_yaml(opt.data)  # check YAML\n    # opt.save_json |= opt.data.endswith('coco.yaml')\n    opt.save_txt |= opt.save_hybrid\n    print_args(vars(opt))\n    return opt", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(opt):\n    check_requirements(requirements=ROOT / 'requirements.txt', exclude=('tensorboard', 'thop'))\n\n    if opt.task in ('train', 'val', 'test'):  # run normally\n        if opt.conf_thres > 0.001:  # https://github.com/ultralytics/yolov5/issues/1466\n            LOGGER.warning(f'WARNING \u26a0\ufe0f confidence threshold {opt.conf_thres} > 0.001 produces invalid results')\n        if opt.save_hybrid:\n            LOGGER.warning('WARNING \u26a0\ufe0f --save-hybrid returns high mAP from hybrid labels, not from predictions alone')\n        run(**vars(opt))\n\n    else:\n        weights = opt.weights if isinstance(opt.weights, list) else [opt.weights]\n        opt.half = torch.cuda.is_available() and opt.device != 'cpu'  # FP16 for fastest results\n        if opt.task == 'speed':  # speed benchmarks\n            # python val.py --task speed --data coco.yaml --batch 1 --weights yolov5n.pt yolov5s.pt...\n            opt.conf_thres, opt.iou_thres, opt.save_json = 0.25, 0.45, False\n            for opt.weights in weights:\n                run(**vars(opt), plots=False)\n\n        elif opt.task == 'study':  # speed vs mAP benchmarks\n            # python val.py --task study --data coco.yaml --iou 0.7 --weights yolov5n.pt yolov5s.pt...\n            for opt.weights in weights:\n                f = f'study_{Path(opt.data).stem}_{Path(opt.weights).stem}.txt'  # filename to save to\n                x, y = list(range(256, 1536 + 128, 128)), []  # x axis (image sizes), y axis\n                for opt.imgsz in x:  # img-size\n                    LOGGER.info(f'\\nRunning {f} --imgsz {opt.imgsz}...')\n                    r, _, t = run(**vars(opt), plots=False)\n                    y.append(r + t)  # results and times\n                np.savetxt(f, y, fmt='%10.4g')  # save\n            os.system('zip -r study.zip study_*.txt')\n            plot_val_study(x=x)  # plot", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def single_encode(x):\n        rle = encode(np.asarray(x[:, :, None], order=\"F\", dtype=\"uint8\"))[0]\n        rle[\"counts\"] = rle[\"counts\"].decode(\"utf-8\")\n        return rle", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run(\n    weights=ROOT / 'yolov5s-seg.pt',  # model.pt path(s)\n    source=ROOT / 'data/images',  # file/dir/URL/glob/screen/0(webcam)\n    data=ROOT / 'data/coco128.yaml',  # dataset.yaml path\n    imgsz=(640, 640),  # inference size (height, width)\n    conf_thres=0.25,  # confidence threshold\n    iou_thres=0.45,  # NMS IOU threshold\n    max_det=1000,  # maximum detections per image\n    device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n    view_img=False,  # show results\n    save_txt=False,  # save results to *.txt\n    save_conf=False,  # save confidences in --save-txt labels\n    save_crop=False,  # save cropped prediction boxes\n    nosave=False,  # do not save images/videos\n    classes=None,  # filter by class: --class 0, or --class 0 2 3\n    agnostic_nms=False,  # class-agnostic NMS\n    augment=False,  # augmented inference\n    visualize=False,  # visualize features\n    update=False,  # update all models\n    project=ROOT / 'runs/predict-seg',  # save results to project/name\n    name='exp',  # save results to project/name\n    exist_ok=False,  # existing project/name ok, do not increment\n    line_thickness=3,  # bounding box thickness (pixels)\n    hide_labels=False,  # hide labels\n    hide_conf=False,  # hide confidences\n    half=False,  # use FP16 half-precision inference\n    dnn=False,  # use OpenCV DNN for ONNX inference\n    vid_stride=1,  # video frame-rate stride\n    retina_masks=False,\n):\n    source = str(source)\n    save_img = not nosave and not source.endswith('.txt')  # save inference images\n    is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)\n    is_url = source.lower().startswith(('rtsp://', 'rtmp://', 'http://', 'https://'))\n    webcam = source.isnumeric() or source.endswith('.txt') or (is_url and not is_file)\n    screenshot = source.lower().startswith('screen')\n    if is_url and is_file:\n        source = check_file(source)  # download\n\n    # Directories\n    save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n    (save_dir / 'labels' if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # make dir\n\n    # Load model\n    device = select_device(device)\n    model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)\n    stride, names, pt = model.stride, model.names, model.pt\n    imgsz = check_img_size(imgsz, s=stride)  # check image size\n\n    # Dataloader\n    bs = 1  # batch_size\n    if webcam:\n        view_img = check_imshow(warn=True)\n        dataset = LoadStreams(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n        bs = len(dataset)\n    elif screenshot:\n        dataset = LoadScreenshots(source, img_size=imgsz, stride=stride, auto=pt)\n    else:\n        dataset = LoadImages(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n    vid_path, vid_writer = [None] * bs, [None] * bs\n\n    # Run inference\n    model.warmup(imgsz=(1 if pt else bs, 3, *imgsz))  # warmup\n    seen, windows, dt = 0, [], (Profile(), Profile(), Profile())\n    for path, im, im0s, vid_cap, s in dataset:\n        with dt[0]:\n            im = torch.from_numpy(im).to(model.device)\n            im = im.half() if model.fp16 else im.float()  # uint8 to fp16/32\n            im /= 255  # 0 - 255 to 0.0 - 1.0\n            if len(im.shape) == 3:\n                im = im[None]  # expand for batch dim\n\n        # Inference\n        with dt[1]:\n            visualize = increment_path(save_dir / Path(path).stem, mkdir=True) if visualize else False\n            pred, proto = model(im, augment=augment, visualize=visualize)[:2]\n\n        # NMS\n        with dt[2]:\n            pred = non_max_suppression(pred, conf_thres, iou_thres, classes, agnostic_nms, max_det=max_det, nm=32)\n\n        # Second-stage classifier (optional)\n        # pred = utils.general.apply_classifier(pred, classifier_model, im, im0s)\n\n        # Process predictions\n        for i, det in enumerate(pred):  # per image\n            seen += 1\n            if webcam:  # batch_size >= 1\n                p, im0, frame = path[i], im0s[i].copy(), dataset.count\n                s += f'{i}: '\n            else:\n                p, im0, frame = path, im0s.copy(), getattr(dataset, 'frame', 0)\n\n            p = Path(p)  # to Path\n            save_path = str(save_dir / p.name)  # im.jpg\n            txt_path = str(save_dir / 'labels' / p.stem) + ('' if dataset.mode == 'image' else f'_{frame}')  # im.txt\n            s += '%gx%g ' % im.shape[2:]  # print string\n            imc = im0.copy() if save_crop else im0  # for save_crop\n            annotator = Annotator(im0, line_width=line_thickness, example=str(names))\n            if len(det):\n                masks = process_mask(proto[i], det[:, 6:], det[:, :4], im.shape[2:], upsample=True)  # HWC\n                det[:, :4] = scale_boxes(im.shape[2:], det[:, :4], im0.shape).round()  # rescale boxes to im0 size\n\n                # Segments\n                if save_txt:\n                    segments = reversed(masks2segments(masks))\n                    segments = [scale_segments(im.shape[2:], x, im0.shape, normalize=True) for x in segments]\n\n                # Print results\n                for c in det[:, 5].unique():\n                    n = (det[:, 5] == c).sum()  # detections per class\n                    s += f\"{n} {names[int(c)]}{'s' * (n > 1)}, \"  # add to string\n\n                # Mask plotting\n                annotator.masks(masks,\n                                colors=[colors(x, True) for x in det[:, 5]],\n                                im_gpu=None if retina_masks else im[i])\n\n                # Write results\n                for j, (*xyxy, conf, cls) in enumerate(reversed(det[:, :6])):\n                    if save_txt:  # Write to file\n                        segj = segments[j].reshape(-1)  # (n,2) to (n*2)\n                        line = (cls, *segj, conf) if save_conf else (cls, *segj)  # label format\n                        with open(f'{txt_path}.txt', 'a') as f:\n                            f.write(('%g ' * len(line)).rstrip() % line + '\\n')\n\n                    if save_img or save_crop or view_img:  # Add bbox to image\n                        c = int(cls)  # integer class\n                        label = None if hide_labels else (names[c] if hide_conf else f'{names[c]} {conf:.2f}')\n                        annotator.box_label(xyxy, label, color=colors(c, True))\n                        # annotator.draw.polygon(segments[j], outline=colors(c, True), width=3)\n                    if save_crop:\n                        save_one_box(xyxy, imc, file=save_dir / 'crops' / names[c] / f'{p.stem}.jpg', BGR=True)\n\n            # Stream results\n            im0 = annotator.result()\n            if view_img:\n                if platform.system() == 'Linux' and p not in windows:\n                    windows.append(p)\n                    cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # allow window resize (Linux)\n                    cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])\n                cv2.imshow(str(p), im0)\n                if cv2.waitKey(1) == ord('q'):  # 1 millisecond\n                    exit()\n\n            # Save results (image with detections)\n            if save_img:\n                if dataset.mode == 'image':\n                    cv2.imwrite(save_path, im0)\n                else:  # 'video' or 'stream'\n                    if vid_path[i] != save_path:  # new video\n                        vid_path[i] = save_path\n                        if isinstance(vid_writer[i], cv2.VideoWriter):\n                            vid_writer[i].release()  # release previous video writer\n                        if vid_cap:  # video\n                            fps = vid_cap.get(cv2.CAP_PROP_FPS)\n                            w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n                            h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n                        else:  # stream\n                            fps, w, h = 30, im0.shape[1], im0.shape[0]\n                        save_path = str(Path(save_path).with_suffix('.mp4'))  # force *.mp4 suffix on results videos\n                        vid_writer[i] = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*'mp4v'), fps, (w, h))\n                    vid_writer[i].write(im0)\n\n        # Print time (inference-only)\n        LOGGER.info(f\"{s}{'' if len(det) else '(no detections), '}{dt[1].dt * 1E3:.1f}ms\")\n\n    # Print results\n    t = tuple(x.t / seen * 1E3 for x in dt)  # speeds per image\n    LOGGER.info(f'Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {(1, 3, *imgsz)}' % t)\n    if save_txt or save_img:\n        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else ''\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n    if update:\n        strip_optimizer(weights[0])  # update model (to fix SourceChangeWarning)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_opt():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--weights', nargs='+', type=str, default=ROOT / 'yolov5s-seg.pt', help='model path(s)')\n    parser.add_argument('--source', type=str, default=ROOT / 'data/images', help='file/dir/URL/glob/screen/0(webcam)')\n    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128.yaml', help='(optional) dataset.yaml path')\n    parser.add_argument('--imgsz', '--img', '--img-size', nargs='+', type=int, default=[640], help='inference size h,w')\n    parser.add_argument('--conf-thres', type=float, default=0.25, help='confidence threshold')\n    parser.add_argument('--iou-thres', type=float, default=0.45, help='NMS IoU threshold')\n    parser.add_argument('--max-det', type=int, default=1000, help='maximum detections per image')\n    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--view-img', action='store_true', help='show results')\n    parser.add_argument('--save-txt', action='store_true', help='save results to *.txt')\n    parser.add_argument('--save-conf', action='store_true', help='save confidences in --save-txt labels')\n    parser.add_argument('--save-crop', action='store_true', help='save cropped prediction boxes')\n    parser.add_argument('--nosave', action='store_true', help='do not save images/videos')\n    parser.add_argument('--classes', nargs='+', type=int, help='filter by class: --classes 0, or --classes 0 2 3')\n    parser.add_argument('--agnostic-nms', action='store_true', help='class-agnostic NMS')\n    parser.add_argument('--augment', action='store_true', help='augmented inference')\n    parser.add_argument('--visualize', action='store_true', help='visualize features')\n    parser.add_argument('--update', action='store_true', help='update all models')\n    parser.add_argument('--project', default=ROOT / 'runs/predict-seg', help='save results to project/name')\n    parser.add_argument('--name', default='exp', help='save results to project/name')\n    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n    parser.add_argument('--line-thickness', default=3, type=int, help='bounding box thickness (pixels)')\n    parser.add_argument('--hide-labels', default=False, action='store_true', help='hide labels')\n    parser.add_argument('--hide-conf', default=False, action='store_true', help='hide confidences')\n    parser.add_argument('--half', action='store_true', help='use FP16 half-precision inference')\n    parser.add_argument('--dnn', action='store_true', help='use OpenCV DNN for ONNX inference')\n    parser.add_argument('--vid-stride', type=int, default=1, help='video frame-rate stride')\n    parser.add_argument('--retina-masks', action='store_true', help='whether to plot masks in native resolution')\n    opt = parser.parse_args()\n    opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # expand\n    print_args(vars(opt))\n    return opt", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(opt):\n    check_requirements(exclude=('tensorboard', 'thop'))\n    run(**vars(opt))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def train(hyp, opt, device, callbacks):  # hyp is path/to/hyp.yaml or hyp dictionary\n    save_dir, epochs, batch_size, weights, single_cls, evolve, data, cfg, resume, noval, nosave, workers, freeze, mask_ratio = \\\n        Path(opt.save_dir), opt.epochs, opt.batch_size, opt.weights, opt.single_cls, opt.evolve, opt.data, opt.cfg, \\\n        opt.resume, opt.noval, opt.nosave, opt.workers, opt.freeze, opt.mask_ratio\n    # callbacks.run('on_pretrain_routine_start')\n\n    # Directories\n    w = save_dir / 'weights'  # weights dir\n    (w.parent if evolve else w).mkdir(parents=True, exist_ok=True)  # make dir\n    last, best = w / 'last.pt', w / 'best.pt'\n\n    # Hyperparameters\n    if isinstance(hyp, str):\n        with open(hyp, errors='ignore') as f:\n            hyp = yaml.safe_load(f)  # load hyps dict\n    LOGGER.info(colorstr('hyperparameters: ') + ', '.join(f'{k}={v}' for k, v in hyp.items()))\n    opt.hyp = hyp.copy()  # for saving hyps to checkpoints\n\n    # Save run settings\n    if not evolve:\n        yaml_save(save_dir / 'hyp.yaml', hyp)\n        yaml_save(save_dir / 'opt.yaml', vars(opt))\n\n    # Loggers\n    data_dict = None\n    if RANK in {-1, 0}:\n        logger = GenericLogger(opt=opt, console_logger=LOGGER)\n\n    # Config\n    plots = not evolve and not opt.noplots  # create plots\n    overlap = not opt.no_overlap\n    cuda = device.type != 'cpu'\n    init_seeds(opt.seed + 1 + RANK, deterministic=True)\n    with torch_distributed_zero_first(LOCAL_RANK):\n        data_dict = data_dict or check_dataset(data)  # check if None\n    train_path, val_path = data_dict['train'], data_dict['val']\n    nc = 1 if single_cls else int(data_dict['nc'])  # number of classes\n    names = {0: 'item'} if single_cls and len(data_dict['names']) != 1 else data_dict['names']  # class names\n    is_coco = isinstance(val_path, str) and val_path.endswith('coco/val2017.txt')  # COCO dataset\n\n    # Model\n    check_suffix(weights, '.pt')  # check weights\n    pretrained = weights.endswith('.pt')\n    if pretrained:\n        with torch_distributed_zero_first(LOCAL_RANK):\n            weights = attempt_download(weights)  # download if not found locally\n        ckpt = torch.load(weights, map_location='cpu')  # load checkpoint to CPU to avoid CUDA memory leak\n        model = SegmentationModel(cfg or ckpt['model'].yaml, ch=3, nc=nc, anchors=hyp.get('anchors')).to(device)\n        exclude = ['anchor'] if (cfg or hyp.get('anchors')) and not resume else []  # exclude keys\n        csd = ckpt['model'].float().state_dict()  # checkpoint state_dict as FP32\n        csd = intersect_dicts(csd, model.state_dict(), exclude=exclude)  # intersect\n        model.load_state_dict(csd, strict=False)  # load\n        LOGGER.info(f'Transferred {len(csd)}/{len(model.state_dict())} items from {weights}')  # report\n    else:\n        model = SegmentationModel(cfg, ch=3, nc=nc, anchors=hyp.get('anchors')).to(device)  # create\n    amp = check_amp(model)  # check AMP\n\n    # Freeze\n    freeze = [f'model.{x}.' for x in (freeze if len(freeze) > 1 else range(freeze[0]))]  # layers to freeze\n    for k, v in model.named_parameters():\n        v.requires_grad = True  # train all layers\n        # v.register_hook(lambda x: torch.nan_to_num(x))  # NaN to 0 (commented for erratic training results)\n        if any(x in k for x in freeze):\n            LOGGER.info(f'freezing {k}')\n            v.requires_grad = False\n\n    # Image size\n    gs = max(int(model.stride.max()), 32)  # grid size (max stride)\n    imgsz = check_img_size(opt.imgsz, gs, floor=gs * 2)  # verify imgsz is gs-multiple\n\n    # Batch size\n    if RANK == -1 and batch_size == -1:  # single-GPU only, estimate best batch size\n        batch_size = check_train_batch_size(model, imgsz, amp)\n        logger.update_params({\"batch_size\": batch_size})\n        # loggers.on_params_update({\"batch_size\": batch_size})\n\n    # Optimizer\n    nbs = 64  # nominal batch size\n    accumulate = max(round(nbs / batch_size), 1)  # accumulate loss before optimizing\n    hyp['weight_decay'] *= batch_size * accumulate / nbs  # scale weight_decay\n    optimizer = smart_optimizer(model, opt.optimizer, hyp['lr0'], hyp['momentum'], hyp['weight_decay'])\n\n    # Scheduler\n    if opt.cos_lr:\n        lf = one_cycle(1, hyp['lrf'], epochs)  # cosine 1->hyp['lrf']\n    else:\n        lf = lambda x: (1 - x / epochs) * (1.0 - hyp['lrf']) + hyp['lrf']  # linear\n    scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf)  # plot_lr_scheduler(optimizer, scheduler, epochs)\n\n    # EMA\n    ema = ModelEMA(model) if RANK in {-1, 0} else None\n\n    # Resume\n    best_fitness, start_epoch = 0.0, 0\n    if pretrained:\n        if resume:\n            best_fitness, start_epoch, epochs = smart_resume(ckpt, optimizer, ema, weights, epochs, resume)\n        del ckpt, csd\n\n    # DP mode\n    if cuda and RANK == -1 and torch.cuda.device_count() > 1:\n        LOGGER.warning('WARNING \u26a0\ufe0f DP not recommended, use torch.distributed.run for best DDP Multi-GPU results.\\n'\n                       'See Multi-GPU Tutorial at https://github.com/ultralytics/yolov5/issues/475 to get started.')\n        model = torch.nn.DataParallel(model)\n\n    # SyncBatchNorm\n    if opt.sync_bn and cuda and RANK != -1:\n        model = torch.nn.SyncBatchNorm.convert_sync_batchnorm(model).to(device)\n        LOGGER.info('Using SyncBatchNorm()')\n\n    # Trainloader\n    train_loader, dataset = create_dataloader(\n        train_path,\n        imgsz,\n        batch_size // WORLD_SIZE,\n        gs,\n        single_cls,\n        hyp=hyp,\n        augment=True,\n        cache=None if opt.cache == 'val' else opt.cache,\n        rect=opt.rect,\n        rank=LOCAL_RANK,\n        workers=workers,\n        image_weights=opt.image_weights,\n        quad=opt.quad,\n        prefix=colorstr('train: '),\n        shuffle=True,\n        mask_downsample_ratio=mask_ratio,\n        overlap_mask=overlap,\n    )\n    labels = np.concatenate(dataset.labels, 0)\n    mlc = int(labels[:, 0].max())  # max label class\n    assert mlc < nc, f'Label class {mlc} exceeds nc={nc} in {data}. Possible class labels are 0-{nc - 1}'\n\n    # Process 0\n    if RANK in {-1, 0}:\n        val_loader = create_dataloader(val_path,\n                                       imgsz,\n                                       batch_size // WORLD_SIZE * 2,\n                                       gs,\n                                       single_cls,\n                                       hyp=hyp,\n                                       cache=None if noval else opt.cache,\n                                       rect=True,\n                                       rank=-1,\n                                       workers=workers * 2,\n                                       pad=0.5,\n                                       mask_downsample_ratio=mask_ratio,\n                                       overlap_mask=overlap,\n                                       prefix=colorstr('val: '))[0]\n\n        if not resume:\n            if not opt.noautoanchor:\n                check_anchors(dataset, model=model, thr=hyp['anchor_t'], imgsz=imgsz)  # run AutoAnchor\n            model.half().float()  # pre-reduce anchor precision\n\n            if plots:\n                plot_labels(labels, names, save_dir)\n        # callbacks.run('on_pretrain_routine_end', labels, names)\n\n    # DDP mode\n    if cuda and RANK != -1:\n        model = smart_DDP(model)\n\n    # Model attributes\n    nl = de_parallel(model).model[-1].nl  # number of detection layers (to scale hyps)\n    hyp['box'] *= 3 / nl  # scale to layers\n    hyp['cls'] *= nc / 80 * 3 / nl  # scale to classes and layers\n    hyp['obj'] *= (imgsz / 640) ** 2 * 3 / nl  # scale to image size and layers\n    hyp['label_smoothing'] = opt.label_smoothing\n    model.nc = nc  # attach number of classes to model\n    model.hyp = hyp  # attach hyperparameters to model\n    model.class_weights = labels_to_class_weights(dataset.labels, nc).to(device) * nc  # attach class weights\n    model.names = names\n\n    # Start training\n    t0 = time.time()\n    nb = len(train_loader)  # number of batches\n    nw = max(round(hyp['warmup_epochs'] * nb), 100)  # number of warmup iterations, max(3 epochs, 100 iterations)\n    # nw = min(nw, (epochs - start_epoch) / 2 * nb)  # limit warmup to < 1/2 of training\n    last_opt_step = -1\n    maps = np.zeros(nc)  # mAP per class\n    results = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)  # P, R, mAP@.5, mAP@.5-.95, val_loss(box, obj, cls)\n    scheduler.last_epoch = start_epoch - 1  # do not move\n    scaler = torch.cuda.amp.GradScaler(enabled=amp)\n    stopper, stop = EarlyStopping(patience=opt.patience), False\n    compute_loss = ComputeLoss(model, overlap=overlap)  # init loss class\n    # callbacks.run('on_train_start')\n    LOGGER.info(f'Image sizes {imgsz} train, {imgsz} val\\n'\n                f'Using {train_loader.num_workers * WORLD_SIZE} dataloader workers\\n'\n                f\"Logging results to {colorstr('bold', save_dir)}\\n\"\n                f'Starting training for {epochs} epochs...')\n    for epoch in range(start_epoch, epochs):  # epoch ------------------------------------------------------------------\n        # callbacks.run('on_train_epoch_start')\n        model.train()\n\n        # Update image weights (optional, single-GPU only)\n        if opt.image_weights:\n            cw = model.class_weights.cpu().numpy() * (1 - maps) ** 2 / nc  # class weights\n            iw = labels_to_image_weights(dataset.labels, nc=nc, class_weights=cw)  # image weights\n            dataset.indices = random.choices(range(dataset.n), weights=iw, k=dataset.n)  # rand weighted idx\n\n        # Update mosaic border (optional)\n        # b = int(random.uniform(0.25 * imgsz, 0.75 * imgsz + gs) // gs * gs)\n        # dataset.mosaic_border = [b - imgsz, -b]  # height, width borders\n\n        mloss = torch.zeros(4, device=device)  # mean losses\n        if RANK != -1:\n            train_loader.sampler.set_epoch(epoch)\n        pbar = enumerate(train_loader)\n        LOGGER.info(('\\n' + '%11s' * 8) %\n                    ('Epoch', 'GPU_mem', 'box_loss', 'seg_loss', 'obj_loss', 'cls_loss', 'Instances', 'Size'))\n        if RANK in {-1, 0}:\n            pbar = tqdm(pbar, total=nb, bar_format=TQDM_BAR_FORMAT)  # progress bar\n        optimizer.zero_grad()\n        for i, (imgs, targets, paths, _, masks) in pbar:  # batch ------------------------------------------------------\n            # callbacks.run('on_train_batch_start')\n            ni = i + nb * epoch  # number integrated batches (since train start)\n            imgs = imgs.to(device, non_blocking=True).float() / 255  # uint8 to float32, 0-255 to 0.0-1.0\n\n            # Warmup\n            if ni <= nw:\n                xi = [0, nw]  # x interp\n                # compute_loss.gr = np.interp(ni, xi, [0.0, 1.0])  # iou loss ratio (obj_loss = 1.0 or iou)\n                accumulate = max(1, np.interp(ni, xi, [1, nbs / batch_size]).round())\n                for j, x in enumerate(optimizer.param_groups):\n                    # bias lr falls from 0.1 to lr0, all other lrs rise from 0.0 to lr0\n                    x['lr'] = np.interp(ni, xi, [hyp['warmup_bias_lr'] if j == 0 else 0.0, x['initial_lr'] * lf(epoch)])\n                    if 'momentum' in x:\n                        x['momentum'] = np.interp(ni, xi, [hyp['warmup_momentum'], hyp['momentum']])\n\n            # Multi-scale\n            if opt.multi_scale:\n                sz = random.randrange(imgsz * 0.5, imgsz * 1.5 + gs) // gs * gs  # size\n                sf = sz / max(imgs.shape[2:])  # scale factor\n                if sf != 1:\n                    ns = [math.ceil(x * sf / gs) * gs for x in imgs.shape[2:]]  # new shape (stretched to gs-multiple)\n                    imgs = nn.functional.interpolate(imgs, size=ns, mode='bilinear', align_corners=False)\n\n            # Forward\n            with torch.cuda.amp.autocast(amp):\n                pred = model(imgs)  # forward\n                loss, loss_items = compute_loss(pred, targets.to(device), masks=masks.to(device).float())\n                if RANK != -1:\n                    loss *= WORLD_SIZE  # gradient averaged between devices in DDP mode\n                if opt.quad:\n                    loss *= 4.\n\n            # Backward\n            scaler.scale(loss).backward()\n\n            # Optimize - https://pytorch.org/docs/master/notes/amp_examples.html\n            if ni - last_opt_step >= accumulate:\n                scaler.unscale_(optimizer)  # unscale gradients\n                torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=10.0)  # clip gradients\n                scaler.step(optimizer)  # optimizer.step\n                scaler.update()\n                optimizer.zero_grad()\n                if ema:\n                    ema.update(model)\n                last_opt_step = ni\n\n            # Log\n            if RANK in {-1, 0}:\n                mloss = (mloss * i + loss_items) / (i + 1)  # update mean losses\n                mem = f'{torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0:.3g}G'  # (GB)\n                pbar.set_description(('%11s' * 2 + '%11.4g' * 6) %\n                                     (f'{epoch}/{epochs - 1}', mem, *mloss, targets.shape[0], imgs.shape[-1]))\n                # callbacks.run('on_train_batch_end', model, ni, imgs, targets, paths)\n                # if callbacks.stop_training:\n                #    return\n\n                # Mosaic plots\n                if plots:\n                    if ni < 3:\n                        plot_images_and_masks(imgs, targets, masks, paths, save_dir / f\"train_batch{ni}.jpg\")\n                    if ni == 10:\n                        files = sorted(save_dir.glob('train*.jpg'))\n                        logger.log_images(files, \"Mosaics\", epoch)\n            # end batch ------------------------------------------------------------------------------------------------\n\n        # Scheduler\n        lr = [x['lr'] for x in optimizer.param_groups]  # for loggers\n        scheduler.step()\n\n        if RANK in {-1, 0}:\n            # mAP\n            # callbacks.run('on_train_epoch_end', epoch=epoch)\n            ema.update_attr(model, include=['yaml', 'nc', 'hyp', 'names', 'stride', 'class_weights'])\n            final_epoch = (epoch + 1 == epochs) or stopper.possible_stop\n            if not noval or final_epoch:  # Calculate mAP\n                results, maps, _ = validate.run(data_dict,\n                                                batch_size=batch_size // WORLD_SIZE * 2,\n                                                imgsz=imgsz,\n                                                half=amp,\n                                                model=ema.ema,\n                                                single_cls=single_cls,\n                                                dataloader=val_loader,\n                                                save_dir=save_dir,\n                                                plots=False,\n                                                callbacks=callbacks,\n                                                compute_loss=compute_loss,\n                                                mask_downsample_ratio=mask_ratio,\n                                                overlap=overlap)\n\n            # Update best mAP\n            fi = fitness(np.array(results).reshape(1, -1))  # weighted combination of [P, R, mAP@.5, mAP@.5-.95]\n            stop = stopper(epoch=epoch, fitness=fi)  # early stop check\n            if fi > best_fitness:\n                best_fitness = fi\n            log_vals = list(mloss) + list(results) + lr\n            # callbacks.run('on_fit_epoch_end', log_vals, epoch, best_fitness, fi)\n            # Log val metrics and media\n            metrics_dict = dict(zip(KEYS, log_vals))\n            logger.log_metrics(metrics_dict, epoch)\n\n            # Save model\n            if (not nosave) or (final_epoch and not evolve):  # if save\n                ckpt = {\n                    'epoch': epoch,\n                    'best_fitness': best_fitness,\n                    'model': deepcopy(de_parallel(model)).half(),\n                    'ema': deepcopy(ema.ema).half(),\n                    'updates': ema.updates,\n                    'optimizer': optimizer.state_dict(),\n                    'opt': vars(opt),\n                    'git': GIT_INFO,  # {remote, branch, commit} if a git repo\n                    'date': datetime.now().isoformat()}\n\n                # Save last, best and delete\n                torch.save(ckpt, last)\n                if best_fitness == fi:\n                    torch.save(ckpt, best)\n                if opt.save_period > 0 and epoch % opt.save_period == 0:\n                    torch.save(ckpt, w / f'epoch{epoch}.pt')\n                    logger.log_model(w / f'epoch{epoch}.pt')\n                del ckpt\n                # callbacks.run('on_model_save', last, epoch, final_epoch, best_fitness, fi)\n\n        # EarlyStopping\n        if RANK != -1:  # if DDP training\n            broadcast_list = [stop if RANK == 0 else None]\n            dist.broadcast_object_list(broadcast_list, 0)  # broadcast 'stop' to all ranks\n            if RANK != 0:\n                stop = broadcast_list[0]\n        if stop:\n            break  # must break all DDP ranks\n\n        # end epoch ----------------------------------------------------------------------------------------------------\n    # end training -----------------------------------------------------------------------------------------------------\n    if RANK in {-1, 0}:\n        LOGGER.info(f'\\n{epoch - start_epoch + 1} epochs completed in {(time.time() - t0) / 3600:.3f} hours.')\n        for f in last, best:\n            if f.exists():\n                strip_optimizer(f)  # strip optimizers\n                if f is best:\n                    LOGGER.info(f'\\nValidating {f}...')\n                    results, _, _ = validate.run(\n                        data_dict,\n                        batch_size=batch_size // WORLD_SIZE * 2,\n                        imgsz=imgsz,\n                        model=attempt_load(f, device).half(),\n                        iou_thres=0.65 if is_coco else 0.60,  # best pycocotools at iou 0.65\n                        single_cls=single_cls,\n                        dataloader=val_loader,\n                        save_dir=save_dir,\n                        save_json=is_coco,\n                        verbose=True,\n                        plots=plots,\n                        callbacks=callbacks,\n                        compute_loss=compute_loss,\n                        mask_downsample_ratio=mask_ratio,\n                        overlap=overlap)  # val best model with plots\n                    if is_coco:\n                        # callbacks.run('on_fit_epoch_end', list(mloss) + list(results) + lr, epoch, best_fitness, fi)\n                        metrics_dict = dict(zip(KEYS, list(mloss) + list(results) + lr))\n                        logger.log_metrics(metrics_dict, epoch)\n\n        # callbacks.run('on_train_end', last, best, epoch, results)\n        # on train end callback using genericLogger\n        logger.log_metrics(dict(zip(KEYS[4:16], results)), epochs)\n        if not opt.evolve:\n            logger.log_model(best, epoch)\n        if plots:\n            plot_results_with_masks(file=save_dir / 'results.csv')  # save results.png\n            files = ['results.png', 'confusion_matrix.png', *(f'{x}_curve.png' for x in ('F1', 'PR', 'P', 'R'))]\n            files = [(save_dir / f) for f in files if (save_dir / f).exists()]  # filter\n            LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}\")\n            logger.log_images(files, \"Results\", epoch + 1)\n            logger.log_images(sorted(save_dir.glob('val*.jpg')), \"Validation\", epoch + 1)\n    torch.cuda.empty_cache()\n    return results", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_opt(known=False):\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--weights', type=str, default=ROOT / 'yolov5s-seg.pt', help='initial weights path')\n    parser.add_argument('--cfg', type=str, default='', help='model.yaml path')\n    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128-seg.yaml', help='dataset.yaml path')\n    parser.add_argument('--hyp', type=str, default=ROOT / 'data/hyps/hyp.scratch-low.yaml', help='hyperparameters path')\n    parser.add_argument('--epochs', type=int, default=100, help='total training epochs')\n    parser.add_argument('--batch-size', type=int, default=16, help='total batch size for all GPUs, -1 for autobatch')\n    parser.add_argument('--imgsz', '--img', '--img-size', type=int, default=640, help='train, val image size (pixels)')\n    parser.add_argument('--rect', action='store_true', help='rectangular training')\n    parser.add_argument('--resume', nargs='?', const=True, default=False, help='resume most recent training')\n    parser.add_argument('--nosave', action='store_true', help='only save final checkpoint')\n    parser.add_argument('--noval', action='store_true', help='only validate final epoch')\n    parser.add_argument('--noautoanchor', action='store_true', help='disable AutoAnchor')\n    parser.add_argument('--noplots', action='store_true', help='save no plot files')\n    parser.add_argument('--evolve', type=int, nargs='?', const=300, help='evolve hyperparameters for x generations')\n    parser.add_argument('--bucket', type=str, default='', help='gsutil bucket')\n    parser.add_argument('--cache', type=str, nargs='?', const='ram', help='image --cache ram/disk')\n    parser.add_argument('--image-weights', action='store_true', help='use weighted image selection for training')\n    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--multi-scale', action='store_true', help='vary img-size +/- 50%%')\n    parser.add_argument('--single-cls', action='store_true', help='train multi-class data as single-class')\n    parser.add_argument('--optimizer', type=str, choices=['SGD', 'Adam', 'AdamW'], default='SGD', help='optimizer')\n    parser.add_argument('--sync-bn', action='store_true', help='use SyncBatchNorm, only available in DDP mode')\n    parser.add_argument('--workers', type=int, default=8, help='max dataloader workers (per RANK in DDP mode)')\n    parser.add_argument('--project', default=ROOT / 'runs/train-seg', help='save to project/name')\n    parser.add_argument('--name', default='exp', help='save to project/name')\n    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n    parser.add_argument('--quad', action='store_true', help='quad dataloader')\n    parser.add_argument('--cos-lr', action='store_true', help='cosine LR scheduler')\n    parser.add_argument('--label-smoothing', type=float, default=0.0, help='Label smoothing epsilon')\n    parser.add_argument('--patience', type=int, default=100, help='EarlyStopping patience (epochs without improvement)')\n    parser.add_argument('--freeze', nargs='+', type=int, default=[0], help='Freeze layers: backbone=10, first3=0 1 2')\n    parser.add_argument('--save-period', type=int, default=-1, help='Save checkpoint every x epochs (disabled if < 1)')\n    parser.add_argument('--seed', type=int, default=0, help='Global training seed')\n    parser.add_argument('--local_rank', type=int, default=-1, help='Automatic DDP Multi-GPU argument, do not modify')\n\n    # Instance Segmentation Args\n    parser.add_argument('--mask-ratio', type=int, default=4, help='Downsample the truth masks to saving memory')\n    parser.add_argument('--no-overlap', action='store_true', help='Overlap masks train faster at slightly less mAP')\n\n    return parser.parse_known_args()[0] if known else parser.parse_args()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(opt, callbacks=Callbacks()):\n    # Checks\n    if RANK in {-1, 0}:\n        print_args(vars(opt))\n        check_git_status()\n        check_requirements()\n\n    # Resume\n    if opt.resume and not opt.evolve:  # resume from specified or most recent last.pt\n        last = Path(check_file(opt.resume) if isinstance(opt.resume, str) else get_latest_run())\n        opt_yaml = last.parent.parent / 'opt.yaml'  # train options yaml\n        opt_data = opt.data  # original dataset\n        if opt_yaml.is_file():\n            with open(opt_yaml, errors='ignore') as f:\n                d = yaml.safe_load(f)\n        else:\n            d = torch.load(last, map_location='cpu')['opt']\n        opt = argparse.Namespace(**d)  # replace\n        opt.cfg, opt.weights, opt.resume = '', str(last), True  # reinstate\n        if is_url(opt_data):\n            opt.data = check_file(opt_data)  # avoid HUB resume auth timeout\n    else:\n        opt.data, opt.cfg, opt.hyp, opt.weights, opt.project = \\\n            check_file(opt.data), check_yaml(opt.cfg), check_yaml(opt.hyp), str(opt.weights), str(opt.project)  # checks\n        assert len(opt.cfg) or len(opt.weights), 'either --cfg or --weights must be specified'\n        if opt.evolve:\n            if opt.project == str(ROOT / 'runs/train'):  # if default project name, rename to runs/evolve\n                opt.project = str(ROOT / 'runs/evolve')\n            opt.exist_ok, opt.resume = opt.resume, False  # pass resume to exist_ok and disable resume\n        if opt.name == 'cfg':\n            opt.name = Path(opt.cfg).stem  # use model.yaml as name\n        opt.save_dir = str(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok))\n\n    # DDP mode\n    device = select_device(opt.device, batch_size=opt.batch_size)\n    if LOCAL_RANK != -1:\n        msg = 'is not compatible with YOLOv5 Multi-GPU DDP training'\n        assert not opt.image_weights, f'--image-weights {msg}'\n        assert not opt.evolve, f'--evolve {msg}'\n        assert opt.batch_size != -1, f'AutoBatch with --batch-size -1 {msg}, please pass a valid --batch-size'\n        assert opt.batch_size % WORLD_SIZE == 0, f'--batch-size {opt.batch_size} must be multiple of WORLD_SIZE'\n        assert torch.cuda.device_count() > LOCAL_RANK, 'insufficient CUDA devices for DDP command'\n        torch.cuda.set_device(LOCAL_RANK)\n        device = torch.device('cuda', LOCAL_RANK)\n        dist.init_process_group(backend=\"nccl\" if dist.is_nccl_available() else \"gloo\")\n\n    # Train\n    if not opt.evolve:\n        train(opt.hyp, opt, device, callbacks)\n\n    # Evolve hyperparameters (optional)\n    else:\n        # Hyperparameter evolution metadata (mutation scale 0-1, lower_limit, upper_limit)\n        meta = {\n            'lr0': (1, 1e-5, 1e-1),  # initial learning rate (SGD=1E-2, Adam=1E-3)\n            'lrf': (1, 0.01, 1.0),  # final OneCycleLR learning rate (lr0 * lrf)\n            'momentum': (0.3, 0.6, 0.98),  # SGD momentum/Adam beta1\n            'weight_decay': (1, 0.0, 0.001),  # optimizer weight decay\n            'warmup_epochs': (1, 0.0, 5.0),  # warmup epochs (fractions ok)\n            'warmup_momentum': (1, 0.0, 0.95),  # warmup initial momentum\n            'warmup_bias_lr': (1, 0.0, 0.2),  # warmup initial bias lr\n            'box': (1, 0.02, 0.2),  # box loss gain\n            'cls': (1, 0.2, 4.0),  # cls loss gain\n            'cls_pw': (1, 0.5, 2.0),  # cls BCELoss positive_weight\n            'obj': (1, 0.2, 4.0),  # obj loss gain (scale with pixels)\n            'obj_pw': (1, 0.5, 2.0),  # obj BCELoss positive_weight\n            'iou_t': (0, 0.1, 0.7),  # IoU training threshold\n            'anchor_t': (1, 2.0, 8.0),  # anchor-multiple threshold\n            'anchors': (2, 2.0, 10.0),  # anchors per output grid (0 to ignore)\n            'fl_gamma': (0, 0.0, 2.0),  # focal loss gamma (efficientDet default gamma=1.5)\n            'hsv_h': (1, 0.0, 0.1),  # image HSV-Hue augmentation (fraction)\n            'hsv_s': (1, 0.0, 0.9),  # image HSV-Saturation augmentation (fraction)\n            'hsv_v': (1, 0.0, 0.9),  # image HSV-Value augmentation (fraction)\n            'degrees': (1, 0.0, 45.0),  # image rotation (+/- deg)\n            'translate': (1, 0.0, 0.9),  # image translation (+/- fraction)\n            'scale': (1, 0.0, 0.9),  # image scale (+/- gain)\n            'shear': (1, 0.0, 10.0),  # image shear (+/- deg)\n            'perspective': (0, 0.0, 0.001),  # image perspective (+/- fraction), range 0-0.001\n            'flipud': (1, 0.0, 1.0),  # image flip up-down (probability)\n            'fliplr': (0, 0.0, 1.0),  # image flip left-right (probability)\n            'mosaic': (1, 0.0, 1.0),  # image mixup (probability)\n            'mixup': (1, 0.0, 1.0),  # image mixup (probability)\n            'copy_paste': (1, 0.0, 1.0)}  # segment copy-paste (probability)\n\n        with open(opt.hyp, errors='ignore') as f:\n            hyp = yaml.safe_load(f)  # load hyps dict\n            if 'anchors' not in hyp:  # anchors commented in hyp.yaml\n                hyp['anchors'] = 3\n        if opt.noautoanchor:\n            del hyp['anchors'], meta['anchors']\n        opt.noval, opt.nosave, save_dir = True, True, Path(opt.save_dir)  # only val/save final epoch\n        # ei = [isinstance(x, (int, float)) for x in hyp.values()]  # evolvable indices\n        evolve_yaml, evolve_csv = save_dir / 'hyp_evolve.yaml', save_dir / 'evolve.csv'\n        if opt.bucket:\n            os.system(f'gsutil cp gs://{opt.bucket}/evolve.csv {evolve_csv}')  # download evolve.csv if exists\n\n        for _ in range(opt.evolve):  # generations to evolve\n            if evolve_csv.exists():  # if evolve.csv exists: select best hyps and mutate\n                # Select parent(s)\n                parent = 'single'  # parent selection method: 'single' or 'weighted'\n                x = np.loadtxt(evolve_csv, ndmin=2, delimiter=',', skiprows=1)\n                n = min(5, len(x))  # number of previous results to consider\n                x = x[np.argsort(-fitness(x))][:n]  # top n mutations\n                w = fitness(x) - fitness(x).min() + 1E-6  # weights (sum > 0)\n                if parent == 'single' or len(x) == 1:\n                    # x = x[random.randint(0, n - 1)]  # random selection\n                    x = x[random.choices(range(n), weights=w)[0]]  # weighted selection\n                elif parent == 'weighted':\n                    x = (x * w.reshape(n, 1)).sum(0) / w.sum()  # weighted combination\n\n                # Mutate\n                mp, s = 0.8, 0.2  # mutation probability, sigma\n                npr = np.random\n                npr.seed(int(time.time()))\n                g = np.array([meta[k][0] for k in hyp.keys()])  # gains 0-1\n                ng = len(meta)\n                v = np.ones(ng)\n                while all(v == 1):  # mutate until a change occurs (prevent duplicates)\n                    v = (g * (npr.random(ng) < mp) * npr.randn(ng) * npr.random() * s + 1).clip(0.3, 3.0)\n                for i, k in enumerate(hyp.keys()):  # plt.hist(v.ravel(), 300)\n                    hyp[k] = float(x[i + 7] * v[i])  # mutate\n\n            # Constrain to limits\n            for k, v in meta.items():\n                hyp[k] = max(hyp[k], v[1])  # lower limit\n                hyp[k] = min(hyp[k], v[2])  # upper limit\n                hyp[k] = round(hyp[k], 5)  # significant digits\n\n            # Train mutation\n            results = train(hyp.copy(), opt, device, callbacks)\n            callbacks = Callbacks()\n            # Write mutation results\n            print_mutation(KEYS, results, hyp.copy(), save_dir, opt.bucket)\n\n        # Plot results\n        plot_evolve(evolve_csv)\n        LOGGER.info(f'Hyperparameter evolution finished {opt.evolve} generations\\n'\n                    f\"Results saved to {colorstr('bold', save_dir)}\\n\"\n                    f'Usage example: $ python train.py --hyp {evolve_yaml}')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run(**kwargs):\n    # Usage: import train; train.run(data='coco128.yaml', imgsz=320, weights='yolov5m.pt')\n    opt = parse_opt(True)\n    for k, v in kwargs.items():\n        setattr(opt, k, v)\n    main(opt)\n    return opt", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def fitness(x):\n    # Model fitness as a weighted combination of metrics\n    w = [0.0, 0.0, 0.1, 0.9]  # weights for [P, R, mAP@0.5, mAP@0.5:0.95]\n    return (x[:, :4] * w).sum(1)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def smooth(y, f=0.05):\n    # Box filter of fraction f\n    nf = round(len(y) * f * 2) // 2 + 1  # number of filter elements (must be odd)\n    p = np.ones(nf // 2)  # ones padding\n    yp = np.concatenate((p * y[0], y, p * y[-1]), 0)  # y padded\n    return np.convolve(yp, np.ones(nf) / nf, mode='valid')  # y-smoothed", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def ap_per_class(tp, conf, pred_cls, target_cls, plot=False, save_dir='.', names=(), eps=1e-16, prefix=\"\"):\n    \"\"\" Compute the average precision, given the recall and precision curves.\n    Source: https://github.com/rafaelpadilla/Object-Detection-Metrics.\n    # Arguments\n        tp:  True positives (nparray, nx1 or nx10).\n        conf:  Objectness value from 0-1 (nparray).\n        pred_cls:  Predicted object classes (nparray).\n        target_cls:  True object classes (nparray).\n        plot:  Plot precision-recall curve at mAP@0.5\n        save_dir:  Plot save directory\n    # Returns\n        The average precision as computed in py-faster-rcnn.\n    \"\"\"\n\n    # Sort by objectness\n    i = np.argsort(-conf)\n    tp, conf, pred_cls = tp[i], conf[i], pred_cls[i]\n\n    # Find unique classes\n    unique_classes, nt = np.unique(target_cls, return_counts=True)\n    nc = unique_classes.shape[0]  # number of classes, number of detections\n\n    # Create Precision-Recall curve and compute AP for each class\n    px, py = np.linspace(0, 1, 1000), []  # for plotting\n    ap, p, r = np.zeros((nc, tp.shape[1])), np.zeros((nc, 1000)), np.zeros((nc, 1000))\n    for ci, c in enumerate(unique_classes):\n        i = pred_cls == c\n        n_l = nt[ci]  # number of labels\n        n_p = i.sum()  # number of predictions\n        if n_p == 0 or n_l == 0:\n            continue\n\n        # Accumulate FPs and TPs\n        fpc = (1 - tp[i]).cumsum(0)\n        tpc = tp[i].cumsum(0)\n\n        # Recall\n        recall = tpc / (n_l + eps)  # recall curve\n        r[ci] = np.interp(-px, -conf[i], recall[:, 0], left=0)  # negative x, xp because xp decreases\n\n        # Precision\n        precision = tpc / (tpc + fpc)  # precision curve\n        p[ci] = np.interp(-px, -conf[i], precision[:, 0], left=1)  # p at pr_score\n\n        # AP from recall-precision curve\n        for j in range(tp.shape[1]):\n            ap[ci, j], mpre, mrec = compute_ap(recall[:, j], precision[:, j])\n            if plot and j == 0:\n                py.append(np.interp(px, mrec, mpre))  # precision at mAP@0.5\n\n    # Compute F1 (harmonic mean of precision and recall)\n    f1 = 2 * p * r / (p + r + eps)\n    names = [v for k, v in names.items() if k in unique_classes]  # list: only classes that have data\n    names = dict(enumerate(names))  # to dict\n    if plot:\n        plot_pr_curve(px, py, ap, Path(save_dir) / f'{prefix}PR_curve.png', names)\n        plot_mc_curve(px, f1, Path(save_dir) / f'{prefix}F1_curve.png', names, ylabel='F1')\n        plot_mc_curve(px, p, Path(save_dir) / f'{prefix}P_curve.png', names, ylabel='Precision')\n        plot_mc_curve(px, r, Path(save_dir) / f'{prefix}R_curve.png', names, ylabel='Recall')\n\n    i = smooth(f1.mean(0), 0.1).argmax()  # max F1 index\n    p, r, f1 = p[:, i], r[:, i], f1[:, i]\n    tp = (r * nt).round()  # true positives\n    fp = (tp / (p + eps) - tp).round()  # false positives\n    return tp, fp, p, r, f1, ap, unique_classes.astype(int)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def compute_ap(recall, precision):\n    \"\"\" Compute the average precision, given the recall and precision curves\n    # Arguments\n        recall:    The recall curve (list)\n        precision: The precision curve (list)\n    # Returns\n        Average precision, precision curve, recall curve\n    \"\"\"\n\n    # Append sentinel values to beginning and end\n    mrec = np.concatenate(([0.0], recall, [1.0]))\n    mpre = np.concatenate(([1.0], precision, [0.0]))\n\n    # Compute the precision envelope\n    mpre = np.flip(np.maximum.accumulate(np.flip(mpre)))\n\n    # Integrate area under curve\n    method = 'interp'  # methods: 'continuous', 'interp'\n    if method == 'interp':\n        x = np.linspace(0, 1, 101)  # 101-point interp (COCO)\n        ap = np.trapz(np.interp(x, mrec, mpre), x)  # integrate\n    else:  # 'continuous'\n        i = np.where(mrec[1:] != mrec[:-1])[0]  # points where x axis (recall) changes\n        ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1])  # area under curve\n\n    return ap, mpre, mrec", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def bbox_iou(box1, box2, xywh=True, GIoU=False, DIoU=False, CIoU=False, eps=1e-7):\n    # Returns Intersection over Union (IoU) of box1(1,4) to box2(n,4)\n\n    # Get the coordinates of bounding boxes\n    if xywh:  # transform from xywh to xyxy\n        (x1, y1, w1, h1), (x2, y2, w2, h2) = box1.chunk(4, -1), box2.chunk(4, -1)\n        w1_, h1_, w2_, h2_ = w1 / 2, h1 / 2, w2 / 2, h2 / 2\n        b1_x1, b1_x2, b1_y1, b1_y2 = x1 - w1_, x1 + w1_, y1 - h1_, y1 + h1_\n        b2_x1, b2_x2, b2_y1, b2_y2 = x2 - w2_, x2 + w2_, y2 - h2_, y2 + h2_\n    else:  # x1, y1, x2, y2 = box1\n        b1_x1, b1_y1, b1_x2, b1_y2 = box1.chunk(4, -1)\n        b2_x1, b2_y1, b2_x2, b2_y2 = box2.chunk(4, -1)\n        w1, h1 = b1_x2 - b1_x1, (b1_y2 - b1_y1).clamp(eps)\n        w2, h2 = b2_x2 - b2_x1, (b2_y2 - b2_y1).clamp(eps)\n\n    # Intersection area\n    inter = (b1_x2.minimum(b2_x2) - b1_x1.maximum(b2_x1)).clamp(0) * \\\n            (b1_y2.minimum(b2_y2) - b1_y1.maximum(b2_y1)).clamp(0)\n\n    # Union Area\n    union = w1 * h1 + w2 * h2 - inter + eps\n\n    # IoU\n    iou = inter / union\n    if CIoU or DIoU or GIoU:\n        cw = b1_x2.maximum(b2_x2) - b1_x1.minimum(b2_x1)  # convex (smallest enclosing box) width\n        ch = b1_y2.maximum(b2_y2) - b1_y1.minimum(b2_y1)  # convex height\n        if CIoU or DIoU:  # Distance or Complete IoU https://arxiv.org/abs/1911.08287v1\n            c2 = cw ** 2 + ch ** 2 + eps  # convex diagonal squared\n            rho2 = ((b2_x1 + b2_x2 - b1_x1 - b1_x2) ** 2 + (b2_y1 + b2_y2 - b1_y1 - b1_y2) ** 2) / 4  # center dist ** 2\n            if CIoU:  # https://github.com/Zzh-tju/DIoU-SSD-pytorch/blob/master/utils/box/box_utils.py#L47\n                v = (4 / math.pi ** 2) * (torch.atan(w2 / h2) - torch.atan(w1 / h1)).pow(2)\n                with torch.no_grad():\n                    alpha = v / (v - iou + (1 + eps))\n                return iou - (rho2 / c2 + v * alpha)  # CIoU\n            return iou - rho2 / c2  # DIoU\n        c_area = cw * ch + eps  # convex area\n        return iou - (c_area - union) / c_area  # GIoU https://arxiv.org/pdf/1902.09630.pdf\n    return iou  # IoU", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def box_iou(box1, box2, eps=1e-7):\n    # https://github.com/pytorch/vision/blob/master/torchvision/ops/boxes.py\n    \"\"\"\n    Return intersection-over-union (Jaccard index) of boxes.\n    Both sets of boxes are expected to be in (x1, y1, x2, y2) format.\n    Arguments:\n        box1 (Tensor[N, 4])\n        box2 (Tensor[M, 4])\n    Returns:\n        iou (Tensor[N, M]): the NxM matrix containing the pairwise\n            IoU values for every element in boxes1 and boxes2\n    \"\"\"\n\n    # inter(N,M) = (rb(N,M,2) - lt(N,M,2)).clamp(0).prod(2)\n    (a1, a2), (b1, b2) = box1.unsqueeze(1).chunk(2, 2), box2.unsqueeze(0).chunk(2, 2)\n    inter = (torch.min(a2, b2) - torch.max(a1, b1)).clamp(0).prod(2)\n\n    # IoU = inter / (area1 + area2 - inter)\n    return inter / ((a2 - a1).prod(2) + (b2 - b1).prod(2) - inter + eps)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def bbox_ioa(box1, box2, eps=1e-7):\n    \"\"\" Returns the intersection over box2 area given box1, box2. Boxes are x1y1x2y2\n    box1:       np.array of shape(4)\n    box2:       np.array of shape(nx4)\n    returns:    np.array of shape(n)\n    \"\"\"\n\n    # Get the coordinates of bounding boxes\n    b1_x1, b1_y1, b1_x2, b1_y2 = box1\n    b2_x1, b2_y1, b2_x2, b2_y2 = box2.T\n\n    # Intersection area\n    inter_area = (np.minimum(b1_x2, b2_x2) - np.maximum(b1_x1, b2_x1)).clip(0) * \\\n                 (np.minimum(b1_y2, b2_y2) - np.maximum(b1_y1, b2_y1)).clip(0)\n\n    # box2 area\n    box2_area = (b2_x2 - b2_x1) * (b2_y2 - b2_y1) + eps\n\n    # Intersection over box2 area\n    return inter_area / box2_area", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def wh_iou(wh1, wh2, eps=1e-7):\n    # Returns the nxm IoU matrix. wh1 is nx2, wh2 is mx2\n    wh1 = wh1[:, None]  # [N,1,2]\n    wh2 = wh2[None]  # [1,M,2]\n    inter = torch.min(wh1, wh2).prod(2)  # [N,M]\n    return inter / (wh1.prod(2) + wh2.prod(2) - inter + eps)  # iou = inter / (area1 + area2 - inter)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def plot_pr_curve(px, py, ap, save_dir=Path('pr_curve.png'), names=()):\n    # Precision-recall curve\n    fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)\n    py = np.stack(py, axis=1)\n\n    if 0 < len(names) < 21:  # display per-class legend if < 21 classes\n        for i, y in enumerate(py.T):\n            ax.plot(px, y, linewidth=1, label=f'{names[i]} {ap[i, 0]:.3f}')  # plot(recall, precision)\n    else:\n        ax.plot(px, py, linewidth=1, color='grey')  # plot(recall, precision)\n\n    ax.plot(px, py.mean(1), linewidth=3, color='blue', label='all classes %.3f mAP@0.5' % ap[:, 0].mean())\n    ax.set_xlabel('Recall')\n    ax.set_ylabel('Precision')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.legend(bbox_to_anchor=(1.04, 1), loc=\"upper left\")\n    ax.set_title('Precision-Recall Curve')\n    fig.savefig(save_dir, dpi=250)\n    plt.close(fig)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def plot_mc_curve(px, py, save_dir=Path('mc_curve.png'), names=(), xlabel='Confidence', ylabel='Metric'):\n    # Metric-confidence curve\n    fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)\n\n    if 0 < len(names) < 21:  # display per-class legend if < 21 classes\n        for i, y in enumerate(py):\n            ax.plot(px, y, linewidth=1, label=f'{names[i]}')  # plot(confidence, metric)\n    else:\n        ax.plot(px, py.T, linewidth=1, color='grey')  # plot(confidence, metric)\n\n    y = smooth(py.mean(0), 0.05)\n    ax.plot(px, y, linewidth=3, color='blue', label=f'all classes {y.max():.2f} at {px[y.argmax()]:.3f}')\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.legend(bbox_to_anchor=(1.04, 1), loc=\"upper left\")\n    ax.set_title(f'{ylabel}-Confidence Curve')\n    fig.savefig(save_dir, dpi=250)\n    plt.close(fig)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, nc, conf=0.25, iou_thres=0.45):\n        self.matrix = np.zeros((nc + 1, nc + 1))\n        self.nc = nc  # number of classes\n        self.conf = conf\n        self.iou_thres = iou_thres", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def process_batch(self, detections, labels):\n        \"\"\"\n        Return intersection-over-union (Jaccard index) of boxes.\n        Both sets of boxes are expected to be in (x1, y1, x2, y2) format.\n        Arguments:\n            detections (Array[N, 6]), x1, y1, x2, y2, conf, class\n            labels (Array[M, 5]), class, x1, y1, x2, y2\n        Returns:\n            None, updates confusion matrix accordingly\n        \"\"\"\n        if detections is None:\n            gt_classes = labels.int()\n            for gc in gt_classes:\n                self.matrix[self.nc, gc] += 1  # background FN\n            return\n\n        detections = detections[detections[:, 4] > self.conf]\n        gt_classes = labels[:, 0].int()\n        detection_classes = detections[:, 5].int()\n        iou = box_iou(labels[:, 1:], detections[:, :4])\n\n        x = torch.where(iou > self.iou_thres)\n        if x[0].shape[0]:\n            matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()\n            if x[0].shape[0] > 1:\n                matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 1], return_index=True)[1]]\n                matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 0], return_index=True)[1]]\n        else:\n            matches = np.zeros((0, 3))\n\n        n = matches.shape[0] > 0\n        m0, m1, _ = matches.transpose().astype(int)\n        for i, gc in enumerate(gt_classes):\n            j = m0 == i\n            if n and sum(j) == 1:\n                self.matrix[detection_classes[m1[j]], gc] += 1  # correct\n            else:\n                self.matrix[self.nc, gc] += 1  # true background\n\n        if n:\n            for i, dc in enumerate(detection_classes):\n                if not any(m1 == i):\n                    self.matrix[dc, self.nc] += 1  # predicted background", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def matrix(self):\n        return self.matrix", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def tp_fp(self):\n        tp = self.matrix.diagonal()  # true positives\n        fp = self.matrix.sum(1) - tp  # false positives\n        # fn = self.matrix.sum(0) - tp  # false negatives (missed detections)\n        return tp[:-1], fp[:-1]  # remove background class", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def plot(self, normalize=True, save_dir='', names=()):\n        import seaborn as sn\n\n        array = self.matrix / ((self.matrix.sum(0).reshape(1, -1) + 1E-9) if normalize else 1)  # normalize columns\n        array[array < 0.005] = np.nan  # don't annotate (would appear as 0.00)\n\n        fig, ax = plt.subplots(1, 1, figsize=(12, 9), tight_layout=True)\n        nc, nn = self.nc, len(names)  # number of classes, names\n        sn.set(font_scale=1.0 if nc < 50 else 0.8)  # for label size\n        labels = (0 < nn < 99) and (nn == nc)  # apply names to ticklabels\n        ticklabels = (names + ['background']) if labels else \"auto\"\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')  # suppress empty matrix RuntimeWarning: All-NaN slice encountered\n            sn.heatmap(array,\n                       ax=ax,\n                       annot=nc < 30,\n                       annot_kws={\n                           \"size\": 8},\n                       cmap='Blues',\n                       fmt='.2f',\n                       square=True,\n                       vmin=0.0,\n                       xticklabels=ticklabels,\n                       yticklabels=ticklabels).set_facecolor((1, 1, 1))\n        ax.set_ylabel('True')\n        ax.set_ylabel('Predicted')\n        ax.set_title('Confusion Matrix')\n        fig.savefig(Path(save_dir) / 'confusion_matrix.png', dpi=250)\n        plt.close(fig)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def print(self):\n        for i in range(self.nc + 1):\n            print(' '.join(map(str, self.matrix[i])))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def log_tensorboard_graph(tb, model, imgsz=(640, 640)):\n    # Log model graph to TensorBoard\n    try:\n        p = next(model.parameters())  # for device, type\n        imgsz = (imgsz, imgsz) if isinstance(imgsz, int) else imgsz  # expand\n        im = torch.zeros((1, 3, *imgsz)).to(p.device).type_as(p)  # input image (WARNING: must be zeros, not empty)\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')  # suppress jit trace warning\n            tb.add_graph(torch.jit.trace(de_parallel(model), im, strict=False), [])\n    except Exception as e:\n        LOGGER.warning(f'WARNING \u26a0\ufe0f TensorBoard graph visualization failure {e}')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def web_project_name(project):\n    # Convert local project name to web project name\n    if not project.startswith('runs/train'):\n        return project\n    suffix = '-Classify' if project.endswith('-cls') else '-Segment' if project.endswith('-seg') else ''\n    return f'YOLOv5{suffix}'", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, save_dir=None, weights=None, opt=None, hyp=None, logger=None, include=LOGGERS):\n        self.save_dir = save_dir\n        self.weights = weights\n        self.opt = opt\n        self.hyp = hyp\n        self.plots = not opt.noplots  # plot results\n        self.logger = logger  # for printing results to console\n        self.include = include\n        self.keys = [\n            'train/box_loss',\n            'train/obj_loss',\n            'train/cls_loss',  # train loss\n            'metrics/precision',\n            'metrics/recall',\n            'metrics/mAP_0.5',\n            'metrics/mAP_0.5:0.95',  # metrics\n            'val/box_loss',\n            'val/obj_loss',\n            'val/cls_loss',  # val loss\n            'x/lr0',\n            'x/lr1',\n            'x/lr2']  # params\n        self.best_keys = ['best/epoch', 'best/precision', 'best/recall', 'best/mAP_0.5', 'best/mAP_0.5:0.95']\n        for k in LOGGERS:\n            setattr(self, k, None)  # init empty logger dictionary\n        self.csv = True  # always log to csv\n\n        # Messages\n        # if not wandb:\n        #     prefix = colorstr('Weights & Biases: ')\n        #     s = f\"{prefix}run 'pip install wandb' to automatically track and visualize YOLOv5 \ud83d\ude80 runs in Weights & Biases\"\n        #     self.logger.info(s)\n        if not clearml:\n            prefix = colorstr('ClearML: ')\n            s = f\"{prefix}run 'pip install clearml' to automatically track, visualize and remotely train YOLOv5 \ud83d\ude80 in ClearML\"\n            self.logger.info(s)\n        if not comet_ml:\n            prefix = colorstr('Comet: ')\n            s = f\"{prefix}run 'pip install comet_ml' to automatically track and visualize YOLOv5 \ud83d\ude80 runs in Comet\"\n            self.logger.info(s)\n        # TensorBoard\n        s = self.save_dir\n        if 'tb' in self.include and not self.opt.evolve:\n            prefix = colorstr('TensorBoard: ')\n            self.logger.info(f\"{prefix}Start with 'tensorboard --logdir {s.parent}', view at http://localhost:6006/\")\n            self.tb = SummaryWriter(str(s))\n\n        # W&B\n        if wandb and 'wandb' in self.include:\n            wandb_artifact_resume = isinstance(self.opt.resume, str) and self.opt.resume.startswith('wandb-artifact://')\n            run_id = torch.load(self.weights).get('wandb_id') if self.opt.resume and not wandb_artifact_resume else None\n            self.opt.hyp = self.hyp  # add hyperparameters\n            self.wandb = WandbLogger(self.opt, run_id)\n            # temp warn. because nested artifacts not supported after 0.12.10\n            # if pkg.parse_version(wandb.__version__) >= pkg.parse_version('0.12.11'):\n            #    s = \"YOLOv5 temporarily requires wandb version 0.12.10 or below. Some features may not work as expected.\"\n            #    self.logger.warning(s)\n        else:\n            self.wandb = None\n\n        # ClearML\n        if clearml and 'clearml' in self.include:\n            self.clearml = ClearmlLogger(self.opt, self.hyp)\n        else:\n            self.clearml = None\n\n        # Comet\n        if comet_ml and 'comet' in self.include:\n            if isinstance(self.opt.resume, str) and self.opt.resume.startswith(\"comet://\"):\n                run_id = self.opt.resume.split(\"/\")[-1]\n                self.comet_logger = CometLogger(self.opt, self.hyp, run_id=run_id)\n\n            else:\n                self.comet_logger = CometLogger(self.opt, self.hyp)\n\n        else:\n            self.comet_logger = None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def remote_dataset(self):\n        # Get data_dict if custom dataset artifact link is provided\n        data_dict = None\n        if self.clearml:\n            data_dict = self.clearml.data_dict\n        if self.wandb:\n            data_dict = self.wandb.data_dict\n        if self.comet_logger:\n            data_dict = self.comet_logger.data_dict\n\n        return data_dict", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_train_start(self):\n        if self.comet_logger:\n            self.comet_logger.on_train_start()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_pretrain_routine_start(self):\n        if self.comet_logger:\n            self.comet_logger.on_pretrain_routine_start()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_pretrain_routine_end(self, labels, names):\n        # Callback runs on pre-train routine end\n        if self.plots:\n            plot_labels(labels, names, self.save_dir)\n            paths = self.save_dir.glob('*labels*.jpg')  # training labels\n            if self.wandb:\n                self.wandb.log({\"Labels\": [wandb.Image(str(x), caption=x.name) for x in paths]})\n            # if self.clearml:\n            #    pass  # ClearML saves these images automatically using hooks\n            if self.comet_logger:\n                self.comet_logger.on_pretrain_routine_end(paths)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_train_batch_end(self, model, ni, imgs, targets, paths, vals):\n        log_dict = dict(zip(self.keys[0:3], vals))\n        # Callback runs on train batch end\n        # ni: number integrated batches (since train start)\n        if self.plots:\n            if ni < 3:\n                f = self.save_dir / f'train_batch{ni}.jpg'  # filename\n                plot_images(imgs, targets, paths, f)\n                if ni == 0 and self.tb and not self.opt.sync_bn:\n                    log_tensorboard_graph(self.tb, model, imgsz=(self.opt.imgsz, self.opt.imgsz))\n            if ni == 10 and (self.wandb or self.clearml):\n                files = sorted(self.save_dir.glob('train*.jpg'))\n                if self.wandb:\n                    self.wandb.log({'Mosaics': [wandb.Image(str(f), caption=f.name) for f in files if f.exists()]})\n                if self.clearml:\n                    self.clearml.log_debug_samples(files, title='Mosaics')\n\n        if self.comet_logger:\n            self.comet_logger.on_train_batch_end(log_dict, step=ni)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_train_epoch_end(self, epoch):\n        # Callback runs on train epoch end\n        if self.wandb:\n            self.wandb.current_epoch = epoch + 1\n\n        if self.comet_logger:\n            self.comet_logger.on_train_epoch_end(epoch)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_val_start(self):\n        if self.comet_logger:\n            self.comet_logger.on_val_start()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_val_image_end(self, pred, predn, path, names, im):\n        # Callback runs on val image end\n        if self.wandb:\n            self.wandb.val_one_image(pred, predn, path, names, im)\n        if self.clearml:\n            self.clearml.log_image_with_boxes(path, pred, names, im)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_val_batch_end(self, batch_i, im, targets, paths, shapes, out):\n        if self.comet_logger:\n            self.comet_logger.on_val_batch_end(batch_i, im, targets, paths, shapes, out)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_val_end(self, nt, tp, fp, p, r, f1, ap, ap50, ap_class, confusion_matrix):\n        # Callback runs on val end\n        if self.wandb or self.clearml:\n            files = sorted(self.save_dir.glob('val*.jpg'))\n            if self.wandb:\n                self.wandb.log({\"Validation\": [wandb.Image(str(f), caption=f.name) for f in files]})\n            if self.clearml:\n                self.clearml.log_debug_samples(files, title='Validation')\n\n        if self.comet_logger:\n            self.comet_logger.on_val_end(nt, tp, fp, p, r, f1, ap, ap50, ap_class, confusion_matrix)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_fit_epoch_end(self, vals, epoch, best_fitness, fi):\n        # Callback runs at the end of each fit (train+val) epoch\n        x = dict(zip(self.keys, vals))\n        if self.csv:\n            file = self.save_dir / 'results.csv'\n            n = len(x) + 1  # number of cols\n            s = '' if file.exists() else (('%20s,' * n % tuple(['epoch'] + self.keys)).rstrip(',') + '\\n')  # add header\n            with open(file, 'a') as f:\n                f.write(s + ('%20.5g,' * n % tuple([epoch] + vals)).rstrip(',') + '\\n')\n\n        if self.tb:\n            for k, v in x.items():\n                self.tb.add_scalar(k, v, epoch)\n        elif self.clearml:  # log to ClearML if TensorBoard not used\n            for k, v in x.items():\n                title, series = k.split('/')\n                self.clearml.task.get_logger().report_scalar(title, series, v, epoch)\n\n        if self.wandb:\n            if best_fitness == fi:\n                best_results = [epoch] + vals[3:7]\n                for i, name in enumerate(self.best_keys):\n                    self.wandb.wandb_run.summary[name] = best_results[i]  # log best results in the summary\n            self.wandb.log(x)\n            self.wandb.end_epoch(best_result=best_fitness == fi)\n\n        if self.clearml:\n            self.clearml.current_epoch_logged_images = set()  # reset epoch image limit\n            self.clearml.current_epoch += 1\n\n        if self.comet_logger:\n            self.comet_logger.on_fit_epoch_end(x, epoch=epoch)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_model_save(self, last, epoch, final_epoch, best_fitness, fi):\n        # Callback runs on model save event\n        if (epoch + 1) % self.opt.save_period == 0 and not final_epoch and self.opt.save_period != -1:\n            if self.wandb:\n                self.wandb.log_model(last.parent, self.opt, epoch, fi, best_model=best_fitness == fi)\n            if self.clearml:\n                self.clearml.task.update_output_model(model_path=str(last),\n                                                      model_name='Latest Model',\n                                                      auto_delete_file=False)\n\n        if self.comet_logger:\n            self.comet_logger.on_model_save(last, epoch, final_epoch, best_fitness, fi)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_train_end(self, last, best, epoch, results):\n        # Callback runs on training end, i.e. saving best model\n        if self.plots:\n            plot_results(file=self.save_dir / 'results.csv')  # save results.png\n        files = ['results.png', 'confusion_matrix.png', *(f'{x}_curve.png' for x in ('F1', 'PR', 'P', 'R'))]\n        files = [(self.save_dir / f) for f in files if (self.save_dir / f).exists()]  # filter\n        self.logger.info(f\"Results saved to {colorstr('bold', self.save_dir)}\")\n\n        if self.tb and not self.clearml:  # These images are already captured by ClearML by now, we don't want doubles\n            for f in files:\n                self.tb.add_image(f.stem, cv2.imread(str(f))[..., ::-1], epoch, dataformats='HWC')\n\n        if self.wandb:\n            self.wandb.log(dict(zip(self.keys[3:10], results)))\n            self.wandb.log({\"Results\": [wandb.Image(str(f), caption=f.name) for f in files]})\n            # Calling wandb.log. TODO: Refactor this into WandbLogger.log_model\n            if not self.opt.evolve:\n                wandb.log_artifact(str(best if best.exists() else last),\n                                   type='model',\n                                   name=f'run_{self.wandb.wandb_run.id}_model',\n                                   aliases=['latest', 'best', 'stripped'])\n            self.wandb.finish_run()\n\n        if self.clearml and not self.opt.evolve:\n            self.clearml.task.update_output_model(model_path=str(best if best.exists() else last),\n                                                  name='Best Model',\n                                                  auto_delete_file=False)\n\n        if self.comet_logger:\n            final_results = dict(zip(self.keys[3:10], results))\n            self.comet_logger.on_train_end(files, self.save_dir, last, best, epoch, final_results)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_params_update(self, params: dict):\n        # Update hyperparams or configs of the experiment\n        if self.wandb:\n            self.wandb.wandb_run.config.update(params, allow_val_change=True)\n        if self.comet_logger:\n            self.comet_logger.on_params_update(params)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, opt, console_logger, include=('tb', 'wandb')):\n        # init default loggers\n        self.save_dir = Path(opt.save_dir)\n        self.include = include\n        self.console_logger = console_logger\n        self.csv = self.save_dir / 'results.csv'  # CSV logger\n        if 'tb' in self.include:\n            prefix = colorstr('TensorBoard: ')\n            self.console_logger.info(\n                f\"{prefix}Start with 'tensorboard --logdir {self.save_dir.parent}', view at http://localhost:6006/\")\n            self.tb = SummaryWriter(str(self.save_dir))\n\n        if wandb and 'wandb' in self.include:\n            self.wandb = wandb.init(project=web_project_name(str(opt.project)),\n                                    name=None if opt.name == \"exp\" else opt.name,\n                                    config=opt)\n        else:\n            self.wandb = None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_metrics(self, metrics, epoch):\n        # Log metrics dictionary to all loggers\n        if self.csv:\n            keys, vals = list(metrics.keys()), list(metrics.values())\n            n = len(metrics) + 1  # number of cols\n            s = '' if self.csv.exists() else (('%23s,' * n % tuple(['epoch'] + keys)).rstrip(',') + '\\n')  # header\n            with open(self.csv, 'a') as f:\n                f.write(s + ('%23.5g,' * n % tuple([epoch] + vals)).rstrip(',') + '\\n')\n\n        if self.tb:\n            for k, v in metrics.items():\n                self.tb.add_scalar(k, v, epoch)\n\n        if self.wandb:\n            self.wandb.log(metrics, step=epoch)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_images(self, files, name='Images', epoch=0):\n        # Log images to all loggers\n        files = [Path(f) for f in (files if isinstance(files, (tuple, list)) else [files])]  # to Path\n        files = [f for f in files if f.exists()]  # filter by exists\n\n        if self.tb:\n            for f in files:\n                self.tb.add_image(f.stem, cv2.imread(str(f))[..., ::-1], epoch, dataformats='HWC')\n\n        if self.wandb:\n            self.wandb.log({name: [wandb.Image(str(f), caption=f.name) for f in files]}, step=epoch)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_graph(self, model, imgsz=(640, 640)):\n        # Log model graph to all loggers\n        if self.tb:\n            log_tensorboard_graph(self.tb, model, imgsz)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_model(self, model_path, epoch=0, metadata={}):\n        # Log model to all loggers\n        if self.wandb:\n            art = wandb.Artifact(name=f\"run_{wandb.run.id}_model\", type=\"model\", metadata=metadata)\n            art.add_file(str(model_path))\n            wandb.log_artifact(art)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def update_params(self, params):\n        # Update the paramters logged\n        if self.wandb:\n            wandb.run.config.update(params, allow_val_change=True)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, opt, hyp, run_id=None, job_type=\"Training\", **experiment_kwargs) -> None:\n        self.job_type = job_type\n        self.opt = opt\n        self.hyp = hyp\n\n        # Comet Flags\n        self.comet_mode = COMET_MODE\n\n        self.save_model = opt.save_period > -1\n        self.model_name = COMET_MODEL_NAME\n\n        # Batch Logging Settings\n        self.log_batch_metrics = COMET_LOG_BATCH_METRICS\n        self.comet_log_batch_interval = COMET_BATCH_LOGGING_INTERVAL\n\n        # Dataset Artifact Settings\n        self.upload_dataset = self.opt.upload_dataset if self.opt.upload_dataset else COMET_UPLOAD_DATASET\n        self.resume = self.opt.resume\n\n        # Default parameters to pass to Experiment objects\n        self.default_experiment_kwargs = {\n            \"log_code\": False,\n            \"log_env_gpu\": True,\n            \"log_env_cpu\": True,\n            \"project_name\": COMET_PROJECT_NAME,}\n        self.default_experiment_kwargs.update(experiment_kwargs)\n        self.experiment = self._get_experiment(self.comet_mode, run_id)\n\n        self.data_dict = self.check_dataset(self.opt.data)\n        self.class_names = self.data_dict[\"names\"]\n        self.num_classes = self.data_dict[\"nc\"]\n\n        self.logged_images_count = 0\n        self.max_images = COMET_MAX_IMAGE_UPLOADS\n\n        if run_id is None:\n            self.experiment.log_other(\"Created from\", \"YOLOv5\")\n            if not isinstance(self.experiment, comet_ml.OfflineExperiment):\n                workspace, project_name, experiment_id = self.experiment.url.split(\"/\")[-3:]\n                self.experiment.log_other(\n                    \"Run Path\",\n                    f\"{workspace}/{project_name}/{experiment_id}\",\n                )\n            self.log_parameters(vars(opt))\n            self.log_parameters(self.opt.hyp)\n            self.log_asset_data(\n                self.opt.hyp,\n                name=\"hyperparameters.json\",\n                metadata={\"type\": \"hyp-config-file\"},\n            )\n            self.log_asset(\n                f\"{self.opt.save_dir}/opt.yaml\",\n                metadata={\"type\": \"opt-config-file\"},\n            )\n\n        self.comet_log_confusion_matrix = COMET_LOG_CONFUSION_MATRIX\n\n        if hasattr(self.opt, \"conf_thres\"):\n            self.conf_thres = self.opt.conf_thres\n        else:\n            self.conf_thres = CONF_THRES\n        if hasattr(self.opt, \"iou_thres\"):\n            self.iou_thres = self.opt.iou_thres\n        else:\n            self.iou_thres = IOU_THRES\n\n        self.log_parameters({\"val_iou_threshold\": self.iou_thres, \"val_conf_threshold\": self.conf_thres})\n\n        self.comet_log_predictions = COMET_LOG_PREDICTIONS\n        if self.opt.bbox_interval == -1:\n            self.comet_log_prediction_interval = 1 if self.opt.epochs < 10 else self.opt.epochs // 10\n        else:\n            self.comet_log_prediction_interval = self.opt.bbox_interval\n\n        if self.comet_log_predictions:\n            self.metadata_dict = {}\n            self.logged_image_names = []\n\n        self.comet_log_per_class_metrics = COMET_LOG_PER_CLASS_METRICS\n\n        self.experiment.log_others({\n            \"comet_mode\": COMET_MODE,\n            \"comet_max_image_uploads\": COMET_MAX_IMAGE_UPLOADS,\n            \"comet_log_per_class_metrics\": COMET_LOG_PER_CLASS_METRICS,\n            \"comet_log_batch_metrics\": COMET_LOG_BATCH_METRICS,\n            \"comet_log_confusion_matrix\": COMET_LOG_CONFUSION_MATRIX,\n            \"comet_model_name\": COMET_MODEL_NAME,})\n\n        # Check if running the Experiment with the Comet Optimizer\n        if hasattr(self.opt, \"comet_optimizer_id\"):\n            self.experiment.log_other(\"optimizer_id\", self.opt.comet_optimizer_id)\n            self.experiment.log_other(\"optimizer_objective\", self.opt.comet_optimizer_objective)\n            self.experiment.log_other(\"optimizer_metric\", self.opt.comet_optimizer_metric)\n            self.experiment.log_other(\"optimizer_parameters\", json.dumps(self.hyp))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _get_experiment(self, mode, experiment_id=None):\n        if mode == \"offline\":\n            if experiment_id is not None:\n                return comet_ml.ExistingOfflineExperiment(\n                    previous_experiment=experiment_id,\n                    **self.default_experiment_kwargs,\n                )\n\n            return comet_ml.OfflineExperiment(**self.default_experiment_kwargs,)\n\n        else:\n            try:\n                if experiment_id is not None:\n                    return comet_ml.ExistingExperiment(\n                        previous_experiment=experiment_id,\n                        **self.default_experiment_kwargs,\n                    )\n\n                return comet_ml.Experiment(**self.default_experiment_kwargs)\n\n            except ValueError:\n                logger.warning(\"COMET WARNING: \"\n                               \"Comet credentials have not been set. \"\n                               \"Comet will default to offline logging. \"\n                               \"Please set your credentials to enable online logging.\")\n                return self._get_experiment(\"offline\", experiment_id)\n\n        return", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_metrics(self, log_dict, **kwargs):\n        self.experiment.log_metrics(log_dict, **kwargs)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_parameters(self, log_dict, **kwargs):\n        self.experiment.log_parameters(log_dict, **kwargs)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_asset(self, asset_path, **kwargs):\n        self.experiment.log_asset(asset_path, **kwargs)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_asset_data(self, asset, **kwargs):\n        self.experiment.log_asset_data(asset, **kwargs)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_image(self, img, **kwargs):\n        self.experiment.log_image(img, **kwargs)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_model(self, path, opt, epoch, fitness_score, best_model=False):\n        if not self.save_model:\n            return\n\n        model_metadata = {\n            \"fitness_score\": fitness_score[-1],\n            \"epochs_trained\": epoch + 1,\n            \"save_period\": opt.save_period,\n            \"total_epochs\": opt.epochs,}\n\n        model_files = glob.glob(f\"{path}/*.pt\")\n        for model_path in model_files:\n            name = Path(model_path).name\n\n            self.experiment.log_model(\n                self.model_name,\n                file_or_folder=model_path,\n                file_name=name,\n                metadata=model_metadata,\n                overwrite=True,\n            )", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def check_dataset(self, data_file):\n        with open(data_file) as f:\n            data_config = yaml.safe_load(f)\n\n        if data_config['path'].startswith(COMET_PREFIX):\n            path = data_config['path'].replace(COMET_PREFIX, \"\")\n            data_dict = self.download_dataset_artifact(path)\n\n            return data_dict\n\n        self.log_asset(self.opt.data, metadata={\"type\": \"data-config-file\"})\n\n        return check_dataset(data_file)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_predictions(self, image, labelsn, path, shape, predn):\n        if self.logged_images_count >= self.max_images:\n            return\n        detections = predn[predn[:, 4] > self.conf_thres]\n        iou = box_iou(labelsn[:, 1:], detections[:, :4])\n        mask, _ = torch.where(iou > self.iou_thres)\n        if len(mask) == 0:\n            return\n\n        filtered_detections = detections[mask]\n        filtered_labels = labelsn[mask]\n\n        image_id = path.split(\"/\")[-1].split(\".\")[0]\n        image_name = f\"{image_id}_curr_epoch_{self.experiment.curr_epoch}\"\n        if image_name not in self.logged_image_names:\n            native_scale_image = PIL.Image.open(path)\n            self.log_image(native_scale_image, name=image_name)\n            self.logged_image_names.append(image_name)\n\n        metadata = []\n        for cls, *xyxy in filtered_labels.tolist():\n            metadata.append({\n                \"label\": f\"{self.class_names[int(cls)]}-gt\",\n                \"score\": 100,\n                \"box\": {\n                    \"x\": xyxy[0],\n                    \"y\": xyxy[1],\n                    \"x2\": xyxy[2],\n                    \"y2\": xyxy[3]},})\n        for *xyxy, conf, cls in filtered_detections.tolist():\n            metadata.append({\n                \"label\": f\"{self.class_names[int(cls)]}\",\n                \"score\": conf * 100,\n                \"box\": {\n                    \"x\": xyxy[0],\n                    \"y\": xyxy[1],\n                    \"x2\": xyxy[2],\n                    \"y2\": xyxy[3]},})\n\n        self.metadata_dict[image_name] = metadata\n        self.logged_images_count += 1\n\n        return", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def preprocess_prediction(self, image, labels, shape, pred):\n        nl, _ = labels.shape[0], pred.shape[0]\n\n        # Predictions\n        if self.opt.single_cls:\n            pred[:, 5] = 0\n\n        predn = pred.clone()\n        scale_boxes(image.shape[1:], predn[:, :4], shape[0], shape[1])\n\n        labelsn = None\n        if nl:\n            tbox = xywh2xyxy(labels[:, 1:5])  # target boxes\n            scale_boxes(image.shape[1:], tbox, shape[0], shape[1])  # native-space labels\n            labelsn = torch.cat((labels[:, 0:1], tbox), 1)  # native-space labels\n            scale_boxes(image.shape[1:], predn[:, :4], shape[0], shape[1])  # native-space pred\n\n        return predn, labelsn", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def add_assets_to_artifact(self, artifact, path, asset_path, split):\n        img_paths = sorted(glob.glob(f\"{asset_path}/*\"))\n        label_paths = img2label_paths(img_paths)\n\n        for image_file, label_file in zip(img_paths, label_paths):\n            image_logical_path, label_logical_path = map(lambda x: os.path.relpath(x, path), [image_file, label_file])\n\n            try:\n                artifact.add(image_file, logical_path=image_logical_path, metadata={\"split\": split})\n                artifact.add(label_file, logical_path=label_logical_path, metadata={\"split\": split})\n            except ValueError as e:\n                logger.error('COMET ERROR: Error adding file to Artifact. Skipping file.')\n                logger.error(f\"COMET ERROR: {e}\")\n                continue\n\n        return artifact", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def upload_dataset_artifact(self):\n        dataset_name = self.data_dict.get(\"dataset_name\", \"yolov5-dataset\")\n        path = str((ROOT / Path(self.data_dict[\"path\"])).resolve())\n\n        metadata = self.data_dict.copy()\n        for key in [\"train\", \"val\", \"test\"]:\n            split_path = metadata.get(key)\n            if split_path is not None:\n                metadata[key] = split_path.replace(path, \"\")\n\n        artifact = comet_ml.Artifact(name=dataset_name, artifact_type=\"dataset\", metadata=metadata)\n        for key in metadata.keys():\n            if key in [\"train\", \"val\", \"test\"]:\n                if isinstance(self.upload_dataset, str) and (key != self.upload_dataset):\n                    continue\n\n                asset_path = self.data_dict.get(key)\n                if asset_path is not None:\n                    artifact = self.add_assets_to_artifact(artifact, path, asset_path, key)\n\n        self.experiment.log_artifact(artifact)\n\n        return", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def download_dataset_artifact(self, artifact_path):\n        logged_artifact = self.experiment.get_artifact(artifact_path)\n        artifact_save_dir = str(Path(self.opt.save_dir) / logged_artifact.name)\n        logged_artifact.download(artifact_save_dir)\n\n        metadata = logged_artifact.metadata\n        data_dict = metadata.copy()\n        data_dict[\"path\"] = artifact_save_dir\n\n        metadata_names = metadata.get(\"names\")\n        if type(metadata_names) == dict:\n            data_dict[\"names\"] = {int(k): v for k, v in metadata.get(\"names\").items()}\n        elif type(metadata_names) == list:\n            data_dict[\"names\"] = {int(k): v for k, v in zip(range(len(metadata_names)), metadata_names)}\n        else:\n            raise \"Invalid 'names' field in dataset yaml file. Please use a list or dictionary\"\n\n        data_dict = self.update_data_paths(data_dict)\n        return data_dict", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def update_data_paths(self, data_dict):\n        path = data_dict.get(\"path\", \"\")\n\n        for split in [\"train\", \"val\", \"test\"]:\n            if data_dict.get(split):\n                split_path = data_dict.get(split)\n                data_dict[split] = (f\"{path}/{split_path}\" if isinstance(split, str) else [\n                    f\"{path}/{x}\" for x in split_path])\n\n        return data_dict", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_pretrain_routine_end(self, paths):\n        if self.opt.resume:\n            return\n\n        for path in paths:\n            self.log_asset(str(path))\n\n        if self.upload_dataset:\n            if not self.resume:\n                self.upload_dataset_artifact()\n\n        return", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_train_start(self):\n        self.log_parameters(self.hyp)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_train_epoch_start(self):\n        return", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_train_epoch_end(self, epoch):\n        self.experiment.curr_epoch = epoch\n\n        return", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_train_batch_start(self):\n        return", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_train_batch_end(self, log_dict, step):\n        self.experiment.curr_step = step\n        if self.log_batch_metrics and (step % self.comet_log_batch_interval == 0):\n            self.log_metrics(log_dict, step=step)\n\n        return", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_train_end(self, files, save_dir, last, best, epoch, results):\n        if self.comet_log_predictions:\n            curr_epoch = self.experiment.curr_epoch\n            self.experiment.log_asset_data(self.metadata_dict, \"image-metadata.json\", epoch=curr_epoch)\n\n        for f in files:\n            self.log_asset(f, metadata={\"epoch\": epoch})\n        self.log_asset(f\"{save_dir}/results.csv\", metadata={\"epoch\": epoch})\n\n        if not self.opt.evolve:\n            model_path = str(best if best.exists() else last)\n            name = Path(model_path).name\n            if self.save_model:\n                self.experiment.log_model(\n                    self.model_name,\n                    file_or_folder=model_path,\n                    file_name=name,\n                    overwrite=True,\n                )\n\n        # Check if running Experiment with Comet Optimizer\n        if hasattr(self.opt, 'comet_optimizer_id'):\n            metric = results.get(self.opt.comet_optimizer_metric)\n            self.experiment.log_other('optimizer_metric_value', metric)\n\n        self.finish_run()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_val_start(self):\n        return", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_val_batch_start(self):\n        return", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_val_batch_end(self, batch_i, images, targets, paths, shapes, outputs):\n        if not (self.comet_log_predictions and ((batch_i + 1) % self.comet_log_prediction_interval == 0)):\n            return\n\n        for si, pred in enumerate(outputs):\n            if len(pred) == 0:\n                continue\n\n            image = images[si]\n            labels = targets[targets[:, 0] == si, 1:]\n            shape = shapes[si]\n            path = paths[si]\n            predn, labelsn = self.preprocess_prediction(image, labels, shape, pred)\n            if labelsn is not None:\n                self.log_predictions(image, labelsn, path, shape, predn)\n\n        return", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_val_end(self, nt, tp, fp, p, r, f1, ap, ap50, ap_class, confusion_matrix):\n        if self.comet_log_per_class_metrics:\n            if self.num_classes > 1:\n                for i, c in enumerate(ap_class):\n                    class_name = self.class_names[c]\n                    self.experiment.log_metrics(\n                        {\n                            'mAP@.5': ap50[i],\n                            'mAP@.5:.95': ap[i],\n                            'precision': p[i],\n                            'recall': r[i],\n                            'f1': f1[i],\n                            'true_positives': tp[i],\n                            'false_positives': fp[i],\n                            'support': nt[c]},\n                        prefix=class_name)\n\n        if self.comet_log_confusion_matrix:\n            epoch = self.experiment.curr_epoch\n            class_names = list(self.class_names.values())\n            class_names.append(\"background\")\n            num_classes = len(class_names)\n\n            self.experiment.log_confusion_matrix(\n                matrix=confusion_matrix.matrix,\n                max_categories=num_classes,\n                labels=class_names,\n                epoch=epoch,\n                column_label='Actual Category',\n                row_label='Predicted Category',\n                file_name=f\"confusion-matrix-epoch-{epoch}.json\",\n            )", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_fit_epoch_end(self, result, epoch):\n        self.log_metrics(result, epoch=epoch)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_model_save(self, last, epoch, final_epoch, best_fitness, fi):\n        if ((epoch + 1) % self.opt.save_period == 0 and not final_epoch) and self.opt.save_period != -1:\n            self.log_model(last.parent, self.opt, epoch, fi, best_model=best_fitness == fi)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def on_params_update(self, params):\n        self.log_parameters(params)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def finish_run(self):\n        self.experiment.end()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def download_model_checkpoint(opt, experiment):\n    model_dir = f\"{opt.project}/{experiment.name}\"\n    os.makedirs(model_dir, exist_ok=True)\n\n    model_name = COMET_MODEL_NAME\n    model_asset_list = experiment.get_model_asset_list(model_name)\n\n    if len(model_asset_list) == 0:\n        logger.error(f\"COMET ERROR: No checkpoints found for model name : {model_name}\")\n        return\n\n    model_asset_list = sorted(\n        model_asset_list,\n        key=lambda x: x[\"step\"],\n        reverse=True,\n    )\n    logged_checkpoint_map = {asset[\"fileName\"]: asset[\"assetId\"] for asset in model_asset_list}\n\n    resource_url = urlparse(opt.weights)\n    checkpoint_filename = resource_url.query\n\n    if checkpoint_filename:\n        asset_id = logged_checkpoint_map.get(checkpoint_filename)\n    else:\n        asset_id = logged_checkpoint_map.get(COMET_DEFAULT_CHECKPOINT_FILENAME)\n        checkpoint_filename = COMET_DEFAULT_CHECKPOINT_FILENAME\n\n    if asset_id is None:\n        logger.error(f\"COMET ERROR: Checkpoint {checkpoint_filename} not found in the given Experiment\")\n        return\n\n    try:\n        logger.info(f\"COMET INFO: Downloading checkpoint {checkpoint_filename}\")\n        asset_filename = checkpoint_filename\n\n        model_binary = experiment.get_asset(asset_id, return_type=\"binary\", stream=False)\n        model_download_path = f\"{model_dir}/{asset_filename}\"\n        with open(model_download_path, \"wb\") as f:\n            f.write(model_binary)\n\n        opt.weights = model_download_path\n\n    except Exception as e:\n        logger.warning(\"COMET WARNING: Unable to download checkpoint from Comet\")\n        logger.exception(e)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def set_opt_parameters(opt, experiment):\n    \"\"\"Update the opts Namespace with parameters\n    from Comet's ExistingExperiment when resuming a run\n\n    Args:\n        opt (argparse.Namespace): Namespace of command line options\n        experiment (comet_ml.APIExperiment): Comet API Experiment object\n    \"\"\"\n    asset_list = experiment.get_asset_list()\n    resume_string = opt.resume\n\n    for asset in asset_list:\n        if asset[\"fileName\"] == \"opt.yaml\":\n            asset_id = asset[\"assetId\"]\n            asset_binary = experiment.get_asset(asset_id, return_type=\"binary\", stream=False)\n            opt_dict = yaml.safe_load(asset_binary)\n            for key, value in opt_dict.items():\n                setattr(opt, key, value)\n            opt.resume = resume_string\n\n    # Save hyperparameters to YAML file\n    # Necessary to pass checks in training script\n    save_dir = f\"{opt.project}/{experiment.name}\"\n    os.makedirs(save_dir, exist_ok=True)\n\n    hyp_yaml_path = f\"{save_dir}/hyp.yaml\"\n    with open(hyp_yaml_path, \"w\") as f:\n        yaml.dump(opt.hyp, f)\n    opt.hyp = hyp_yaml_path", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_comet_weights(opt):\n    \"\"\"Downloads model weights from Comet and updates the\n    weights path to point to saved weights location\n\n    Args:\n        opt (argparse.Namespace): Command Line arguments passed\n            to YOLOv5 training script\n\n    Returns:\n        None/bool: Return True if weights are successfully downloaded\n            else return None\n    \"\"\"\n    if comet_ml is None:\n        return\n\n    if isinstance(opt.weights, str):\n        if opt.weights.startswith(COMET_PREFIX):\n            api = comet_ml.API()\n            resource = urlparse(opt.weights)\n            experiment_path = f\"{resource.netloc}{resource.path}\"\n            experiment = api.get(experiment_path)\n            download_model_checkpoint(opt, experiment)\n            return True\n\n    return None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_comet_resume(opt):\n    \"\"\"Restores run parameters to its original state based on the model checkpoint\n    and logged Experiment parameters.\n\n    Args:\n        opt (argparse.Namespace): Command Line arguments passed\n            to YOLOv5 training script\n\n    Returns:\n        None/bool: Return True if the run is restored successfully\n            else return None\n    \"\"\"\n    if comet_ml is None:\n        return\n\n    if isinstance(opt.resume, str):\n        if opt.resume.startswith(COMET_PREFIX):\n            api = comet_ml.API()\n            resource = urlparse(opt.resume)\n            experiment_path = f\"{resource.netloc}{resource.path}\"\n            experiment = api.get(experiment_path)\n            set_opt_parameters(opt, experiment)\n            download_model_checkpoint(opt, experiment)\n\n            return True\n\n    return None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def get_args(known=False):\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--weights', type=str, default=ROOT / 'yolov5s.pt', help='initial weights path')\n    parser.add_argument('--cfg', type=str, default='', help='model.yaml path')\n    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128.yaml', help='dataset.yaml path')\n    parser.add_argument('--hyp', type=str, default=ROOT / 'data/hyps/hyp.scratch-low.yaml', help='hyperparameters path')\n    parser.add_argument('--epochs', type=int, default=300, help='total training epochs')\n    parser.add_argument('--batch-size', type=int, default=16, help='total batch size for all GPUs, -1 for autobatch')\n    parser.add_argument('--imgsz', '--img', '--img-size', type=int, default=640, help='train, val image size (pixels)')\n    parser.add_argument('--rect', action='store_true', help='rectangular training')\n    parser.add_argument('--resume', nargs='?', const=True, default=False, help='resume most recent training')\n    parser.add_argument('--nosave', action='store_true', help='only save final checkpoint')\n    parser.add_argument('--noval', action='store_true', help='only validate final epoch')\n    parser.add_argument('--noautoanchor', action='store_true', help='disable AutoAnchor')\n    parser.add_argument('--noplots', action='store_true', help='save no plot files')\n    parser.add_argument('--evolve', type=int, nargs='?', const=300, help='evolve hyperparameters for x generations')\n    parser.add_argument('--bucket', type=str, default='', help='gsutil bucket')\n    parser.add_argument('--cache', type=str, nargs='?', const='ram', help='--cache images in \"ram\" (default) or \"disk\"')\n    parser.add_argument('--image-weights', action='store_true', help='use weighted image selection for training')\n    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--multi-scale', action='store_true', help='vary img-size +/- 50%%')\n    parser.add_argument('--single-cls', action='store_true', help='train multi-class data as single-class')\n    parser.add_argument('--optimizer', type=str, choices=['SGD', 'Adam', 'AdamW'], default='SGD', help='optimizer')\n    parser.add_argument('--sync-bn', action='store_true', help='use SyncBatchNorm, only available in DDP mode')\n    parser.add_argument('--workers', type=int, default=8, help='max dataloader workers (per RANK in DDP mode)')\n    parser.add_argument('--project', default=ROOT / 'runs/train', help='save to project/name')\n    parser.add_argument('--name', default='exp', help='save to project/name')\n    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n    parser.add_argument('--quad', action='store_true', help='quad dataloader')\n    parser.add_argument('--cos-lr', action='store_true', help='cosine LR scheduler')\n    parser.add_argument('--label-smoothing', type=float, default=0.0, help='Label smoothing epsilon')\n    parser.add_argument('--patience', type=int, default=100, help='EarlyStopping patience (epochs without improvement)')\n    parser.add_argument('--freeze', nargs='+', type=int, default=[0], help='Freeze layers: backbone=10, first3=0 1 2')\n    parser.add_argument('--save-period', type=int, default=-1, help='Save checkpoint every x epochs (disabled if < 1)')\n    parser.add_argument('--seed', type=int, default=0, help='Global training seed')\n    parser.add_argument('--local_rank', type=int, default=-1, help='Automatic DDP Multi-GPU argument, do not modify')\n\n    # Weights & Biases arguments\n    parser.add_argument('--entity', default=None, help='W&B: Entity')\n    parser.add_argument('--upload_dataset', nargs='?', const=True, default=False, help='W&B: Upload data, \"val\" option')\n    parser.add_argument('--bbox_interval', type=int, default=-1, help='W&B: Set bounding-box image logging interval')\n    parser.add_argument('--artifact_alias', type=str, default='latest', help='W&B: Version of dataset artifact to use')\n\n    # Comet Arguments\n    parser.add_argument(\"--comet_optimizer_config\", type=str, help=\"Comet: Path to a Comet Optimizer Config File.\")\n    parser.add_argument(\"--comet_optimizer_id\", type=str, help=\"Comet: ID of the Comet Optimizer sweep.\")\n    parser.add_argument(\"--comet_optimizer_objective\", type=str, help=\"Comet: Set to 'minimize' or 'maximize'.\")\n    parser.add_argument(\"--comet_optimizer_metric\", type=str, help=\"Comet: Metric to Optimize.\")\n    parser.add_argument(\"--comet_optimizer_workers\",\n                        type=int,\n                        default=1,\n                        help=\"Comet: Number of Parallel Workers to use with the Comet Optimizer.\")\n\n    return parser.parse_known_args()[0] if known else parser.parse_args()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run(parameters, opt):\n    hyp_dict = {k: v for k, v in parameters.items() if k not in [\"epochs\", \"batch_size\"]}\n\n    opt.save_dir = str(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok or opt.evolve))\n    opt.batch_size = parameters.get(\"batch_size\")\n    opt.epochs = parameters.get(\"epochs\")\n\n    device = select_device(opt.device, batch_size=opt.batch_size)\n    train(hyp_dict, opt, device, callbacks=Callbacks())", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def construct_dataset(clearml_info_string):\n    \"\"\"Load in a clearml dataset and fill the internal data_dict with its contents.\n    \"\"\"\n    dataset_id = clearml_info_string.replace('clearml://', '')\n    dataset = Dataset.get(dataset_id=dataset_id)\n    dataset_root_path = Path(dataset.get_local_copy())\n\n    # We'll search for the yaml file definition in the dataset\n    yaml_filenames = list(glob.glob(str(dataset_root_path / \"*.yaml\")) + glob.glob(str(dataset_root_path / \"*.yml\")))\n    if len(yaml_filenames) > 1:\n        raise ValueError('More than one yaml file was found in the dataset root, cannot determine which one contains '\n                         'the dataset definition this way.')\n    elif len(yaml_filenames) == 0:\n        raise ValueError('No yaml definition found in dataset root path, check that there is a correct yaml file '\n                         'inside the dataset root path.')\n    with open(yaml_filenames[0]) as f:\n        dataset_definition = yaml.safe_load(f)\n\n    assert set(dataset_definition.keys()).issuperset(\n        {'train', 'test', 'val', 'nc', 'names'}\n    ), \"The right keys were not found in the yaml file, make sure it at least has the following keys: ('train', 'test', 'val', 'nc', 'names')\"\n\n    data_dict = dict()\n    data_dict['train'] = str(\n        (dataset_root_path / dataset_definition['train']).resolve()) if dataset_definition['train'] else None\n    data_dict['test'] = str(\n        (dataset_root_path / dataset_definition['test']).resolve()) if dataset_definition['test'] else None\n    data_dict['val'] = str(\n        (dataset_root_path / dataset_definition['val']).resolve()) if dataset_definition['val'] else None\n    data_dict['nc'] = dataset_definition['nc']\n    data_dict['names'] = dataset_definition['names']\n\n    return data_dict", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, opt, hyp):\n        \"\"\"\n        - Initialize ClearML Task, this object will capture the experiment\n        - Upload dataset version to ClearML Data if opt.upload_dataset is True\n\n        arguments:\n        opt (namespace) -- Commandline arguments for this run\n        hyp (dict) -- Hyperparameters for this run\n\n        \"\"\"\n        self.current_epoch = 0\n        # Keep tracked of amount of logged images to enforce a limit\n        self.current_epoch_logged_images = set()\n        # Maximum number of images to log to clearML per epoch\n        self.max_imgs_to_log_per_epoch = 16\n        # Get the interval of epochs when bounding box images should be logged\n        self.bbox_interval = opt.bbox_interval\n        self.clearml = clearml\n        self.task = None\n        self.data_dict = None\n        if self.clearml:\n            self.task = Task.init(\n                project_name=opt.project if opt.project != 'runs/train' else 'YOLOv5',\n                task_name=opt.name if opt.name != 'exp' else 'Training',\n                tags=['YOLOv5'],\n                output_uri=True,\n                auto_connect_frameworks={'pytorch': False}\n                # We disconnect pytorch auto-detection, because we added manual model save points in the code\n            )\n            # ClearML's hooks will already grab all general parameters\n            # Only the hyperparameters coming from the yaml config file\n            # will have to be added manually!\n            self.task.connect(hyp, name='Hyperparameters')\n\n            # Get ClearML Dataset Version if requested\n            if opt.data.startswith('clearml://'):\n                # data_dict should have the following keys:\n                # names, nc (number of classes), test, train, val (all three relative paths to ../datasets)\n                self.data_dict = construct_dataset(opt.data)\n                # Set data to data_dict because wandb will crash without this information and opt is the best way\n                # to give it to them\n                opt.data = self.data_dict", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_debug_samples(self, files, title='Debug Samples'):\n        \"\"\"\n        Log files (images) as debug samples in the ClearML task.\n\n        arguments:\n        files (List(PosixPath)) a list of file paths in PosixPath format\n        title (str) A title that groups together images with the same values\n        \"\"\"\n        for f in files:\n            if f.exists():\n                it = re.search(r'_batch(\\d+)', f.name)\n                iteration = int(it.groups()[0]) if it else 0\n                self.task.get_logger().report_image(title=title,\n                                                    series=f.name.replace(it.group(), ''),\n                                                    local_path=str(f),\n                                                    iteration=iteration)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_image_with_boxes(self, image_path, boxes, class_names, image, conf_threshold=0.25):\n        \"\"\"\n        Draw the bounding boxes on a single image and report the result as a ClearML debug sample.\n\n        arguments:\n        image_path (PosixPath) the path the original image file\n        boxes (list): list of scaled predictions in the format - [xmin, ymin, xmax, ymax, confidence, class]\n        class_names (dict): dict containing mapping of class int to class name\n        image (Tensor): A torch tensor containing the actual image data\n        \"\"\"\n        if len(self.current_epoch_logged_images) < self.max_imgs_to_log_per_epoch and self.current_epoch >= 0:\n            # Log every bbox_interval times and deduplicate for any intermittend extra eval runs\n            if self.current_epoch % self.bbox_interval == 0 and image_path not in self.current_epoch_logged_images:\n                im = np.ascontiguousarray(np.moveaxis(image.mul(255).clamp(0, 255).byte().cpu().numpy(), 0, 2))\n                annotator = Annotator(im=im, pil=True)\n                for i, (conf, class_nr, box) in enumerate(zip(boxes[:, 4], boxes[:, 5], boxes[:, :4])):\n                    color = colors(i)\n\n                    class_name = class_names[int(class_nr)]\n                    confidence_percentage = round(float(conf) * 100, 2)\n                    label = f\"{class_name}: {confidence_percentage}%\"\n\n                    if conf > conf_threshold:\n                        annotator.rectangle(box.cpu().numpy(), outline=color)\n                        annotator.box_label(box.cpu().numpy(), label=label, color=color)\n\n                annotated_image = annotator.result()\n                self.task.get_logger().report_image(title='Bounding Boxes',\n                                                    series=image_path.name,\n                                                    iteration=self.current_epoch,\n                                                    image=annotated_image)\n                self.current_epoch_logged_images.add(image_path)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def create_dataset_artifact(opt):\n    logger = WandbLogger(opt, None, job_type='Dataset Creation')  # TODO: return value unused\n    if not logger.wandb:\n        LOGGER.info(\"install wandb using `pip install wandb` to log the dataset\")", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def sweep():\n    wandb.init()\n    # Get hyp dict from sweep agent. Copy because train() modifies parameters which confused wandb.\n    hyp_dict = vars(wandb.config).get(\"_items\").copy()\n\n    # Workaround: get necessary opt args\n    opt = parse_opt(known=True)\n    opt.batch_size = hyp_dict.get(\"batch_size\")\n    opt.save_dir = str(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok or opt.evolve))\n    opt.epochs = hyp_dict.get(\"epochs\")\n    opt.nosave = True\n    opt.data = hyp_dict.get(\"data\")\n    opt.weights = str(opt.weights)\n    opt.cfg = str(opt.cfg)\n    opt.data = str(opt.data)\n    opt.hyp = str(opt.hyp)\n    opt.project = str(opt.project)\n    device = select_device(opt.device, batch_size=opt.batch_size)\n\n    # train\n    train(hyp_dict, opt, device, callbacks=Callbacks())", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def remove_prefix(from_string, prefix=WANDB_ARTIFACT_PREFIX):\n    return from_string[len(prefix):]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_wandb_config_file(data_config_file):\n    wandb_config = '_wandb.'.join(data_config_file.rsplit('.', 1))  # updated data.yaml path\n    if Path(wandb_config).is_file():\n        return wandb_config\n    return data_config_file", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_wandb_dataset(data_file):\n    is_trainset_wandb_artifact = False\n    is_valset_wandb_artifact = False\n    if isinstance(data_file, dict):\n        # In that case another dataset manager has already processed it and we don't have to\n        return data_file\n    if check_file(data_file) and data_file.endswith('.yaml'):\n        with open(data_file, errors='ignore') as f:\n            data_dict = yaml.safe_load(f)\n        is_trainset_wandb_artifact = isinstance(data_dict['train'],\n                                                str) and data_dict['train'].startswith(WANDB_ARTIFACT_PREFIX)\n        is_valset_wandb_artifact = isinstance(data_dict['val'],\n                                              str) and data_dict['val'].startswith(WANDB_ARTIFACT_PREFIX)\n    if is_trainset_wandb_artifact or is_valset_wandb_artifact:\n        return data_dict\n    else:\n        return check_dataset(data_file)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def get_run_info(run_path):\n    run_path = Path(remove_prefix(run_path, WANDB_ARTIFACT_PREFIX))\n    run_id = run_path.stem\n    project = run_path.parent.stem\n    entity = run_path.parent.parent.stem\n    model_artifact_name = 'run_' + run_id + '_model'\n    return entity, project, run_id, model_artifact_name", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_wandb_resume(opt):\n    process_wandb_config_ddp_mode(opt) if RANK not in [-1, 0] else None\n    if isinstance(opt.resume, str):\n        if opt.resume.startswith(WANDB_ARTIFACT_PREFIX):\n            if RANK not in [-1, 0]:  # For resuming DDP runs\n                entity, project, run_id, model_artifact_name = get_run_info(opt.resume)\n                api = wandb.Api()\n                artifact = api.artifact(entity + '/' + project + '/' + model_artifact_name + ':latest')\n                modeldir = artifact.download()\n                opt.weights = str(Path(modeldir) / \"last.pt\")\n            return True\n    return None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def process_wandb_config_ddp_mode(opt):\n    with open(check_file(opt.data), errors='ignore') as f:\n        data_dict = yaml.safe_load(f)  # data dict\n    train_dir, val_dir = None, None\n    if isinstance(data_dict['train'], str) and data_dict['train'].startswith(WANDB_ARTIFACT_PREFIX):\n        api = wandb.Api()\n        train_artifact = api.artifact(remove_prefix(data_dict['train']) + ':' + opt.artifact_alias)\n        train_dir = train_artifact.download()\n        train_path = Path(train_dir) / 'data/images/'\n        data_dict['train'] = str(train_path)\n\n    if isinstance(data_dict['val'], str) and data_dict['val'].startswith(WANDB_ARTIFACT_PREFIX):\n        api = wandb.Api()\n        val_artifact = api.artifact(remove_prefix(data_dict['val']) + ':' + opt.artifact_alias)\n        val_dir = val_artifact.download()\n        val_path = Path(val_dir) / 'data/images/'\n        data_dict['val'] = str(val_path)\n    if train_dir or val_dir:\n        ddp_data_path = str(Path(val_dir) / 'wandb_local_data.yaml')\n        with open(ddp_data_path, 'w') as f:\n            yaml.safe_dump(data_dict, f)\n        opt.data = ddp_data_path", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def all_logging_disabled(highest_level=logging.CRITICAL):\n    \"\"\" source - https://gist.github.com/simon-weber/7853144\n    A context manager that will prevent any logging messages triggered during the body from being processed.\n    :param highest_level: the maximum logging level in use.\n      This would only need to be changed if a custom level greater than CRITICAL is defined.\n    \"\"\"\n    previous_level = logging.root.manager.disable\n    logging.disable(highest_level)\n    try:\n        yield\n    finally:\n        logging.disable(previous_level)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, opt, run_id=None, job_type='Training'):\n        \"\"\"\n        - Initialize WandbLogger instance\n        - Upload dataset if opt.upload_dataset is True\n        - Setup training processes if job_type is 'Training'\n\n        arguments:\n        opt (namespace) -- Commandline arguments for this run\n        run_id (str) -- Run ID of W&B run to be resumed\n        job_type (str) -- To set the job_type for this run\n\n       \"\"\"\n        # Temporary-fix\n        if opt.upload_dataset:\n            opt.upload_dataset = False\n            # LOGGER.info(\"Uploading Dataset functionality is not being supported temporarily due to a bug.\")\n\n        # Pre-training routine --\n        self.job_type = job_type\n        self.wandb, self.wandb_run = wandb, None if not wandb else wandb.run\n        self.val_artifact, self.train_artifact = None, None\n        self.train_artifact_path, self.val_artifact_path = None, None\n        self.result_artifact = None\n        self.val_table, self.result_table = None, None\n        self.bbox_media_panel_images = []\n        self.val_table_path_map = None\n        self.max_imgs_to_log = 16\n        self.wandb_artifact_data_dict = None\n        self.data_dict = None\n        # It's more elegant to stick to 1 wandb.init call,\n        #  but useful config data is overwritten in the WandbLogger's wandb.init call\n        if isinstance(opt.resume, str):  # checks resume from artifact\n            if opt.resume.startswith(WANDB_ARTIFACT_PREFIX):\n                entity, project, run_id, model_artifact_name = get_run_info(opt.resume)\n                model_artifact_name = WANDB_ARTIFACT_PREFIX + model_artifact_name\n                assert wandb, 'install wandb to resume wandb runs'\n                # Resume wandb-artifact:// runs here| workaround for not overwriting wandb.config\n                self.wandb_run = wandb.init(id=run_id,\n                                            project=project,\n                                            entity=entity,\n                                            resume='allow',\n                                            allow_val_change=True)\n                opt.resume = model_artifact_name\n        elif self.wandb:\n            self.wandb_run = wandb.init(config=opt,\n                                        resume=\"allow\",\n                                        project='YOLOv5' if opt.project == 'runs/train' else Path(opt.project).stem,\n                                        entity=opt.entity,\n                                        name=opt.name if opt.name != 'exp' else None,\n                                        job_type=job_type,\n                                        id=run_id,\n                                        allow_val_change=True) if not wandb.run else wandb.run\n        if self.wandb_run:\n            if self.job_type == 'Training':\n                if opt.upload_dataset:\n                    if not opt.resume:\n                        self.wandb_artifact_data_dict = self.check_and_upload_dataset(opt)\n\n                if isinstance(opt.data, dict):\n                    # This means another dataset manager has already processed the dataset info (e.g. ClearML)\n                    # and they will have stored the already processed dict in opt.data\n                    self.data_dict = opt.data\n                elif opt.resume:\n                    # resume from artifact\n                    if isinstance(opt.resume, str) and opt.resume.startswith(WANDB_ARTIFACT_PREFIX):\n                        self.data_dict = dict(self.wandb_run.config.data_dict)\n                    else:  # local resume\n                        self.data_dict = check_wandb_dataset(opt.data)\n                else:\n                    self.data_dict = check_wandb_dataset(opt.data)\n                    self.wandb_artifact_data_dict = self.wandb_artifact_data_dict or self.data_dict\n\n                    # write data_dict to config. useful for resuming from artifacts. Do this only when not resuming.\n                    self.wandb_run.config.update({'data_dict': self.wandb_artifact_data_dict}, allow_val_change=True)\n                self.setup_training(opt)\n\n            if self.job_type == 'Dataset Creation':\n                self.wandb_run.config.update({\"upload_dataset\": True})\n                self.data_dict = self.check_and_upload_dataset(opt)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def check_and_upload_dataset(self, opt):\n        \"\"\"\n        Check if the dataset format is compatible and upload it as W&B artifact\n\n        arguments:\n        opt (namespace)-- Commandline arguments for current run\n\n        returns:\n        Updated dataset info dictionary where local dataset paths are replaced by WAND_ARFACT_PREFIX links.\n        \"\"\"\n        assert wandb, 'Install wandb to upload dataset'\n        config_path = self.log_dataset_artifact(opt.data, opt.single_cls,\n                                                'YOLOv5' if opt.project == 'runs/train' else Path(opt.project).stem)\n        with open(config_path, errors='ignore') as f:\n            wandb_data_dict = yaml.safe_load(f)\n        return wandb_data_dict", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def setup_training(self, opt):\n        \"\"\"\n        Setup the necessary processes for training YOLO models:\n          - Attempt to download model checkpoint and dataset artifacts if opt.resume stats with WANDB_ARTIFACT_PREFIX\n          - Update data_dict, to contain info of previous run if resumed and the paths of dataset artifact if downloaded\n          - Setup log_dict, initialize bbox_interval\n\n        arguments:\n        opt (namespace) -- commandline arguments for this run\n\n        \"\"\"\n        self.log_dict, self.current_epoch = {}, 0\n        self.bbox_interval = opt.bbox_interval\n        if isinstance(opt.resume, str):\n            modeldir, _ = self.download_model_artifact(opt)\n            if modeldir:\n                self.weights = Path(modeldir) / \"last.pt\"\n                config = self.wandb_run.config\n                opt.weights, opt.save_period, opt.batch_size, opt.bbox_interval, opt.epochs, opt.hyp, opt.imgsz = str(\n                    self.weights), config.save_period, config.batch_size, config.bbox_interval, config.epochs,\\\n                    config.hyp, config.imgsz\n        data_dict = self.data_dict\n        if self.val_artifact is None:  # If --upload_dataset is set, use the existing artifact, don't download\n            self.train_artifact_path, self.train_artifact = self.download_dataset_artifact(\n                data_dict.get('train'), opt.artifact_alias)\n            self.val_artifact_path, self.val_artifact = self.download_dataset_artifact(\n                data_dict.get('val'), opt.artifact_alias)\n\n        if self.train_artifact_path is not None:\n            train_path = Path(self.train_artifact_path) / 'data/images/'\n            data_dict['train'] = str(train_path)\n        if self.val_artifact_path is not None:\n            val_path = Path(self.val_artifact_path) / 'data/images/'\n            data_dict['val'] = str(val_path)\n\n        if self.val_artifact is not None:\n            self.result_artifact = wandb.Artifact(\"run_\" + wandb.run.id + \"_progress\", \"evaluation\")\n            columns = [\"epoch\", \"id\", \"ground truth\", \"prediction\"]\n            columns.extend(self.data_dict['names'])\n            self.result_table = wandb.Table(columns)\n            self.val_table = self.val_artifact.get(\"val\")\n            if self.val_table_path_map is None:\n                self.map_val_table_path()\n        if opt.bbox_interval == -1:\n            self.bbox_interval = opt.bbox_interval = (opt.epochs // 10) if opt.epochs > 10 else 1\n            if opt.evolve or opt.noplots:\n                self.bbox_interval = opt.bbox_interval = opt.epochs + 1  # disable bbox_interval\n        train_from_artifact = self.train_artifact_path is not None and self.val_artifact_path is not None\n        # Update the the data_dict to point to local artifacts dir\n        if train_from_artifact:\n            self.data_dict = data_dict", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def download_dataset_artifact(self, path, alias):\n        \"\"\"\n        download the model checkpoint artifact if the path starts with WANDB_ARTIFACT_PREFIX\n\n        arguments:\n        path -- path of the dataset to be used for training\n        alias (str)-- alias of the artifact to be download/used for training\n\n        returns:\n        (str, wandb.Artifact) -- path of the downladed dataset and it's corresponding artifact object if dataset\n        is found otherwise returns (None, None)\n        \"\"\"\n        if isinstance(path, str) and path.startswith(WANDB_ARTIFACT_PREFIX):\n            artifact_path = Path(remove_prefix(path, WANDB_ARTIFACT_PREFIX) + \":\" + alias)\n            dataset_artifact = wandb.use_artifact(artifact_path.as_posix().replace(\"\\\\\", \"/\"))\n            assert dataset_artifact is not None, \"'Error: W&B dataset artifact doesn\\'t exist'\"\n            datadir = dataset_artifact.download()\n            return datadir, dataset_artifact\n        return None, None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def download_model_artifact(self, opt):\n        \"\"\"\n        download the model checkpoint artifact if the resume path starts with WANDB_ARTIFACT_PREFIX\n\n        arguments:\n        opt (namespace) -- Commandline arguments for this run\n        \"\"\"\n        if opt.resume.startswith(WANDB_ARTIFACT_PREFIX):\n            model_artifact = wandb.use_artifact(remove_prefix(opt.resume, WANDB_ARTIFACT_PREFIX) + \":latest\")\n            assert model_artifact is not None, 'Error: W&B model artifact doesn\\'t exist'\n            modeldir = model_artifact.download()\n            # epochs_trained = model_artifact.metadata.get('epochs_trained')\n            total_epochs = model_artifact.metadata.get('total_epochs')\n            is_finished = total_epochs is None\n            assert not is_finished, 'training is finished, can only resume incomplete runs.'\n            return modeldir, model_artifact\n        return None, None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_model(self, path, opt, epoch, fitness_score, best_model=False):\n        \"\"\"\n        Log the model checkpoint as W&B artifact\n\n        arguments:\n        path (Path)   -- Path of directory containing the checkpoints\n        opt (namespace) -- Command line arguments for this run\n        epoch (int)  -- Current epoch number\n        fitness_score (float) -- fitness score for current epoch\n        best_model (boolean) -- Boolean representing if the current checkpoint is the best yet.\n        \"\"\"\n        model_artifact = wandb.Artifact('run_' + wandb.run.id + '_model',\n                                        type='model',\n                                        metadata={\n                                            'original_url': str(path),\n                                            'epochs_trained': epoch + 1,\n                                            'save period': opt.save_period,\n                                            'project': opt.project,\n                                            'total_epochs': opt.epochs,\n                                            'fitness_score': fitness_score})\n        model_artifact.add_file(str(path / 'last.pt'), name='last.pt')\n        wandb.log_artifact(model_artifact,\n                           aliases=['latest', 'last', 'epoch ' + str(self.current_epoch), 'best' if best_model else ''])\n        LOGGER.info(f\"Saving model artifact on epoch {epoch + 1}\")", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_dataset_artifact(self, data_file, single_cls, project, overwrite_config=False):\n        \"\"\"\n        Log the dataset as W&B artifact and return the new data file with W&B links\n\n        arguments:\n        data_file (str) -- the .yaml file with information about the dataset like - path, classes etc.\n        single_class (boolean)  -- train multi-class data as single-class\n        project (str) -- project name. Used to construct the artifact path\n        overwrite_config (boolean) -- overwrites the data.yaml file if set to true otherwise creates a new\n        file with _wandb postfix. Eg -> data_wandb.yaml\n\n        returns:\n        the new .yaml file with artifact links. it can be used to start training directly from artifacts\n        \"\"\"\n        upload_dataset = self.wandb_run.config.upload_dataset\n        log_val_only = isinstance(upload_dataset, str) and upload_dataset == 'val'\n        self.data_dict = check_dataset(data_file)  # parse and check\n        data = dict(self.data_dict)\n        nc, names = (1, ['item']) if single_cls else (int(data['nc']), data['names'])\n        names = {k: v for k, v in enumerate(names)}  # to index dictionary\n\n        # log train set\n        if not log_val_only:\n            self.train_artifact = self.create_dataset_table(LoadImagesAndLabels(data['train'], rect=True, batch_size=1),\n                                                            names,\n                                                            name='train') if data.get('train') else None\n            if data.get('train'):\n                data['train'] = WANDB_ARTIFACT_PREFIX + str(Path(project) / 'train')\n\n        self.val_artifact = self.create_dataset_table(\n            LoadImagesAndLabels(data['val'], rect=True, batch_size=1), names, name='val') if data.get('val') else None\n        if data.get('val'):\n            data['val'] = WANDB_ARTIFACT_PREFIX + str(Path(project) / 'val')\n\n        path = Path(data_file)\n        # create a _wandb.yaml file with artifacts links if both train and test set are logged\n        if not log_val_only:\n            path = (path.stem if overwrite_config else path.stem + '_wandb') + '.yaml'  # updated data.yaml path\n            path = ROOT / 'data' / path\n            data.pop('download', None)\n            data.pop('path', None)\n            with open(path, 'w') as f:\n                yaml.safe_dump(data, f)\n                LOGGER.info(f\"Created dataset config file {path}\")\n\n        if self.job_type == 'Training':  # builds correct artifact pipeline graph\n            if not log_val_only:\n                self.wandb_run.log_artifact(\n                    self.train_artifact)  # calling use_artifact downloads the dataset. NOT NEEDED!\n            self.wandb_run.use_artifact(self.val_artifact)\n            self.val_artifact.wait()\n            self.val_table = self.val_artifact.get('val')\n            self.map_val_table_path()\n        else:\n            self.wandb_run.log_artifact(self.train_artifact)\n            self.wandb_run.log_artifact(self.val_artifact)\n        return path", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def map_val_table_path(self):\n        \"\"\"\n        Map the validation dataset Table like name of file -> it's id in the W&B Table.\n        Useful for - referencing artifacts for evaluation.\n        \"\"\"\n        self.val_table_path_map = {}\n        LOGGER.info(\"Mapping dataset\")\n        for i, data in enumerate(tqdm(self.val_table.data)):\n            self.val_table_path_map[data[3]] = data[0]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def create_dataset_table(self, dataset: LoadImagesAndLabels, class_to_id: Dict[int, str], name: str = 'dataset'):\n        \"\"\"\n        Create and return W&B artifact containing W&B Table of the dataset.\n\n        arguments:\n        dataset -- instance of LoadImagesAndLabels class used to iterate over the data to build Table\n        class_to_id -- hash map that maps class ids to labels\n        name -- name of the artifact\n\n        returns:\n        dataset artifact to be logged or used\n        \"\"\"\n        # TODO: Explore multiprocessing to slpit this loop parallely| This is essential for speeding up the the logging\n        artifact = wandb.Artifact(name=name, type=\"dataset\")\n        img_files = tqdm([dataset.path]) if isinstance(dataset.path, str) and Path(dataset.path).is_dir() else None\n        img_files = tqdm(dataset.im_files) if not img_files else img_files\n        for img_file in img_files:\n            if Path(img_file).is_dir():\n                artifact.add_dir(img_file, name='data/images')\n                labels_path = 'labels'.join(dataset.path.rsplit('images', 1))\n                artifact.add_dir(labels_path, name='data/labels')\n            else:\n                artifact.add_file(img_file, name='data/images/' + Path(img_file).name)\n                label_file = Path(img2label_paths([img_file])[0])\n                artifact.add_file(str(label_file), name='data/labels/' +\n                                  label_file.name) if label_file.exists() else None\n        table = wandb.Table(columns=[\"id\", \"train_image\", \"Classes\", \"name\"])\n        class_set = wandb.Classes([{'id': id, 'name': name} for id, name in class_to_id.items()])\n        for si, (img, labels, paths, shapes) in enumerate(tqdm(dataset)):\n            box_data, img_classes = [], {}\n            for cls, *xywh in labels[:, 1:].tolist():\n                cls = int(cls)\n                box_data.append({\n                    \"position\": {\n                        \"middle\": [xywh[0], xywh[1]],\n                        \"width\": xywh[2],\n                        \"height\": xywh[3]},\n                    \"class_id\": cls,\n                    \"box_caption\": \"%s\" % (class_to_id[cls])})\n                img_classes[cls] = class_to_id[cls]\n            boxes = {\"ground_truth\": {\"box_data\": box_data, \"class_labels\": class_to_id}}  # inference-space\n            table.add_data(si, wandb.Image(paths, classes=class_set, boxes=boxes), list(img_classes.values()),\n                           Path(paths).name)\n        artifact.add(table, name)\n        return artifact", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log_training_progress(self, predn, path, names):\n        \"\"\"\n        Build evaluation Table. Uses reference from validation dataset table.\n\n        arguments:\n        predn (list): list of predictions in the native space in the format - [xmin, ymin, xmax, ymax, confidence, class]\n        path (str): local path of the current evaluation image\n        names (dict(int, str)): hash map that maps class ids to labels\n        \"\"\"\n        class_set = wandb.Classes([{'id': id, 'name': name} for id, name in names.items()])\n        box_data = []\n        avg_conf_per_class = [0] * len(self.data_dict['names'])\n        pred_class_count = {}\n        for *xyxy, conf, cls in predn.tolist():\n            if conf >= 0.25:\n                cls = int(cls)\n                box_data.append({\n                    \"position\": {\n                        \"minX\": xyxy[0],\n                        \"minY\": xyxy[1],\n                        \"maxX\": xyxy[2],\n                        \"maxY\": xyxy[3]},\n                    \"class_id\": cls,\n                    \"box_caption\": f\"{names[cls]} {conf:.3f}\",\n                    \"scores\": {\n                        \"class_score\": conf},\n                    \"domain\": \"pixel\"})\n                avg_conf_per_class[cls] += conf\n\n                if cls in pred_class_count:\n                    pred_class_count[cls] += 1\n                else:\n                    pred_class_count[cls] = 1\n\n        for pred_class in pred_class_count.keys():\n            avg_conf_per_class[pred_class] = avg_conf_per_class[pred_class] / pred_class_count[pred_class]\n\n        boxes = {\"predictions\": {\"box_data\": box_data, \"class_labels\": names}}  # inference-space\n        id = self.val_table_path_map[Path(path).name]\n        self.result_table.add_data(self.current_epoch, id, self.val_table.data[id][1],\n                                   wandb.Image(self.val_table.data[id][1], boxes=boxes, classes=class_set),\n                                   *avg_conf_per_class)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def val_one_image(self, pred, predn, path, names, im):\n        \"\"\"\n        Log validation data for one image. updates the result Table if validation dataset is uploaded and log bbox media panel\n\n        arguments:\n        pred (list): list of scaled predictions in the format - [xmin, ymin, xmax, ymax, confidence, class]\n        predn (list): list of predictions in the native space - [xmin, ymin, xmax, ymax, confidence, class]\n        path (str): local path of the current evaluation image\n        \"\"\"\n        if self.val_table and self.result_table:  # Log Table if Val dataset is uploaded as artifact\n            self.log_training_progress(predn, path, names)\n\n        if len(self.bbox_media_panel_images) < self.max_imgs_to_log and self.current_epoch > 0:\n            if self.current_epoch % self.bbox_interval == 0:\n                box_data = [{\n                    \"position\": {\n                        \"minX\": xyxy[0],\n                        \"minY\": xyxy[1],\n                        \"maxX\": xyxy[2],\n                        \"maxY\": xyxy[3]},\n                    \"class_id\": int(cls),\n                    \"box_caption\": f\"{names[int(cls)]} {conf:.3f}\",\n                    \"scores\": {\n                        \"class_score\": conf},\n                    \"domain\": \"pixel\"} for *xyxy, conf, cls in pred.tolist()]\n                boxes = {\"predictions\": {\"box_data\": box_data, \"class_labels\": names}}  # inference-space\n                self.bbox_media_panel_images.append(wandb.Image(im, boxes=boxes, caption=path.name))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def log(self, log_dict):\n        \"\"\"\n        save the metrics to the logging dictionary\n\n        arguments:\n        log_dict (Dict) -- metrics/media to be logged in current step\n        \"\"\"\n        if self.wandb_run:\n            for key, value in log_dict.items():\n                self.log_dict[key] = value", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def end_epoch(self, best_result=False):\n        \"\"\"\n        commit the log_dict, model artifacts and Tables to W&B and flush the log_dict.\n\n        arguments:\n        best_result (boolean): Boolean representing if the result of this evaluation is best or not\n        \"\"\"\n        if self.wandb_run:\n            with all_logging_disabled():\n                if self.bbox_media_panel_images:\n                    self.log_dict[\"BoundingBoxDebugger\"] = self.bbox_media_panel_images\n                try:\n                    wandb.log(self.log_dict)\n                except BaseException as e:\n                    LOGGER.info(\n                        f\"An error occurred in wandb logger. The training will proceed without interruption. More info\\n{e}\"\n                    )\n                    self.wandb_run.finish()\n                    self.wandb_run = None\n\n                self.log_dict = {}\n                self.bbox_media_panel_images = []\n            if self.result_artifact:\n                self.result_artifact.add(self.result_table, 'result')\n                wandb.log_artifact(self.result_artifact,\n                                   aliases=[\n                                       'latest', 'last', 'epoch ' + str(self.current_epoch),\n                                       ('best' if best_result else '')])\n\n                wandb.log({\"evaluation\": self.result_table})\n                columns = [\"epoch\", \"id\", \"ground truth\", \"prediction\"]\n                columns.extend(self.data_dict['names'])\n                self.result_table = wandb.Table(columns)\n                self.result_artifact = wandb.Artifact(\"run_\" + wandb.run.id + \"_progress\", \"evaluation\")", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def finish_run(self):\n        \"\"\"\n        Log metrics if any and finish the current W&B run\n        \"\"\"\n        if self.wandb_run:\n            if self.log_dict:\n                with all_logging_disabled():\n                    wandb.log(self.log_dict)\n            wandb.run.finish()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, url: str):\n        \"\"\"\n        Keyword arguments:\n        url: Fully qualified address of the Triton server - for e.g. grpc://localhost:8000\n        \"\"\"\n\n        parsed_url = urlparse(url)\n        if parsed_url.scheme == \"grpc\":\n            from tritonclient.grpc import InferenceServerClient, InferInput\n\n            self.client = InferenceServerClient(parsed_url.netloc)  # Triton GRPC client\n            model_repository = self.client.get_model_repository_index()\n            self.model_name = model_repository.models[0].name\n            self.metadata = self.client.get_model_metadata(self.model_name, as_json=True)\n\n            def create_input_placeholders() -> typing.List[InferInput]:\n                return [\n                    InferInput(i['name'], [int(s) for s in i[\"shape\"]], i['datatype']) for i in self.metadata['inputs']]\n\n        else:\n            from tritonclient.http import InferenceServerClient, InferInput\n\n            self.client = InferenceServerClient(parsed_url.netloc)  # Triton HTTP client\n            model_repository = self.client.get_model_repository_index()\n            self.model_name = model_repository[0]['name']\n            self.metadata = self.client.get_model_metadata(self.model_name)\n\n            def create_input_placeholders() -> typing.List[InferInput]:\n                return [\n                    InferInput(i['name'], [int(s) for s in i[\"shape\"]], i['datatype']) for i in self.metadata['inputs']]\n\n        self._create_input_placeholders_fn = create_input_placeholders", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def runtime(self):\n        \"\"\"Returns the model runtime\"\"\"\n        return self.metadata.get(\"backend\", self.metadata.get(\"platform\"))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __call__(self, *args, **kwargs) -> typing.Union[torch.Tensor, typing.Tuple[torch.Tensor, ...]]:\n        \"\"\" Invokes the model. Parameters can be provided via args or kwargs.\n        args, if provided, are assumed to match the order of inputs of the model.\n        kwargs are matched with the model input names.\n        \"\"\"\n        inputs = self._create_inputs(*args, **kwargs)\n        response = self.client.infer(model_name=self.model_name, inputs=inputs)\n        result = []\n        for output in self.metadata['outputs']:\n            tensor = torch.as_tensor(response.as_numpy(output['name']))\n            result.append(tensor)\n        return result[0] if len(result) == 1 else result", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _create_inputs(self, *args, **kwargs):\n        args_len, kwargs_len = len(args), len(kwargs)\n        if not args_len and not kwargs_len:\n            raise RuntimeError(\"No inputs provided.\")\n        if args_len and kwargs_len:\n            raise RuntimeError(\"Cannot specify args and kwargs at the same time\")\n\n        placeholders = self._create_input_placeholders_fn()\n        if args_len:\n            if args_len != len(placeholders):\n                raise RuntimeError(f\"Expected {len(placeholders)} inputs, got {args_len}.\")\n            for input, value in zip(placeholders, args):\n                input.set_data_from_numpy(value.cpu().numpy())\n        else:\n            for input in placeholders:\n                value = kwargs[input.name]\n                input.set_data_from_numpy(value.cpu().numpy())\n        return placeholders", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "            def create_input_placeholders() -> typing.List[InferInput]:\n                return [\n                    InferInput(i['name'], [int(s) for s in i[\"shape\"]], i['datatype']) for i in self.metadata['inputs']]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "            def create_input_placeholders() -> typing.List[InferInput]:\n                return [\n                    InferInput(i['name'], [int(s) for s in i[\"shape\"]], i['datatype']) for i in self.metadata['inputs']]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(x):\n        return x * torch.sigmoid(x)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(x):\n        # return x * F.hardsigmoid(x)  # for TorchScript and CoreML\n        return x * F.hardtanh(x + 3, 0.0, 6.0) / 6.0  # for TorchScript, CoreML and ONNX", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(x):\n        return x * F.softplus(x).tanh()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        return self.F.apply(x)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, k=3):  # ch_in, kernel\n        super().__init__()\n        self.conv = nn.Conv2d(c1, c1, k, 1, 1, groups=c1, bias=False)\n        self.bn = nn.BatchNorm2d(c1)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        return torch.max(x, self.bn(self.conv(x)))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1):\n        super().__init__()\n        self.p1 = nn.Parameter(torch.randn(1, c1, 1, 1))\n        self.p2 = nn.Parameter(torch.randn(1, c1, 1, 1))\n        self.beta = nn.Parameter(torch.ones(1, c1, 1, 1))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        dpx = (self.p1 - self.p2) * x\n        return dpx * torch.sigmoid(self.beta * dpx) + self.p2 * x", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, k=1, s=1, r=16):  # ch_in, kernel, stride, r\n        super().__init__()\n        c2 = max(r, c1 // r)\n        self.p1 = nn.Parameter(torch.randn(1, c1, 1, 1))\n        self.p2 = nn.Parameter(torch.randn(1, c1, 1, 1))\n        self.fc1 = nn.Conv2d(c1, c2, k, s, bias=True)\n        self.fc2 = nn.Conv2d(c2, c1, k, s, bias=True)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        y = x.mean(dim=2, keepdims=True).mean(dim=3, keepdims=True)\n        # batch-size 1 bug/instabilities https://github.com/ultralytics/yolov5/issues/2891\n        # beta = torch.sigmoid(self.bn2(self.fc2(self.bn1(self.fc1(y)))))  # bug/unstable\n        beta = torch.sigmoid(self.fc2(self.fc1(y)))  # bug patch BN layers removed\n        dpx = (self.p1 - self.p2) * x\n        return dpx * torch.sigmoid(beta * dpx) + self.p2 * x", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "        def forward(ctx, x):\n            ctx.save_for_backward(x)\n            return x.mul(torch.tanh(F.softplus(x)))  # x * tanh(ln(1 + exp(x)))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "        def backward(ctx, grad_output):\n            x = ctx.saved_tensors[0]\n            sx = torch.sigmoid(x)\n            fx = F.softplus(x).tanh()\n            return grad_output * (fx + x * sx * (1 - fx * fx))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_train_batch_size(model, imgsz=640, amp=True):\n    # Check YOLOv5 training batch size\n    with torch.cuda.amp.autocast(amp):\n        return autobatch(deepcopy(model).train(), imgsz)  # compute optimal batch size", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def autobatch(model, imgsz=640, fraction=0.8, batch_size=16):\n    # Automatically estimate best YOLOv5 batch size to use `fraction` of available CUDA memory\n    # Usage:\n    #     import torch\n    #     from utils.autobatch import autobatch\n    #     model = torch.hub.load('ultralytics/yolov5', 'yolov5s', autoshape=False)\n    #     print(autobatch(model))\n\n    # Check device\n    prefix = colorstr('AutoBatch: ')\n    LOGGER.info(f'{prefix}Computing optimal batch size for --imgsz {imgsz}')\n    device = next(model.parameters()).device  # get model device\n    if device.type == 'cpu':\n        LOGGER.info(f'{prefix}CUDA not detected, using default CPU batch-size {batch_size}')\n        return batch_size\n    if torch.backends.cudnn.benchmark:\n        LOGGER.info(f'{prefix} \u26a0\ufe0f Requires torch.backends.cudnn.benchmark=False, using default batch-size {batch_size}')\n        return batch_size\n\n    # Inspect CUDA memory\n    gb = 1 << 30  # bytes to GiB (1024 ** 3)\n    d = str(device).upper()  # 'CUDA:0'\n    properties = torch.cuda.get_device_properties(device)  # device properties\n    t = properties.total_memory / gb  # GiB total\n    r = torch.cuda.memory_reserved(device) / gb  # GiB reserved\n    a = torch.cuda.memory_allocated(device) / gb  # GiB allocated\n    f = t - (r + a)  # GiB free\n    LOGGER.info(f'{prefix}{d} ({properties.name}) {t:.2f}G total, {r:.2f}G reserved, {a:.2f}G allocated, {f:.2f}G free')\n\n    # Profile batch sizes\n    batch_sizes = [1, 2, 4, 8, 16]\n    try:\n        img = [torch.empty(b, 3, imgsz, imgsz) for b in batch_sizes]\n        results = profile(img, model, n=3, device=device)\n    except Exception as e:\n        LOGGER.warning(f'{prefix}{e}')\n\n    # Fit a solution\n    y = [x[2] for x in results if x]  # memory [2]\n    p = np.polyfit(batch_sizes[:len(y)], y, deg=1)  # first degree polynomial fit\n    b = int((f * fraction - p[1]) / p[0])  # y intercept (optimal batch size)\n    if None in results:  # some sizes failed\n        i = results.index(None)  # first fail index\n        if b >= batch_sizes[i]:  # y intercept above failure point\n            b = batch_sizes[max(i - 1, 0)]  # select prior safe point\n    if b < 1 or b > 1024:  # b outside of safe range\n        b = batch_size\n        LOGGER.warning(f'{prefix}WARNING \u26a0\ufe0f CUDA anomaly detected, recommend restart environment and retry command.')\n\n    fraction = (np.polyval(p, b) + r + a) / t  # actual fraction predicted\n    LOGGER.info(f'{prefix}Using batch-size {b} for {d} {t * fraction:.2f}G/{t:.2f}G ({fraction * 100:.0f}%) \u2705')\n    return b", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def get_hash(paths):\n    # Returns a single hash value of a list of paths (files or dirs)\n    size = sum(os.path.getsize(p) for p in paths if os.path.exists(p))  # sizes\n    h = hashlib.md5(str(size).encode())  # hash sizes\n    h.update(''.join(paths).encode())  # hash paths\n    return h.hexdigest()  # return hash", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def exif_size(img):\n    # Returns exif-corrected PIL size\n    s = img.size  # (width, height)\n    with contextlib.suppress(Exception):\n        rotation = dict(img._getexif().items())[orientation]\n        if rotation in [6, 8]:  # rotation 270 or 90\n            s = (s[1], s[0])\n    return s", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def exif_transpose(image):\n    \"\"\"\n    Transpose a PIL image accordingly if it has an EXIF Orientation tag.\n    Inplace version of https://github.com/python-pillow/Pillow/blob/master/src/PIL/ImageOps.py exif_transpose()\n\n    :param image: The image to transpose.\n    :return: An image.\n    \"\"\"\n    exif = image.getexif()\n    orientation = exif.get(0x0112, 1)  # default 1\n    if orientation > 1:\n        method = {\n            2: Image.FLIP_LEFT_RIGHT,\n            3: Image.ROTATE_180,\n            4: Image.FLIP_TOP_BOTTOM,\n            5: Image.TRANSPOSE,\n            6: Image.ROTATE_270,\n            7: Image.TRANSVERSE,\n            8: Image.ROTATE_90}.get(orientation)\n        if method is not None:\n            image = image.transpose(method)\n            del exif[0x0112]\n            image.info[\"exif\"] = exif.tobytes()\n    return image", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def seed_worker(worker_id):\n    # Set dataloader worker seed https://pytorch.org/docs/stable/notes/randomness.html#dataloader\n    worker_seed = torch.initial_seed() % 2 ** 32\n    np.random.seed(worker_seed)\n    random.seed(worker_seed)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def create_dataloader(path,\n                      imgsz,\n                      batch_size,\n                      stride,\n                      single_cls=False,\n                      hyp=None,\n                      augment=False,\n                      cache=False,\n                      pad=0.0,\n                      rect=False,\n                      rank=-1,\n                      workers=8,\n                      image_weights=False,\n                      quad=False,\n                      prefix='',\n                      shuffle=False):\n    if rect and shuffle:\n        LOGGER.warning('WARNING \u26a0\ufe0f --rect is incompatible with DataLoader shuffle, setting shuffle=False')\n        shuffle = False\n    with torch_distributed_zero_first(rank):  # init dataset *.cache only once if DDP\n        dataset = LoadImagesAndLabels(\n            path,\n            imgsz,\n            batch_size,\n            augment=augment,  # augmentation\n            hyp=hyp,  # hyperparameters\n            rect=rect,  # rectangular batches\n            cache_images=cache,\n            single_cls=single_cls,\n            stride=int(stride),\n            pad=pad,\n            image_weights=image_weights,\n            prefix=prefix)\n\n    batch_size = min(batch_size, len(dataset))\n    nd = torch.cuda.device_count()  # number of CUDA devices\n    nw = min([os.cpu_count() // max(nd, 1), batch_size if batch_size > 1 else 0, workers])  # number of workers\n    sampler = None if rank == -1 else distributed.DistributedSampler(dataset, shuffle=shuffle)\n    loader = DataLoader if image_weights else InfiniteDataLoader  # only DataLoader allows for attribute updates\n    generator = torch.Generator()\n    generator.manual_seed(6148914691236517205 + RANK)\n    return loader(dataset,\n                  batch_size=batch_size,\n                  shuffle=shuffle and sampler is None,\n                  num_workers=nw,\n                  sampler=sampler,\n                  pin_memory=PIN_MEMORY,\n                  collate_fn=LoadImagesAndLabels.collate_fn4 if quad else LoadImagesAndLabels.collate_fn,\n                  worker_init_fn=seed_worker,\n                  generator=generator), dataset", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def img2label_paths(img_paths):\n    # Define label paths as a function of image paths\n    sa, sb = f'{os.sep}images{os.sep}', f'{os.sep}labels{os.sep}'  # /images/, /labels/ substrings\n    return [sb.join(x.rsplit(sa, 1)).rsplit('.', 1)[0] + '.txt' for x in img_paths]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def flatten_recursive(path=DATASETS_DIR / 'coco128'):\n    # Flatten a recursive directory by bringing all files to top level\n    new_path = Path(f'{str(path)}_flat')\n    if os.path.exists(new_path):\n        shutil.rmtree(new_path)  # delete output folder\n    os.makedirs(new_path)  # make new output folder\n    for file in tqdm(glob.glob(f'{str(Path(path))}/**/*.*', recursive=True)):\n        shutil.copyfile(file, new_path / Path(file).name)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def extract_boxes(path=DATASETS_DIR / 'coco128'):  # from utils.dataloaders import *; extract_boxes()\n    # Convert detection dataset into classification dataset, with one directory per class\n    path = Path(path)  # images dir\n    shutil.rmtree(path / 'classification') if (path / 'classification').is_dir() else None  # remove existing\n    files = list(path.rglob('*.*'))\n    n = len(files)  # number of files\n    for im_file in tqdm(files, total=n):\n        if im_file.suffix[1:] in IMG_FORMATS:\n            # image\n            im = cv2.imread(str(im_file))[..., ::-1]  # BGR to RGB\n            h, w = im.shape[:2]\n\n            # labels\n            lb_file = Path(img2label_paths([str(im_file)])[0])\n            if Path(lb_file).exists():\n                with open(lb_file) as f:\n                    lb = np.array([x.split() for x in f.read().strip().splitlines()], dtype=np.float32)  # labels\n\n                for j, x in enumerate(lb):\n                    c = int(x[0])  # class\n                    f = (path / 'classifier') / f'{c}' / f'{path.stem}_{im_file.stem}_{j}.jpg'  # new filename\n                    if not f.parent.is_dir():\n                        f.parent.mkdir(parents=True)\n\n                    b = x[1:] * [w, h, w, h]  # box\n                    # b[2:] = b[2:].max()  # rectangle to square\n                    b[2:] = b[2:] * 1.2 + 3  # pad\n                    b = xywh2xyxy(b.reshape(-1, 4)).ravel().astype(int)\n\n                    b[[0, 2]] = np.clip(b[[0, 2]], 0, w)  # clip boxes outside of image\n                    b[[1, 3]] = np.clip(b[[1, 3]], 0, h)\n                    assert cv2.imwrite(str(f), im[b[1]:b[3], b[0]:b[2]]), f'box failure in {f}'", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def autosplit(path=DATASETS_DIR / 'coco128/images', weights=(0.9, 0.1, 0.0), annotated_only=False):\n    \"\"\" Autosplit a dataset into train/val/test splits and save path/autosplit_*.txt files\n    Usage: from utils.dataloaders import *; autosplit()\n    Arguments\n        path:            Path to images directory\n        weights:         Train, val, test weights (list, tuple)\n        annotated_only:  Only use images with an annotated txt file\n    \"\"\"\n    path = Path(path)  # images dir\n    files = sorted(x for x in path.rglob('*.*') if x.suffix[1:].lower() in IMG_FORMATS)  # image files only\n    n = len(files)  # number of files\n    random.seed(0)  # for reproducibility\n    indices = random.choices([0, 1, 2], weights=weights, k=n)  # assign each image to a split\n\n    txt = ['autosplit_train.txt', 'autosplit_val.txt', 'autosplit_test.txt']  # 3 txt files\n    for x in txt:\n        if (path.parent / x).exists():\n            (path.parent / x).unlink()  # remove existing\n\n    print(f'Autosplitting images from {path}' + ', using *.txt labeled images only' * annotated_only)\n    for i, img in tqdm(zip(indices, files), total=n):\n        if not annotated_only or Path(img2label_paths([str(img)])[0]).exists():  # check label\n            with open(path.parent / txt[i], 'a') as f:\n                f.write(f'./{img.relative_to(path.parent).as_posix()}' + '\\n')  # add image to txt file", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def verify_image_label(args):\n    # Verify one image-label pair\n    im_file, lb_file, prefix = args\n    nm, nf, ne, nc, msg, segments = 0, 0, 0, 0, '', []  # number (missing, found, empty, corrupt), message, segments\n    try:\n        # verify images\n        im = Image.open(im_file)\n        im.verify()  # PIL verify\n        shape = exif_size(im)  # image size\n        assert (shape[0] > 9) & (shape[1] > 9), f'image size {shape} <10 pixels'\n        assert im.format.lower() in IMG_FORMATS, f'invalid image format {im.format}'\n        if im.format.lower() in ('jpg', 'jpeg'):\n            with open(im_file, 'rb') as f:\n                f.seek(-2, 2)\n                if f.read() != b'\\xff\\xd9':  # corrupt JPEG\n                    ImageOps.exif_transpose(Image.open(im_file)).save(im_file, 'JPEG', subsampling=0, quality=100)\n                    msg = f'{prefix}WARNING \u26a0\ufe0f {im_file}: corrupt JPEG restored and saved'\n\n        # verify labels\n        if os.path.isfile(lb_file):\n            nf = 1  # label found\n            with open(lb_file) as f:\n                lb = [x.split() for x in f.read().strip().splitlines() if len(x)]\n                if any(len(x) > 6 for x in lb):  # is segment\n                    classes = np.array([x[0] for x in lb], dtype=np.float32)\n                    segments = [np.array(x[1:], dtype=np.float32).reshape(-1, 2) for x in lb]  # (cls, xy1...)\n                    lb = np.concatenate((classes.reshape(-1, 1), segments2boxes(segments)), 1)  # (cls, xywh)\n                lb = np.array(lb, dtype=np.float32)\n            nl = len(lb)\n            if nl:\n                assert lb.shape[1] == 5, f'labels require 5 columns, {lb.shape[1]} columns detected'\n                assert (lb >= 0).all(), f'negative label values {lb[lb < 0]}'\n                assert (lb[:, 1:] <= 1).all(), f'non-normalized or out of bounds coordinates {lb[:, 1:][lb[:, 1:] > 1]}'\n                _, i = np.unique(lb, axis=0, return_index=True)\n                if len(i) < nl:  # duplicate row check\n                    lb = lb[i]  # remove duplicates\n                    if segments:\n                        segments = [segments[x] for x in i]\n                    msg = f'{prefix}WARNING \u26a0\ufe0f {im_file}: {nl - len(i)} duplicate labels removed'\n            else:\n                ne = 1  # label empty\n                lb = np.zeros((0, 5), dtype=np.float32)\n        else:\n            nm = 1  # label missing\n            lb = np.zeros((0, 5), dtype=np.float32)\n        return im_file, lb, shape, segments, nm, nf, ne, nc, msg\n    except Exception as e:\n        nc = 1\n        msg = f'{prefix}WARNING \u26a0\ufe0f {im_file}: ignoring corrupt image/label: {e}'\n        return [None, None, None, None, nm, nf, ne, nc, msg]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def create_classification_dataloader(path,\n                                     imgsz=224,\n                                     batch_size=16,\n                                     augment=True,\n                                     cache=False,\n                                     rank=-1,\n                                     workers=8,\n                                     shuffle=True):\n    # Returns Dataloader object to be used with YOLOv5 Classifier\n    with torch_distributed_zero_first(rank):  # init dataset *.cache only once if DDP\n        dataset = ClassificationDataset(root=path, imgsz=imgsz, augment=augment, cache=cache)\n    batch_size = min(batch_size, len(dataset))\n    nd = torch.cuda.device_count()\n    nw = min([os.cpu_count() // max(nd, 1), batch_size if batch_size > 1 else 0, workers])\n    sampler = None if rank == -1 else distributed.DistributedSampler(dataset, shuffle=shuffle)\n    generator = torch.Generator()\n    generator.manual_seed(6148914691236517205 + RANK)\n    return InfiniteDataLoader(dataset,\n                              batch_size=batch_size,\n                              shuffle=shuffle and sampler is None,\n                              num_workers=nw,\n                              sampler=sampler,\n                              pin_memory=PIN_MEMORY,\n                              worker_init_fn=seed_worker,\n                              generator=generator)  # or DataLoader(persistent_workers=True)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        object.__setattr__(self, 'batch_sampler', _RepeatSampler(self.batch_sampler))\n        self.iterator = super().__iter__()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __len__(self):\n        return len(self.batch_sampler.sampler)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __iter__(self):\n        for _ in range(len(self)):\n            yield next(self.iterator)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, sampler):\n        self.sampler = sampler", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __iter__(self):\n        while True:\n            yield from iter(self.sampler)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, source, img_size=640, stride=32, auto=True, transforms=None):\n        # source = [screen_number left top width height] (pixels)\n        check_requirements('mss')\n        import mss\n\n        source, *params = source.split()\n        self.screen, left, top, width, height = 0, None, None, None, None  # default to full screen 0\n        if len(params) == 1:\n            self.screen = int(params[0])\n        elif len(params) == 4:\n            left, top, width, height = (int(x) for x in params)\n        elif len(params) == 5:\n            self.screen, left, top, width, height = (int(x) for x in params)\n        self.img_size = img_size\n        self.stride = stride\n        self.transforms = transforms\n        self.auto = auto\n        self.mode = 'stream'\n        self.frame = 0\n        self.sct = mss.mss()\n\n        # Parse monitor shape\n        monitor = self.sct.monitors[self.screen]\n        self.top = monitor[\"top\"] if top is None else (monitor[\"top\"] + top)\n        self.left = monitor[\"left\"] if left is None else (monitor[\"left\"] + left)\n        self.width = width or monitor[\"width\"]\n        self.height = height or monitor[\"height\"]\n        self.monitor = {\"left\": self.left, \"top\": self.top, \"width\": self.width, \"height\": self.height}", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __iter__(self):\n        return self", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __next__(self):\n        # mss screen capture: get raw pixels from the screen as np array\n        im0 = np.array(self.sct.grab(self.monitor))[:, :, :3]  # [:, :, :3] BGRA to BGR\n        s = f\"screen {self.screen} (LTWH): {self.left},{self.top},{self.width},{self.height}: \"\n\n        if self.transforms:\n            im = self.transforms(im0)  # transforms\n        else:\n            im = letterbox(im0, self.img_size, stride=self.stride, auto=self.auto)[0]  # padded resize\n            im = im.transpose((2, 0, 1))[::-1]  # HWC to CHW, BGR to RGB\n            im = np.ascontiguousarray(im)  # contiguous\n        self.frame += 1\n        return str(self.screen), im, im0, None, s  # screen, img, original img, im0s, s", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, path, img_size=640, stride=32, auto=True, transforms=None, vid_stride=1):\n        files = []\n        for p in sorted(path) if isinstance(path, (list, tuple)) else [path]:\n            p = str(Path(p).resolve())\n            if '*' in p:\n                files.extend(sorted(glob.glob(p, recursive=True)))  # glob\n            elif os.path.isdir(p):\n                files.extend(sorted(glob.glob(os.path.join(p, '*.*'))))  # dir\n            elif os.path.isfile(p):\n                files.append(p)  # files\n            else:\n                raise FileNotFoundError(f'{p} does not exist')\n\n        images = [x for x in files if x.split('.')[-1].lower() in IMG_FORMATS]\n        videos = [x for x in files if x.split('.')[-1].lower() in VID_FORMATS]\n        ni, nv = len(images), len(videos)\n\n        self.img_size = img_size\n        self.stride = stride\n        self.files = images + videos\n        self.nf = ni + nv  # number of files\n        self.video_flag = [False] * ni + [True] * nv\n        self.mode = 'image'\n        self.auto = auto\n        self.transforms = transforms  # optional\n        self.vid_stride = vid_stride  # video frame-rate stride\n        if any(videos):\n            self._new_video(videos[0])  # new video\n        else:\n            self.cap = None\n        assert self.nf > 0, f'No images or videos found in {p}. ' \\\n                            f'Supported formats are:\\nimages: {IMG_FORMATS}\\nvideos: {VID_FORMATS}'", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __iter__(self):\n        self.count = 0\n        return self", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __next__(self):\n        if self.count == self.nf:\n            raise StopIteration\n        path = self.files[self.count]\n\n        if self.video_flag[self.count]:\n            # Read video\n            self.mode = 'video'\n            for _ in range(self.vid_stride):\n                self.cap.grab()\n            ret_val, im0 = self.cap.retrieve()\n            while not ret_val:\n                self.count += 1\n                self.cap.release()\n                if self.count == self.nf:  # last video\n                    raise StopIteration\n                path = self.files[self.count]\n                self._new_video(path)\n                ret_val, im0 = self.cap.read()\n\n            self.frame += 1\n            # im0 = self._cv2_rotate(im0)  # for use if cv2 autorotation is False\n            s = f'video {self.count + 1}/{self.nf} ({self.frame}/{self.frames}) {path}: '\n\n        else:\n            # Read image\n            self.count += 1\n            im0 = cv2.imread(path)  # BGR\n            assert im0 is not None, f'Image Not Found {path}'\n            s = f'image {self.count}/{self.nf} {path}: '\n\n        if self.transforms:\n            im = self.transforms(im0)  # transforms\n        else:\n            im = letterbox(im0, self.img_size, stride=self.stride, auto=self.auto)[0]  # padded resize\n            im = im.transpose((2, 0, 1))[::-1]  # HWC to CHW, BGR to RGB\n            im = np.ascontiguousarray(im)  # contiguous\n\n        return path, im, im0, self.cap, s", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _new_video(self, path):\n        # Create a new video capture object\n        self.frame = 0\n        self.cap = cv2.VideoCapture(path)\n        self.frames = int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT) / self.vid_stride)\n        self.orientation = int(self.cap.get(cv2.CAP_PROP_ORIENTATION_META))  # rotation degrees", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _cv2_rotate(self, im):\n        # Rotate a cv2 video manually\n        if self.orientation == 0:\n            return cv2.rotate(im, cv2.ROTATE_90_CLOCKWISE)\n        elif self.orientation == 180:\n            return cv2.rotate(im, cv2.ROTATE_90_COUNTERCLOCKWISE)\n        elif self.orientation == 90:\n            return cv2.rotate(im, cv2.ROTATE_180)\n        return im", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __len__(self):\n        return self.nf  # number of files", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, sources='streams.txt', img_size=640, stride=32, auto=True, transforms=None, vid_stride=1):\n        torch.backends.cudnn.benchmark = True  # faster for fixed-size inference\n        self.mode = 'stream'\n        self.img_size = img_size\n        self.stride = stride\n        self.vid_stride = vid_stride  # video frame-rate stride\n        sources = Path(sources).read_text().rsplit() if os.path.isfile(sources) else [sources]\n        n = len(sources)\n        self.sources = [clean_str(x) for x in sources]  # clean source names for later\n        self.imgs, self.fps, self.frames, self.threads = [None] * n, [0] * n, [0] * n, [None] * n\n        for i, s in enumerate(sources):  # index, source\n            # Start thread to read frames from video stream\n            st = f'{i + 1}/{n}: {s}... '\n            if urlparse(s).hostname in ('www.youtube.com', 'youtube.com', 'youtu.be'):  # if source is YouTube video\n                # YouTube format i.e. 'https://www.youtube.com/watch?v=Zgi9g1ksQHc' or 'https://youtu.be/Zgi9g1ksQHc'\n                check_requirements(('pafy', 'youtube_dl==2020.12.2'))\n                import pafy\n                s = pafy.new(s).getbest(preftype=\"mp4\").url  # YouTube URL\n            s = eval(s) if s.isnumeric() else s  # i.e. s = '0' local webcam\n            if s == 0:\n                assert not is_colab(), '--source 0 webcam unsupported on Colab. Rerun command in a local environment.'\n                assert not is_kaggle(), '--source 0 webcam unsupported on Kaggle. Rerun command in a local environment.'\n            cap = cv2.VideoCapture(s)\n            assert cap.isOpened(), f'{st}Failed to open {s}'\n            w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n            h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n            fps = cap.get(cv2.CAP_PROP_FPS)  # warning: may return 0 or nan\n            self.frames[i] = max(int(cap.get(cv2.CAP_PROP_FRAME_COUNT)), 0) or float('inf')  # infinite stream fallback\n            self.fps[i] = max((fps if math.isfinite(fps) else 0) % 100, 0) or 30  # 30 FPS fallback\n\n            _, self.imgs[i] = cap.read()  # guarantee first frame\n            self.threads[i] = Thread(target=self.update, args=([i, cap, s]), daemon=True)\n            LOGGER.info(f\"{st} Success ({self.frames[i]} frames {w}x{h} at {self.fps[i]:.2f} FPS)\")\n            self.threads[i].start()\n        LOGGER.info('')  # newline\n\n        # check for common shapes\n        s = np.stack([letterbox(x, img_size, stride=stride, auto=auto)[0].shape for x in self.imgs])\n        self.rect = np.unique(s, axis=0).shape[0] == 1  # rect inference if all shapes equal\n        self.auto = auto and self.rect\n        self.transforms = transforms  # optional\n        if not self.rect:\n            LOGGER.warning('WARNING \u26a0\ufe0f Stream shapes differ. For optimal performance supply similarly-shaped streams.')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def update(self, i, cap, stream):\n        # Read stream `i` frames in daemon thread\n        n, f = 0, self.frames[i]  # frame number, frame array\n        while cap.isOpened() and n < f:\n            n += 1\n            cap.grab()  # .read() = .grab() followed by .retrieve()\n            if n % self.vid_stride == 0:\n                success, im = cap.retrieve()\n                if success:\n                    self.imgs[i] = im\n                else:\n                    LOGGER.warning('WARNING \u26a0\ufe0f Video stream unresponsive, please check your IP camera connection.')\n                    self.imgs[i] = np.zeros_like(self.imgs[i])\n                    cap.open(stream)  # re-open stream if signal was lost\n            time.sleep(0.0)  # wait time", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __iter__(self):\n        self.count = -1\n        return self", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __next__(self):\n        self.count += 1\n        if not all(x.is_alive() for x in self.threads) or cv2.waitKey(1) == ord('q'):  # q to quit\n            cv2.destroyAllWindows()\n            raise StopIteration\n\n        im0 = self.imgs.copy()\n        if self.transforms:\n            im = np.stack([self.transforms(x) for x in im0])  # transforms\n        else:\n            im = np.stack([letterbox(x, self.img_size, stride=self.stride, auto=self.auto)[0] for x in im0])  # resize\n            im = im[..., ::-1].transpose((0, 3, 1, 2))  # BGR to RGB, BHWC to BCHW\n            im = np.ascontiguousarray(im)  # contiguous\n\n        return self.sources, im, im0, None, ''", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __len__(self):\n        return len(self.sources)  # 1E12 frames = 32 streams at 30 FPS for 30 years", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self,\n                 path,\n                 img_size=640,\n                 batch_size=16,\n                 augment=False,\n                 hyp=None,\n                 rect=False,\n                 image_weights=False,\n                 cache_images=False,\n                 single_cls=False,\n                 stride=32,\n                 pad=0.0,\n                 min_items=0,\n                 prefix=''):\n        self.img_size = img_size\n        self.augment = augment\n        self.hyp = hyp\n        self.image_weights = image_weights\n        self.rect = False if image_weights else rect\n        self.mosaic = self.augment and not self.rect  # load 4 images at a time into a mosaic (only during training)\n        self.mosaic_border = [-img_size // 2, -img_size // 2]\n        self.stride = stride\n        self.path = path\n        self.albumentations = Albumentations(size=img_size) if augment else None\n\n        try:\n            f = []  # image files\n            for p in path if isinstance(path, list) else [path]:\n                p = Path(p)  # os-agnostic\n                if p.is_dir():  # dir\n                    f += glob.glob(str(p / '**' / '*.*'), recursive=True)\n                    # f = list(p.rglob('*.*'))  # pathlib\n                elif p.is_file():  # file\n                    with open(p) as t:\n                        t = t.read().strip().splitlines()\n                        parent = str(p.parent) + os.sep\n                        f += [x.replace('./', parent, 1) if x.startswith('./') else x for x in t]  # to global path\n                        # f += [p.parent / x.lstrip(os.sep) for x in t]  # to global path (pathlib)\n                else:\n                    raise FileNotFoundError(f'{prefix}{p} does not exist')\n            self.im_files = sorted(x.replace('/', os.sep) for x in f if x.split('.')[-1].lower() in IMG_FORMATS)\n            # self.img_files = sorted([x for x in f if x.suffix[1:].lower() in IMG_FORMATS])  # pathlib\n            assert self.im_files, f'{prefix}No images found'\n        except Exception as e:\n            raise Exception(f'{prefix}Error loading data from {path}: {e}\\n{HELP_URL}') from e\n\n        # Check cache\n        self.label_files = img2label_paths(self.im_files)  # labels\n        cache_path = (p if p.is_file() else Path(self.label_files[0]).parent).with_suffix('.cache')\n        try:\n            cache, exists = np.load(cache_path, allow_pickle=True).item(), True  # load dict\n            assert cache['version'] == self.cache_version  # matches current version\n            assert cache['hash'] == get_hash(self.label_files + self.im_files)  # identical hash\n        except Exception:\n            cache, exists = self.cache_labels(cache_path, prefix), False  # run cache ops\n\n        # Display cache\n        nf, nm, ne, nc, n = cache.pop('results')  # found, missing, empty, corrupt, total\n        if exists and LOCAL_RANK in {-1, 0}:\n            d = f\"Scanning {cache_path}... {nf} images, {nm + ne} backgrounds, {nc} corrupt\"\n            tqdm(None, desc=prefix + d, total=n, initial=n, bar_format=TQDM_BAR_FORMAT)  # display cache results\n            if cache['msgs']:\n                LOGGER.info('\\n'.join(cache['msgs']))  # display warnings\n        assert nf > 0 or not augment, f'{prefix}No labels found in {cache_path}, can not start training. {HELP_URL}'\n\n        # Read cache\n        [cache.pop(k) for k in ('hash', 'version', 'msgs')]  # remove items\n        labels, shapes, self.segments = zip(*cache.values())\n        nl = len(np.concatenate(labels, 0))  # number of labels\n        assert nl > 0 or not augment, f'{prefix}All labels empty in {cache_path}, can not start training. {HELP_URL}'\n        self.labels = list(labels)\n        self.shapes = np.array(shapes)\n        self.im_files = list(cache.keys())  # update\n        self.label_files = img2label_paths(cache.keys())  # update\n\n        # Filter images\n        if min_items:\n            include = np.array([len(x) >= min_items for x in self.labels]).nonzero()[0].astype(int)\n            LOGGER.info(f'{prefix}{n - len(include)}/{n} images filtered from dataset')\n            self.im_files = [self.im_files[i] for i in include]\n            self.label_files = [self.label_files[i] for i in include]\n            self.labels = [self.labels[i] for i in include]\n            self.segments = [self.segments[i] for i in include]\n            self.shapes = self.shapes[include]  # wh\n\n        # Create indices\n        n = len(self.shapes)  # number of images\n        bi = np.floor(np.arange(n) / batch_size).astype(int)  # batch index\n        nb = bi[-1] + 1  # number of batches\n        self.batch = bi  # batch index of image\n        self.n = n\n        self.indices = range(n)\n\n        # Update labels\n        include_class = []  # filter labels to include only these classes (optional)\n        include_class_array = np.array(include_class).reshape(1, -1)\n        for i, (label, segment) in enumerate(zip(self.labels, self.segments)):\n            if include_class:\n                j = (label[:, 0:1] == include_class_array).any(1)\n                self.labels[i] = label[j]\n                if segment:\n                    self.segments[i] = segment[j]\n            if single_cls:  # single-class training, merge all classes into 0\n                self.labels[i][:, 0] = 0\n\n        # Rectangular Training\n        if self.rect:\n            # Sort by aspect ratio\n            s = self.shapes  # wh\n            ar = s[:, 1] / s[:, 0]  # aspect ratio\n            irect = ar.argsort()\n            self.im_files = [self.im_files[i] for i in irect]\n            self.label_files = [self.label_files[i] for i in irect]\n            self.labels = [self.labels[i] for i in irect]\n            self.segments = [self.segments[i] for i in irect]\n            self.shapes = s[irect]  # wh\n            ar = ar[irect]\n\n            # Set training image shapes\n            shapes = [[1, 1]] * nb\n            for i in range(nb):\n                ari = ar[bi == i]\n                mini, maxi = ari.min(), ari.max()\n                if maxi < 1:\n                    shapes[i] = [maxi, 1]\n                elif mini > 1:\n                    shapes[i] = [1, 1 / mini]\n\n            self.batch_shapes = np.ceil(np.array(shapes) * img_size / stride + pad).astype(int) * stride\n\n        # Cache images into RAM/disk for faster training\n        if cache_images == 'ram' and not self.check_cache_ram(prefix=prefix):\n            cache_images = False\n        self.ims = [None] * n\n        self.npy_files = [Path(f).with_suffix('.npy') for f in self.im_files]\n        if cache_images:\n            b, gb = 0, 1 << 30  # bytes of cached images, bytes per gigabytes\n            self.im_hw0, self.im_hw = [None] * n, [None] * n\n            fcn = self.cache_images_to_disk if cache_images == 'disk' else self.load_image\n            results = ThreadPool(NUM_THREADS).imap(fcn, range(n))\n            pbar = tqdm(enumerate(results), total=n, bar_format=TQDM_BAR_FORMAT, disable=LOCAL_RANK > 0)\n            for i, x in pbar:\n                if cache_images == 'disk':\n                    b += self.npy_files[i].stat().st_size\n                else:  # 'ram'\n                    self.ims[i], self.im_hw0[i], self.im_hw[i] = x  # im, hw_orig, hw_resized = load_image(self, i)\n                    b += self.ims[i].nbytes\n                pbar.desc = f'{prefix}Caching images ({b / gb:.1f}GB {cache_images})'\n            pbar.close()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def check_cache_ram(self, safety_margin=0.1, prefix=''):\n        # Check image caching requirements vs available memory\n        b, gb = 0, 1 << 30  # bytes of cached images, bytes per gigabytes\n        n = min(self.n, 30)  # extrapolate from 30 random images\n        for _ in range(n):\n            im = cv2.imread(random.choice(self.im_files))  # sample image\n            ratio = self.img_size / max(im.shape[0], im.shape[1])  # max(h, w)  # ratio\n            b += im.nbytes * ratio ** 2\n        mem_required = b * self.n / n  # GB required to cache dataset into RAM\n        mem = psutil.virtual_memory()\n        cache = mem_required * (1 + safety_margin) < mem.available  # to cache or not to cache, that is the question\n        if not cache:\n            LOGGER.info(f\"{prefix}{mem_required / gb:.1f}GB RAM required, \"\n                        f\"{mem.available / gb:.1f}/{mem.total / gb:.1f}GB available, \"\n                        f\"{'caching images \u2705' if cache else 'not caching images \u26a0\ufe0f'}\")\n        return cache", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def cache_labels(self, path=Path('./labels.cache'), prefix=''):\n        # Cache dataset labels, check images and read shapes\n        x = {}  # dict\n        nm, nf, ne, nc, msgs = 0, 0, 0, 0, []  # number missing, found, empty, corrupt, messages\n        desc = f\"{prefix}Scanning {path.parent / path.stem}...\"\n        with Pool(NUM_THREADS) as pool:\n            pbar = tqdm(pool.imap(verify_image_label, zip(self.im_files, self.label_files, repeat(prefix))),\n                        desc=desc,\n                        total=len(self.im_files),\n                        bar_format=TQDM_BAR_FORMAT)\n            for im_file, lb, shape, segments, nm_f, nf_f, ne_f, nc_f, msg in pbar:\n                nm += nm_f\n                nf += nf_f\n                ne += ne_f\n                nc += nc_f\n                if im_file:\n                    x[im_file] = [lb, shape, segments]\n                if msg:\n                    msgs.append(msg)\n                pbar.desc = f\"{desc} {nf} images, {nm + ne} backgrounds, {nc} corrupt\"\n\n        pbar.close()\n        if msgs:\n            LOGGER.info('\\n'.join(msgs))\n        if nf == 0:\n            LOGGER.warning(f'{prefix}WARNING \u26a0\ufe0f No labels found in {path}. {HELP_URL}')\n        x['hash'] = get_hash(self.label_files + self.im_files)\n        x['results'] = nf, nm, ne, nc, len(self.im_files)\n        x['msgs'] = msgs  # warnings\n        x['version'] = self.cache_version  # cache version\n        try:\n            np.save(path, x)  # save cache for next time\n            path.with_suffix('.cache.npy').rename(path)  # remove .npy suffix\n            LOGGER.info(f'{prefix}New cache created: {path}')\n        except Exception as e:\n            LOGGER.warning(f'{prefix}WARNING \u26a0\ufe0f Cache directory {path.parent} is not writeable: {e}')  # not writeable\n        return x", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __len__(self):\n        return len(self.im_files)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __getitem__(self, index):\n        index = self.indices[index]  # linear, shuffled, or image_weights\n\n        hyp = self.hyp\n        mosaic = self.mosaic and random.random() < hyp['mosaic']\n        if mosaic:\n            # Load mosaic\n            img, labels = self.load_mosaic(index)\n            shapes = None\n\n            # MixUp augmentation\n            if random.random() < hyp['mixup']:\n                img, labels = mixup(img, labels, *self.load_mosaic(random.randint(0, self.n - 1)))\n\n        else:\n            # Load image\n            img, (h0, w0), (h, w) = self.load_image(index)\n\n            # Letterbox\n            shape = self.batch_shapes[self.batch[index]] if self.rect else self.img_size  # final letterboxed shape\n            img, ratio, pad = letterbox(img, shape, auto=False, scaleup=self.augment)\n            shapes = (h0, w0), ((h / h0, w / w0), pad)  # for COCO mAP rescaling\n\n            labels = self.labels[index].copy()\n            if labels.size:  # normalized xywh to pixel xyxy format\n                labels[:, 1:] = xywhn2xyxy(labels[:, 1:], ratio[0] * w, ratio[1] * h, padw=pad[0], padh=pad[1])\n\n            if self.augment:\n                img, labels = random_perspective(img,\n                                                 labels,\n                                                 degrees=hyp['degrees'],\n                                                 translate=hyp['translate'],\n                                                 scale=hyp['scale'],\n                                                 shear=hyp['shear'],\n                                                 perspective=hyp['perspective'])\n\n        nl = len(labels)  # number of labels\n        if nl:\n            labels[:, 1:5] = xyxy2xywhn(labels[:, 1:5], w=img.shape[1], h=img.shape[0], clip=True, eps=1E-3)\n\n        if self.augment:\n            # Albumentations\n            img, labels = self.albumentations(img, labels)\n            nl = len(labels)  # update after albumentations\n\n            # HSV color-space\n            augment_hsv(img, hgain=hyp['hsv_h'], sgain=hyp['hsv_s'], vgain=hyp['hsv_v'])\n\n            # Flip up-down\n            if random.random() < hyp['flipud']:\n                img = np.flipud(img)\n                if nl:\n                    labels[:, 2] = 1 - labels[:, 2]\n\n            # Flip left-right\n            if random.random() < hyp['fliplr']:\n                img = np.fliplr(img)\n                if nl:\n                    labels[:, 1] = 1 - labels[:, 1]\n\n            # Cutouts\n            # labels = cutout(img, labels, p=0.5)\n            # nl = len(labels)  # update after cutout\n\n        labels_out = torch.zeros((nl, 6))\n        if nl:\n            labels_out[:, 1:] = torch.from_numpy(labels)\n\n        # Convert\n        img = img.transpose((2, 0, 1))[::-1]  # HWC to CHW, BGR to RGB\n        img = np.ascontiguousarray(img)\n\n        return torch.from_numpy(img), labels_out, self.im_files[index], shapes", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def load_image(self, i):\n        # Loads 1 image from dataset index 'i', returns (im, original hw, resized hw)\n        im, f, fn = self.ims[i], self.im_files[i], self.npy_files[i],\n        if im is None:  # not cached in RAM\n            if fn.exists():  # load npy\n                im = np.load(fn)\n            else:  # read image\n                im = cv2.imread(f)  # BGR\n                assert im is not None, f'Image Not Found {f}'\n            h0, w0 = im.shape[:2]  # orig hw\n            r = self.img_size / max(h0, w0)  # ratio\n            if r != 1:  # if sizes are not equal\n                interp = cv2.INTER_LINEAR if (self.augment or r > 1) else cv2.INTER_AREA\n                im = cv2.resize(im, (int(w0 * r), int(h0 * r)), interpolation=interp)\n            return im, (h0, w0), im.shape[:2]  # im, hw_original, hw_resized\n        return self.ims[i], self.im_hw0[i], self.im_hw[i]  # im, hw_original, hw_resized", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def cache_images_to_disk(self, i):\n        # Saves an image as an *.npy file for faster loading\n        f = self.npy_files[i]\n        if not f.exists():\n            np.save(f.as_posix(), cv2.imread(self.im_files[i]))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def load_mosaic(self, index):\n        # YOLOv5 4-mosaic loader. Loads 1 image + 3 random images into a 4-image mosaic\n        labels4, segments4 = [], []\n        s = self.img_size\n        yc, xc = (int(random.uniform(-x, 2 * s + x)) for x in self.mosaic_border)  # mosaic center x, y\n        indices = [index] + random.choices(self.indices, k=3)  # 3 additional image indices\n        random.shuffle(indices)\n        for i, index in enumerate(indices):\n            # Load image\n            img, _, (h, w) = self.load_image(index)\n\n            # place img in img4\n            if i == 0:  # top left\n                img4 = np.full((s * 2, s * 2, img.shape[2]), 114, dtype=np.uint8)  # base image with 4 tiles\n                x1a, y1a, x2a, y2a = max(xc - w, 0), max(yc - h, 0), xc, yc  # xmin, ymin, xmax, ymax (large image)\n                x1b, y1b, x2b, y2b = w - (x2a - x1a), h - (y2a - y1a), w, h  # xmin, ymin, xmax, ymax (small image)\n            elif i == 1:  # top right\n                x1a, y1a, x2a, y2a = xc, max(yc - h, 0), min(xc + w, s * 2), yc\n                x1b, y1b, x2b, y2b = 0, h - (y2a - y1a), min(w, x2a - x1a), h\n            elif i == 2:  # bottom left\n                x1a, y1a, x2a, y2a = max(xc - w, 0), yc, xc, min(s * 2, yc + h)\n                x1b, y1b, x2b, y2b = w - (x2a - x1a), 0, w, min(y2a - y1a, h)\n            elif i == 3:  # bottom right\n                x1a, y1a, x2a, y2a = xc, yc, min(xc + w, s * 2), min(s * 2, yc + h)\n                x1b, y1b, x2b, y2b = 0, 0, min(w, x2a - x1a), min(y2a - y1a, h)\n\n            img4[y1a:y2a, x1a:x2a] = img[y1b:y2b, x1b:x2b]  # img4[ymin:ymax, xmin:xmax]\n            padw = x1a - x1b\n            padh = y1a - y1b\n\n            # Labels\n            labels, segments = self.labels[index].copy(), self.segments[index].copy()\n            if labels.size:\n                labels[:, 1:] = xywhn2xyxy(labels[:, 1:], w, h, padw, padh)  # normalized xywh to pixel xyxy format\n                segments = [xyn2xy(x, w, h, padw, padh) for x in segments]\n            labels4.append(labels)\n            segments4.extend(segments)\n\n        # Concat/clip labels\n        labels4 = np.concatenate(labels4, 0)\n        for x in (labels4[:, 1:], *segments4):\n            np.clip(x, 0, 2 * s, out=x)  # clip when using random_perspective()\n        # img4, labels4 = replicate(img4, labels4)  # replicate\n\n        # Augment\n        img4, labels4, segments4 = copy_paste(img4, labels4, segments4, p=self.hyp['copy_paste'])\n        img4, labels4 = random_perspective(img4,\n                                           labels4,\n                                           segments4,\n                                           degrees=self.hyp['degrees'],\n                                           translate=self.hyp['translate'],\n                                           scale=self.hyp['scale'],\n                                           shear=self.hyp['shear'],\n                                           perspective=self.hyp['perspective'],\n                                           border=self.mosaic_border)  # border to remove\n\n        return img4, labels4", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def load_mosaic9(self, index):\n        # YOLOv5 9-mosaic loader. Loads 1 image + 8 random images into a 9-image mosaic\n        labels9, segments9 = [], []\n        s = self.img_size\n        indices = [index] + random.choices(self.indices, k=8)  # 8 additional image indices\n        random.shuffle(indices)\n        hp, wp = -1, -1  # height, width previous\n        for i, index in enumerate(indices):\n            # Load image\n            img, _, (h, w) = self.load_image(index)\n\n            # place img in img9\n            if i == 0:  # center\n                img9 = np.full((s * 3, s * 3, img.shape[2]), 114, dtype=np.uint8)  # base image with 4 tiles\n                h0, w0 = h, w\n                c = s, s, s + w, s + h  # xmin, ymin, xmax, ymax (base) coordinates\n            elif i == 1:  # top\n                c = s, s - h, s + w, s\n            elif i == 2:  # top right\n                c = s + wp, s - h, s + wp + w, s\n            elif i == 3:  # right\n                c = s + w0, s, s + w0 + w, s + h\n            elif i == 4:  # bottom right\n                c = s + w0, s + hp, s + w0 + w, s + hp + h\n            elif i == 5:  # bottom\n                c = s + w0 - w, s + h0, s + w0, s + h0 + h\n            elif i == 6:  # bottom left\n                c = s + w0 - wp - w, s + h0, s + w0 - wp, s + h0 + h\n            elif i == 7:  # left\n                c = s - w, s + h0 - h, s, s + h0\n            elif i == 8:  # top left\n                c = s - w, s + h0 - hp - h, s, s + h0 - hp\n\n            padx, pady = c[:2]\n            x1, y1, x2, y2 = (max(x, 0) for x in c)  # allocate coords\n\n            # Labels\n            labels, segments = self.labels[index].copy(), self.segments[index].copy()\n            if labels.size:\n                labels[:, 1:] = xywhn2xyxy(labels[:, 1:], w, h, padx, pady)  # normalized xywh to pixel xyxy format\n                segments = [xyn2xy(x, w, h, padx, pady) for x in segments]\n            labels9.append(labels)\n            segments9.extend(segments)\n\n            # Image\n            img9[y1:y2, x1:x2] = img[y1 - pady:, x1 - padx:]  # img9[ymin:ymax, xmin:xmax]\n            hp, wp = h, w  # height, width previous\n\n        # Offset\n        yc, xc = (int(random.uniform(0, s)) for _ in self.mosaic_border)  # mosaic center x, y\n        img9 = img9[yc:yc + 2 * s, xc:xc + 2 * s]\n\n        # Concat/clip labels\n        labels9 = np.concatenate(labels9, 0)\n        labels9[:, [1, 3]] -= xc\n        labels9[:, [2, 4]] -= yc\n        c = np.array([xc, yc])  # centers\n        segments9 = [x - c for x in segments9]\n\n        for x in (labels9[:, 1:], *segments9):\n            np.clip(x, 0, 2 * s, out=x)  # clip when using random_perspective()\n        # img9, labels9 = replicate(img9, labels9)  # replicate\n\n        # Augment\n        img9, labels9, segments9 = copy_paste(img9, labels9, segments9, p=self.hyp['copy_paste'])\n        img9, labels9 = random_perspective(img9,\n                                           labels9,\n                                           segments9,\n                                           degrees=self.hyp['degrees'],\n                                           translate=self.hyp['translate'],\n                                           scale=self.hyp['scale'],\n                                           shear=self.hyp['shear'],\n                                           perspective=self.hyp['perspective'],\n                                           border=self.mosaic_border)  # border to remove\n\n        return img9, labels9", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def collate_fn(batch):\n        im, label, path, shapes = zip(*batch)  # transposed\n        for i, lb in enumerate(label):\n            lb[:, 0] = i  # add target image index for build_targets()\n        return torch.stack(im, 0), torch.cat(label, 0), path, shapes", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def collate_fn4(batch):\n        im, label, path, shapes = zip(*batch)  # transposed\n        n = len(shapes) // 4\n        im4, label4, path4, shapes4 = [], [], path[:n], shapes[:n]\n\n        ho = torch.tensor([[0.0, 0, 0, 1, 0, 0]])\n        wo = torch.tensor([[0.0, 0, 1, 0, 0, 0]])\n        s = torch.tensor([[1, 1, 0.5, 0.5, 0.5, 0.5]])  # scale\n        for i in range(n):  # zidane torch.zeros(16,3,720,1280)  # BCHW\n            i *= 4\n            if random.random() < 0.5:\n                im1 = F.interpolate(im[i].unsqueeze(0).float(), scale_factor=2.0, mode='bilinear',\n                                    align_corners=False)[0].type(im[i].type())\n                lb = label[i]\n            else:\n                im1 = torch.cat((torch.cat((im[i], im[i + 1]), 1), torch.cat((im[i + 2], im[i + 3]), 1)), 2)\n                lb = torch.cat((label[i], label[i + 1] + ho, label[i + 2] + wo, label[i + 3] + ho + wo), 0) * s\n            im4.append(im1)\n            label4.append(lb)\n\n        for i, lb in enumerate(label4):\n            lb[:, 0] = i  # add target image index for build_targets()\n\n        return torch.stack(im4, 0), torch.cat(label4, 0), path4, shapes4", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, path='coco128.yaml', autodownload=False):\n        # Initialize class\n        zipped, data_dir, yaml_path = self._unzip(Path(path))\n        try:\n            with open(check_yaml(yaml_path), errors='ignore') as f:\n                data = yaml.safe_load(f)  # data dict\n                if zipped:\n                    data['path'] = data_dir\n        except Exception as e:\n            raise Exception(\"error/HUB/dataset_stats/yaml_load\") from e\n\n        check_dataset(data, autodownload)  # download dataset if missing\n        self.hub_dir = Path(data['path'] + '-hub')\n        self.im_dir = self.hub_dir / 'images'\n        self.im_dir.mkdir(parents=True, exist_ok=True)  # makes /images\n        self.stats = {'nc': data['nc'], 'names': list(data['names'].values())}  # statistics dictionary\n        self.data = data", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _find_yaml(dir):\n        # Return data.yaml file\n        files = list(dir.glob('*.yaml')) or list(dir.rglob('*.yaml'))  # try root level first and then recursive\n        assert files, f'No *.yaml file found in {dir}'\n        if len(files) > 1:\n            files = [f for f in files if f.stem == dir.stem]  # prefer *.yaml files that match dir name\n            assert files, f'Multiple *.yaml files found in {dir}, only 1 *.yaml file allowed'\n        assert len(files) == 1, f'Multiple *.yaml files found: {files}, only 1 *.yaml file allowed in {dir}'\n        return files[0]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _unzip(self, path):\n        # Unzip data.zip\n        if not str(path).endswith('.zip'):  # path is data.yaml\n            return False, None, path\n        assert Path(path).is_file(), f'Error unzipping {path}, file not found'\n        unzip_file(path, path=path.parent)\n        dir = path.with_suffix('')  # dataset directory == zip name\n        assert dir.is_dir(), f'Error unzipping {path}, {dir} not found. path/to/abc.zip MUST unzip to path/to/abc/'\n        return True, str(dir), self._find_yaml(dir)  # zipped, data_dir, yaml_path", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _hub_ops(self, f, max_dim=1920):\n        # HUB ops for 1 image 'f': resize and save at reduced quality in /dataset-hub for web/app viewing\n        f_new = self.im_dir / Path(f).name  # dataset-hub image filename\n        try:  # use PIL\n            im = Image.open(f)\n            r = max_dim / max(im.height, im.width)  # ratio\n            if r < 1.0:  # image too large\n                im = im.resize((int(im.width * r), int(im.height * r)))\n            im.save(f_new, 'JPEG', quality=50, optimize=True)  # save\n        except Exception as e:  # use OpenCV\n            LOGGER.info(f'WARNING \u26a0\ufe0f HUB ops PIL failure {f}: {e}')\n            im = cv2.imread(f)\n            im_height, im_width = im.shape[:2]\n            r = max_dim / max(im_height, im_width)  # ratio\n            if r < 1.0:  # image too large\n                im = cv2.resize(im, (int(im_width * r), int(im_height * r)), interpolation=cv2.INTER_AREA)\n            cv2.imwrite(str(f_new), im)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def get_json(self, save=False, verbose=False):\n        # Return dataset JSON for Ultralytics HUB\n        def _round(labels):\n            # Update labels to integer class and 6 decimal place floats\n            return [[int(c), *(round(x, 4) for x in points)] for c, *points in labels]\n\n        for split in 'train', 'val', 'test':\n            if self.data.get(split) is None:\n                self.stats[split] = None  # i.e. no test set\n                continue\n            dataset = LoadImagesAndLabels(self.data[split])  # load dataset\n            x = np.array([\n                np.bincount(label[:, 0].astype(int), minlength=self.data['nc'])\n                for label in tqdm(dataset.labels, total=dataset.n, desc='Statistics')])  # shape(128x80)\n            self.stats[split] = {\n                'instance_stats': {\n                    'total': int(x.sum()),\n                    'per_class': x.sum(0).tolist()},\n                'image_stats': {\n                    'total': dataset.n,\n                    'unlabelled': int(np.all(x == 0, 1).sum()),\n                    'per_class': (x > 0).sum(0).tolist()},\n                'labels': [{\n                    str(Path(k).name): _round(v.tolist())} for k, v in zip(dataset.im_files, dataset.labels)]}\n\n        # Save, print and return\n        if save:\n            stats_path = self.hub_dir / 'stats.json'\n            print(f'Saving {stats_path.resolve()}...')\n            with open(stats_path, 'w') as f:\n                json.dump(self.stats, f)  # save stats.json\n        if verbose:\n            print(json.dumps(self.stats, indent=2, sort_keys=False))\n        return self.stats", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def process_images(self):\n        # Compress images for Ultralytics HUB\n        for split in 'train', 'val', 'test':\n            if self.data.get(split) is None:\n                continue\n            dataset = LoadImagesAndLabels(self.data[split])  # load dataset\n            desc = f'{split} images'\n            for _ in tqdm(ThreadPool(NUM_THREADS).imap(self._hub_ops, dataset.im_files), total=dataset.n, desc=desc):\n                pass\n        print(f'Done. All images saved to {self.im_dir}')\n        return self.im_dir", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, root, augment, imgsz, cache=False):\n        super().__init__(root=root)\n        self.torch_transforms = classify_transforms(imgsz)\n        self.album_transforms = classify_albumentations(augment, imgsz) if augment else None\n        self.cache_ram = cache is True or cache == 'ram'\n        self.cache_disk = cache == 'disk'\n        self.samples = [list(x) + [Path(x[0]).with_suffix('.npy'), None] for x in self.samples]  # file, index, npy, im", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __getitem__(self, i):\n        f, j, fn, im = self.samples[i]  # filename, index, filename.with_suffix('.npy'), image\n        if self.cache_ram and im is None:\n            im = self.samples[i][3] = cv2.imread(f)\n        elif self.cache_disk:\n            if not fn.exists():  # load npy\n                np.save(fn.as_posix(), cv2.imread(f))\n            im = np.load(fn)\n        else:  # read image\n            im = cv2.imread(f)  # BGR\n        if self.album_transforms:\n            sample = self.album_transforms(image=cv2.cvtColor(im, cv2.COLOR_BGR2RGB))[\"image\"]\n        else:\n            sample = self.torch_transforms(im)\n        return sample, j", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "        def _round(labels):\n            # Update labels to integer class and 6 decimal place floats\n            return [[int(c), *(round(x, 4) for x in points)] for c, *points in labels]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def fitness(x):\n    # Model fitness as a weighted combination of metrics\n    w = [0.0, 0.0, 0.1, 0.9, 0.0, 0.0, 0.1, 0.9]\n    return (x[:, :8] * w).sum(1)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def ap_per_class_box_and_mask(\n        tp_m,\n        tp_b,\n        conf,\n        pred_cls,\n        target_cls,\n        plot=False,\n        save_dir=\".\",\n        names=(),\n):\n    \"\"\"\n    Args:\n        tp_b: tp of boxes.\n        tp_m: tp of masks.\n        other arguments see `func: ap_per_class`.\n    \"\"\"\n    results_boxes = ap_per_class(tp_b,\n                                 conf,\n                                 pred_cls,\n                                 target_cls,\n                                 plot=plot,\n                                 save_dir=save_dir,\n                                 names=names,\n                                 prefix=\"Box\")[2:]\n    results_masks = ap_per_class(tp_m,\n                                 conf,\n                                 pred_cls,\n                                 target_cls,\n                                 plot=plot,\n                                 save_dir=save_dir,\n                                 names=names,\n                                 prefix=\"Mask\")[2:]\n\n    results = {\n        \"boxes\": {\n            \"p\": results_boxes[0],\n            \"r\": results_boxes[1],\n            \"ap\": results_boxes[3],\n            \"f1\": results_boxes[2],\n            \"ap_class\": results_boxes[4]},\n        \"masks\": {\n            \"p\": results_masks[0],\n            \"r\": results_masks[1],\n            \"ap\": results_masks[3],\n            \"f1\": results_masks[2],\n            \"ap_class\": results_masks[4]}}\n    return results", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self) -> None:\n        self.p = []  # (nc, )\n        self.r = []  # (nc, )\n        self.f1 = []  # (nc, )\n        self.all_ap = []  # (nc, 10)\n        self.ap_class_index = []  # (nc, )", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def ap50(self):\n        \"\"\"AP@0.5 of all classes.\n        Return:\n            (nc, ) or [].\n        \"\"\"\n        return self.all_ap[:, 0] if len(self.all_ap) else []", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def ap(self):\n        \"\"\"AP@0.5:0.95\n        Return:\n            (nc, ) or [].\n        \"\"\"\n        return self.all_ap.mean(1) if len(self.all_ap) else []", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def mp(self):\n        \"\"\"mean precision of all classes.\n        Return:\n            float.\n        \"\"\"\n        return self.p.mean() if len(self.p) else 0.0", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def mr(self):\n        \"\"\"mean recall of all classes.\n        Return:\n            float.\n        \"\"\"\n        return self.r.mean() if len(self.r) else 0.0", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def map50(self):\n        \"\"\"Mean AP@0.5 of all classes.\n        Return:\n            float.\n        \"\"\"\n        return self.all_ap[:, 0].mean() if len(self.all_ap) else 0.0", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def map(self):\n        \"\"\"Mean AP@0.5:0.95 of all classes.\n        Return:\n            float.\n        \"\"\"\n        return self.all_ap.mean() if len(self.all_ap) else 0.0", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def mean_results(self):\n        \"\"\"Mean of results, return mp, mr, map50, map\"\"\"\n        return (self.mp, self.mr, self.map50, self.map)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def class_result(self, i):\n        \"\"\"class-aware result, return p[i], r[i], ap50[i], ap[i]\"\"\"\n        return (self.p[i], self.r[i], self.ap50[i], self.ap[i])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def get_maps(self, nc):\n        maps = np.zeros(nc) + self.map\n        for i, c in enumerate(self.ap_class_index):\n            maps[c] = self.ap[i]\n        return maps", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def update(self, results):\n        \"\"\"\n        Args:\n            results: tuple(p, r, ap, f1, ap_class)\n        \"\"\"\n        p, r, all_ap, f1, ap_class_index = results\n        self.p = p\n        self.r = r\n        self.all_ap = all_ap\n        self.f1 = f1\n        self.ap_class_index = ap_class_index", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self) -> None:\n        self.metric_box = Metric()\n        self.metric_mask = Metric()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def update(self, results):\n        \"\"\"\n        Args:\n            results: Dict{'boxes': Dict{}, 'masks': Dict{}}\n        \"\"\"\n        self.metric_box.update(list(results[\"boxes\"].values()))\n        self.metric_mask.update(list(results[\"masks\"].values()))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def mean_results(self):\n        return self.metric_box.mean_results() + self.metric_mask.mean_results()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def class_result(self, i):\n        return self.metric_box.class_result(i) + self.metric_mask.class_result(i)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def get_maps(self, nc):\n        return self.metric_box.get_maps(nc) + self.metric_mask.get_maps(nc)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def ap_class_index(self):\n        # boxes and masks have the same ap_class_index\n        return self.metric_box.ap_class_index", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def create_dataloader(path,\n                      imgsz,\n                      batch_size,\n                      stride,\n                      single_cls=False,\n                      hyp=None,\n                      augment=False,\n                      cache=False,\n                      pad=0.0,\n                      rect=False,\n                      rank=-1,\n                      workers=8,\n                      image_weights=False,\n                      quad=False,\n                      prefix='',\n                      shuffle=False,\n                      mask_downsample_ratio=1,\n                      overlap_mask=False):\n    if rect and shuffle:\n        LOGGER.warning('WARNING \u26a0\ufe0f --rect is incompatible with DataLoader shuffle, setting shuffle=False')\n        shuffle = False\n    with torch_distributed_zero_first(rank):  # init dataset *.cache only once if DDP\n        dataset = LoadImagesAndLabelsAndMasks(\n            path,\n            imgsz,\n            batch_size,\n            augment=augment,  # augmentation\n            hyp=hyp,  # hyperparameters\n            rect=rect,  # rectangular batches\n            cache_images=cache,\n            single_cls=single_cls,\n            stride=int(stride),\n            pad=pad,\n            image_weights=image_weights,\n            prefix=prefix,\n            downsample_ratio=mask_downsample_ratio,\n            overlap=overlap_mask)\n\n    batch_size = min(batch_size, len(dataset))\n    nd = torch.cuda.device_count()  # number of CUDA devices\n    nw = min([os.cpu_count() // max(nd, 1), batch_size if batch_size > 1 else 0, workers])  # number of workers\n    sampler = None if rank == -1 else distributed.DistributedSampler(dataset, shuffle=shuffle)\n    loader = DataLoader if image_weights else InfiniteDataLoader  # only DataLoader allows for attribute updates\n    generator = torch.Generator()\n    generator.manual_seed(6148914691236517205 + RANK)\n    return loader(\n        dataset,\n        batch_size=batch_size,\n        shuffle=shuffle and sampler is None,\n        num_workers=nw,\n        sampler=sampler,\n        pin_memory=True,\n        collate_fn=LoadImagesAndLabelsAndMasks.collate_fn4 if quad else LoadImagesAndLabelsAndMasks.collate_fn,\n        worker_init_fn=seed_worker,\n        generator=generator,\n    ), dataset", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def polygon2mask(img_size, polygons, color=1, downsample_ratio=1):\n    \"\"\"\n    Args:\n        img_size (tuple): The image size.\n        polygons (np.ndarray): [N, M], N is the number of polygons,\n            M is the number of points(Be divided by 2).\n    \"\"\"\n    mask = np.zeros(img_size, dtype=np.uint8)\n    polygons = np.asarray(polygons)\n    polygons = polygons.astype(np.int32)\n    shape = polygons.shape\n    polygons = polygons.reshape(shape[0], -1, 2)\n    cv2.fillPoly(mask, polygons, color=color)\n    nh, nw = (img_size[0] // downsample_ratio, img_size[1] // downsample_ratio)\n    # NOTE: fillPoly firstly then resize is trying the keep the same way\n    # of loss calculation when mask-ratio=1.\n    mask = cv2.resize(mask, (nw, nh))\n    return mask", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def polygons2masks(img_size, polygons, color, downsample_ratio=1):\n    \"\"\"\n    Args:\n        img_size (tuple): The image size.\n        polygons (list[np.ndarray]): each polygon is [N, M],\n            N is the number of polygons,\n            M is the number of points(Be divided by 2).\n    \"\"\"\n    masks = []\n    for si in range(len(polygons)):\n        mask = polygon2mask(img_size, [polygons[si].reshape(-1)], color, downsample_ratio)\n        masks.append(mask)\n    return np.array(masks)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def polygons2masks_overlap(img_size, segments, downsample_ratio=1):\n    \"\"\"Return a (640, 640) overlap mask.\"\"\"\n    masks = np.zeros((img_size[0] // downsample_ratio, img_size[1] // downsample_ratio),\n                     dtype=np.int32 if len(segments) > 255 else np.uint8)\n    areas = []\n    ms = []\n    for si in range(len(segments)):\n        mask = polygon2mask(\n            img_size,\n            [segments[si].reshape(-1)],\n            downsample_ratio=downsample_ratio,\n            color=1,\n        )\n        ms.append(mask)\n        areas.append(mask.sum())\n    areas = np.asarray(areas)\n    index = np.argsort(-areas)\n    ms = np.array(ms)[index]\n    for i in range(len(segments)):\n        mask = ms[i] * (i + 1)\n        masks = masks + mask\n        masks = np.clip(masks, a_min=0, a_max=i + 1)\n    return masks, index", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(\n        self,\n        path,\n        img_size=640,\n        batch_size=16,\n        augment=False,\n        hyp=None,\n        rect=False,\n        image_weights=False,\n        cache_images=False,\n        single_cls=False,\n        stride=32,\n        pad=0,\n        min_items=0,\n        prefix=\"\",\n        downsample_ratio=1,\n        overlap=False,\n    ):\n        super().__init__(path, img_size, batch_size, augment, hyp, rect, image_weights, cache_images, single_cls,\n                         stride, pad, min_items, prefix)\n        self.downsample_ratio = downsample_ratio\n        self.overlap = overlap", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __getitem__(self, index):\n        index = self.indices[index]  # linear, shuffled, or image_weights\n\n        hyp = self.hyp\n        mosaic = self.mosaic and random.random() < hyp['mosaic']\n        masks = []\n        if mosaic:\n            # Load mosaic\n            img, labels, segments = self.load_mosaic(index)\n            shapes = None\n\n            # MixUp augmentation\n            if random.random() < hyp[\"mixup\"]:\n                img, labels, segments = mixup(img, labels, segments, *self.load_mosaic(random.randint(0, self.n - 1)))\n\n        else:\n            # Load image\n            img, (h0, w0), (h, w) = self.load_image(index)\n\n            # Letterbox\n            shape = self.batch_shapes[self.batch[index]] if self.rect else self.img_size  # final letterboxed shape\n            img, ratio, pad = letterbox(img, shape, auto=False, scaleup=self.augment)\n            shapes = (h0, w0), ((h / h0, w / w0), pad)  # for COCO mAP rescaling\n\n            labels = self.labels[index].copy()\n            # [array, array, ....], array.shape=(num_points, 2), xyxyxyxy\n            segments = self.segments[index].copy()\n            if len(segments):\n                for i_s in range(len(segments)):\n                    segments[i_s] = xyn2xy(\n                        segments[i_s],\n                        ratio[0] * w,\n                        ratio[1] * h,\n                        padw=pad[0],\n                        padh=pad[1],\n                    )\n            if labels.size:  # normalized xywh to pixel xyxy format\n                labels[:, 1:] = xywhn2xyxy(labels[:, 1:], ratio[0] * w, ratio[1] * h, padw=pad[0], padh=pad[1])\n\n            if self.augment:\n                img, labels, segments = random_perspective(img,\n                                                           labels,\n                                                           segments=segments,\n                                                           degrees=hyp[\"degrees\"],\n                                                           translate=hyp[\"translate\"],\n                                                           scale=hyp[\"scale\"],\n                                                           shear=hyp[\"shear\"],\n                                                           perspective=hyp[\"perspective\"])\n\n        nl = len(labels)  # number of labels\n        if nl:\n            labels[:, 1:5] = xyxy2xywhn(labels[:, 1:5], w=img.shape[1], h=img.shape[0], clip=True, eps=1e-3)\n            if self.overlap:\n                masks, sorted_idx = polygons2masks_overlap(img.shape[:2],\n                                                           segments,\n                                                           downsample_ratio=self.downsample_ratio)\n                masks = masks[None]  # (640, 640) -> (1, 640, 640)\n                labels = labels[sorted_idx]\n            else:\n                masks = polygons2masks(img.shape[:2], segments, color=1, downsample_ratio=self.downsample_ratio)\n\n        masks = (torch.from_numpy(masks) if len(masks) else torch.zeros(1 if self.overlap else nl, img.shape[0] //\n                                                                        self.downsample_ratio, img.shape[1] //\n                                                                        self.downsample_ratio))\n        # TODO: albumentations support\n        if self.augment:\n            # Albumentations\n            # there are some augmentation that won't change boxes and masks,\n            # so just be it for now.\n            img, labels = self.albumentations(img, labels)\n            nl = len(labels)  # update after albumentations\n\n            # HSV color-space\n            augment_hsv(img, hgain=hyp[\"hsv_h\"], sgain=hyp[\"hsv_s\"], vgain=hyp[\"hsv_v\"])\n\n            # Flip up-down\n            if random.random() < hyp[\"flipud\"]:\n                img = np.flipud(img)\n                if nl:\n                    labels[:, 2] = 1 - labels[:, 2]\n                    masks = torch.flip(masks, dims=[1])\n\n            # Flip left-right\n            if random.random() < hyp[\"fliplr\"]:\n                img = np.fliplr(img)\n                if nl:\n                    labels[:, 1] = 1 - labels[:, 1]\n                    masks = torch.flip(masks, dims=[2])\n\n            # Cutouts  # labels = cutout(img, labels, p=0.5)\n\n        labels_out = torch.zeros((nl, 6))\n        if nl:\n            labels_out[:, 1:] = torch.from_numpy(labels)\n\n        # Convert\n        img = img.transpose((2, 0, 1))[::-1]  # HWC to CHW, BGR to RGB\n        img = np.ascontiguousarray(img)\n\n        return (torch.from_numpy(img), labels_out, self.im_files[index], shapes, masks)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def load_mosaic(self, index):\n        # YOLOv5 4-mosaic loader. Loads 1 image + 3 random images into a 4-image mosaic\n        labels4, segments4 = [], []\n        s = self.img_size\n        yc, xc = (int(random.uniform(-x, 2 * s + x)) for x in self.mosaic_border)  # mosaic center x, y\n\n        # 3 additional image indices\n        indices = [index] + random.choices(self.indices, k=3)  # 3 additional image indices\n        for i, index in enumerate(indices):\n            # Load image\n            img, _, (h, w) = self.load_image(index)\n\n            # place img in img4\n            if i == 0:  # top left\n                img4 = np.full((s * 2, s * 2, img.shape[2]), 114, dtype=np.uint8)  # base image with 4 tiles\n                x1a, y1a, x2a, y2a = max(xc - w, 0), max(yc - h, 0), xc, yc  # xmin, ymin, xmax, ymax (large image)\n                x1b, y1b, x2b, y2b = w - (x2a - x1a), h - (y2a - y1a), w, h  # xmin, ymin, xmax, ymax (small image)\n            elif i == 1:  # top right\n                x1a, y1a, x2a, y2a = xc, max(yc - h, 0), min(xc + w, s * 2), yc\n                x1b, y1b, x2b, y2b = 0, h - (y2a - y1a), min(w, x2a - x1a), h\n            elif i == 2:  # bottom left\n                x1a, y1a, x2a, y2a = max(xc - w, 0), yc, xc, min(s * 2, yc + h)\n                x1b, y1b, x2b, y2b = w - (x2a - x1a), 0, w, min(y2a - y1a, h)\n            elif i == 3:  # bottom right\n                x1a, y1a, x2a, y2a = xc, yc, min(xc + w, s * 2), min(s * 2, yc + h)\n                x1b, y1b, x2b, y2b = 0, 0, min(w, x2a - x1a), min(y2a - y1a, h)\n\n            img4[y1a:y2a, x1a:x2a] = img[y1b:y2b, x1b:x2b]  # img4[ymin:ymax, xmin:xmax]\n            padw = x1a - x1b\n            padh = y1a - y1b\n\n            labels, segments = self.labels[index].copy(), self.segments[index].copy()\n\n            if labels.size:\n                labels[:, 1:] = xywhn2xyxy(labels[:, 1:], w, h, padw, padh)  # normalized xywh to pixel xyxy format\n                segments = [xyn2xy(x, w, h, padw, padh) for x in segments]\n            labels4.append(labels)\n            segments4.extend(segments)\n\n        # Concat/clip labels\n        labels4 = np.concatenate(labels4, 0)\n        for x in (labels4[:, 1:], *segments4):\n            np.clip(x, 0, 2 * s, out=x)  # clip when using random_perspective()\n        # img4, labels4 = replicate(img4, labels4)  # replicate\n\n        # Augment\n        img4, labels4, segments4 = copy_paste(img4, labels4, segments4, p=self.hyp[\"copy_paste\"])\n        img4, labels4, segments4 = random_perspective(img4,\n                                                      labels4,\n                                                      segments4,\n                                                      degrees=self.hyp[\"degrees\"],\n                                                      translate=self.hyp[\"translate\"],\n                                                      scale=self.hyp[\"scale\"],\n                                                      shear=self.hyp[\"shear\"],\n                                                      perspective=self.hyp[\"perspective\"],\n                                                      border=self.mosaic_border)  # border to remove\n        return img4, labels4, segments4", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def collate_fn(batch):\n        img, label, path, shapes, masks = zip(*batch)  # transposed\n        batched_masks = torch.cat(masks, 0)\n        for i, l in enumerate(label):\n            l[:, 0] = i  # add target image index for build_targets()\n        return torch.stack(img, 0), torch.cat(label, 0), path, shapes, batched_masks", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, model, autobalance=False, overlap=False):\n        self.sort_obj_iou = False\n        self.overlap = overlap\n        device = next(model.parameters()).device  # get model device\n        h = model.hyp  # hyperparameters\n        self.device = device\n\n        # Define criteria\n        BCEcls = nn.BCEWithLogitsLoss(pos_weight=torch.tensor([h['cls_pw']], device=device))\n        BCEobj = nn.BCEWithLogitsLoss(pos_weight=torch.tensor([h['obj_pw']], device=device))\n\n        # Class label smoothing https://arxiv.org/pdf/1902.04103.pdf eqn 3\n        self.cp, self.cn = smooth_BCE(eps=h.get('label_smoothing', 0.0))  # positive, negative BCE targets\n\n        # Focal loss\n        g = h['fl_gamma']  # focal loss gamma\n        if g > 0:\n            BCEcls, BCEobj = FocalLoss(BCEcls, g), FocalLoss(BCEobj, g)\n\n        m = de_parallel(model).model[-1]  # Detect() module\n        self.balance = {3: [4.0, 1.0, 0.4]}.get(m.nl, [4.0, 1.0, 0.25, 0.06, 0.02])  # P3-P7\n        self.ssi = list(m.stride).index(16) if autobalance else 0  # stride 16 index\n        self.BCEcls, self.BCEobj, self.gr, self.hyp, self.autobalance = BCEcls, BCEobj, 1.0, h, autobalance\n        self.na = m.na  # number of anchors\n        self.nc = m.nc  # number of classes\n        self.nl = m.nl  # number of layers\n        self.nm = m.nm  # number of masks\n        self.anchors = m.anchors\n        self.device = device", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __call__(self, preds, targets, masks):  # predictions, targets, model\n        p, proto = preds\n        bs, nm, mask_h, mask_w = proto.shape  # batch size, number of masks, mask height, mask width\n        lcls = torch.zeros(1, device=self.device)\n        lbox = torch.zeros(1, device=self.device)\n        lobj = torch.zeros(1, device=self.device)\n        lseg = torch.zeros(1, device=self.device)\n        tcls, tbox, indices, anchors, tidxs, xywhn = self.build_targets(p, targets)  # targets\n\n        # Losses\n        for i, pi in enumerate(p):  # layer index, layer predictions\n            b, a, gj, gi = indices[i]  # image, anchor, gridy, gridx\n            tobj = torch.zeros(pi.shape[:4], dtype=pi.dtype, device=self.device)  # target obj\n\n            n = b.shape[0]  # number of targets\n            if n:\n                pxy, pwh, _, pcls, pmask = pi[b, a, gj, gi].split((2, 2, 1, self.nc, nm), 1)  # subset of predictions\n\n                # Box regression\n                pxy = pxy.sigmoid() * 2 - 0.5\n                pwh = (pwh.sigmoid() * 2) ** 2 * anchors[i]\n                pbox = torch.cat((pxy, pwh), 1)  # predicted box\n                iou = bbox_iou(pbox, tbox[i], CIoU=True).squeeze()  # iou(prediction, target)\n                lbox += (1.0 - iou).mean()  # iou loss\n\n                # Objectness\n                iou = iou.detach().clamp(0).type(tobj.dtype)\n                if self.sort_obj_iou:\n                    j = iou.argsort()\n                    b, a, gj, gi, iou = b[j], a[j], gj[j], gi[j], iou[j]\n                if self.gr < 1:\n                    iou = (1.0 - self.gr) + self.gr * iou\n                tobj[b, a, gj, gi] = iou  # iou ratio\n\n                # Classification\n                if self.nc > 1:  # cls loss (only if multiple classes)\n                    t = torch.full_like(pcls, self.cn, device=self.device)  # targets\n                    t[range(n), tcls[i]] = self.cp\n                    lcls += self.BCEcls(pcls, t)  # BCE\n\n                # Mask regression\n                if tuple(masks.shape[-2:]) != (mask_h, mask_w):  # downsample\n                    masks = F.interpolate(masks[None], (mask_h, mask_w), mode=\"nearest\")[0]\n                marea = xywhn[i][:, 2:].prod(1)  # mask width, height normalized\n                mxyxy = xywh2xyxy(xywhn[i] * torch.tensor([mask_w, mask_h, mask_w, mask_h], device=self.device))\n                for bi in b.unique():\n                    j = b == bi  # matching index\n                    if self.overlap:\n                        mask_gti = torch.where(masks[bi][None] == tidxs[i][j].view(-1, 1, 1), 1.0, 0.0)\n                    else:\n                        mask_gti = masks[tidxs[i]][j]\n                    lseg += self.single_mask_loss(mask_gti, pmask[j], proto[bi], mxyxy[j], marea[j])\n\n            obji = self.BCEobj(pi[..., 4], tobj)\n            lobj += obji * self.balance[i]  # obj loss\n            if self.autobalance:\n                self.balance[i] = self.balance[i] * 0.9999 + 0.0001 / obji.detach().item()\n\n        if self.autobalance:\n            self.balance = [x / self.balance[self.ssi] for x in self.balance]\n        lbox *= self.hyp[\"box\"]\n        lobj *= self.hyp[\"obj\"]\n        lcls *= self.hyp[\"cls\"]\n        lseg *= self.hyp[\"box\"] / bs\n\n        loss = lbox + lobj + lcls + lseg\n        return loss * bs, torch.cat((lbox, lseg, lobj, lcls)).detach()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def single_mask_loss(self, gt_mask, pred, proto, xyxy, area):\n        # Mask loss for one image\n        pred_mask = (pred @ proto.view(self.nm, -1)).view(-1, *proto.shape[1:])  # (n,32) @ (32,80,80) -> (n,80,80)\n        loss = F.binary_cross_entropy_with_logits(pred_mask, gt_mask, reduction=\"none\")\n        return (crop_mask(loss, xyxy).mean(dim=(1, 2)) / area).mean()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def build_targets(self, p, targets):\n        # Build targets for compute_loss(), input targets(image,class,x,y,w,h)\n        na, nt = self.na, targets.shape[0]  # number of anchors, targets\n        tcls, tbox, indices, anch, tidxs, xywhn = [], [], [], [], [], []\n        gain = torch.ones(8, device=self.device)  # normalized to gridspace gain\n        ai = torch.arange(na, device=self.device).float().view(na, 1).repeat(1, nt)  # same as .repeat_interleave(nt)\n        if self.overlap:\n            batch = p[0].shape[0]\n            ti = []\n            for i in range(batch):\n                num = (targets[:, 0] == i).sum()  # find number of targets of each image\n                ti.append(torch.arange(num, device=self.device).float().view(1, num).repeat(na, 1) + 1)  # (na, num)\n            ti = torch.cat(ti, 1)  # (na, nt)\n        else:\n            ti = torch.arange(nt, device=self.device).float().view(1, nt).repeat(na, 1)\n        targets = torch.cat((targets.repeat(na, 1, 1), ai[..., None], ti[..., None]), 2)  # append anchor indices\n\n        g = 0.5  # bias\n        off = torch.tensor(\n            [\n                [0, 0],\n                [1, 0],\n                [0, 1],\n                [-1, 0],\n                [0, -1],  # j,k,l,m\n                # [1, 1], [1, -1], [-1, 1], [-1, -1],  # jk,jm,lk,lm\n            ],\n            device=self.device).float() * g  # offsets\n\n        for i in range(self.nl):\n            anchors, shape = self.anchors[i], p[i].shape\n            gain[2:6] = torch.tensor(shape)[[3, 2, 3, 2]]  # xyxy gain\n\n            # Match targets to anchors\n            t = targets * gain  # shape(3,n,7)\n            if nt:\n                # Matches\n                r = t[..., 4:6] / anchors[:, None]  # wh ratio\n                j = torch.max(r, 1 / r).max(2)[0] < self.hyp['anchor_t']  # compare\n                # j = wh_iou(anchors, t[:, 4:6]) > model.hyp['iou_t']  # iou(3,n)=wh_iou(anchors(3,2), gwh(n,2))\n                t = t[j]  # filter\n\n                # Offsets\n                gxy = t[:, 2:4]  # grid xy\n                gxi = gain[[2, 3]] - gxy  # inverse\n                j, k = ((gxy % 1 < g) & (gxy > 1)).T\n                l, m = ((gxi % 1 < g) & (gxi > 1)).T\n                j = torch.stack((torch.ones_like(j), j, k, l, m))\n                t = t.repeat((5, 1, 1))[j]\n                offsets = (torch.zeros_like(gxy)[None] + off[:, None])[j]\n            else:\n                t = targets[0]\n                offsets = 0\n\n            # Define\n            bc, gxy, gwh, at = t.chunk(4, 1)  # (image, class), grid xy, grid wh, anchors\n            (a, tidx), (b, c) = at.long().T, bc.long().T  # anchors, image, class\n            gij = (gxy - offsets).long()\n            gi, gj = gij.T  # grid indices\n\n            # Append\n            indices.append((b, a, gj.clamp_(0, shape[2] - 1), gi.clamp_(0, shape[3] - 1)))  # image, anchor, grid\n            tbox.append(torch.cat((gxy - gij, gwh), 1))  # box\n            anch.append(anchors[a])  # anchors\n            tcls.append(c)  # class\n            tidxs.append(tidx)\n            xywhn.append(torch.cat((gxy, gwh), 1) / gain[2:6])  # xywh normalized\n\n        return tcls, tbox, indices, anch, tidxs, xywhn", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def plot_images_and_masks(images, targets, masks, paths=None, fname='images.jpg', names=None):\n    # Plot image grid with labels\n    if isinstance(images, torch.Tensor):\n        images = images.cpu().float().numpy()\n    if isinstance(targets, torch.Tensor):\n        targets = targets.cpu().numpy()\n    if isinstance(masks, torch.Tensor):\n        masks = masks.cpu().numpy().astype(int)\n\n    max_size = 1920  # max image size\n    max_subplots = 16  # max image subplots, i.e. 4x4\n    bs, _, h, w = images.shape  # batch size, _, height, width\n    bs = min(bs, max_subplots)  # limit plot images\n    ns = np.ceil(bs ** 0.5)  # number of subplots (square)\n    if np.max(images[0]) <= 1:\n        images *= 255  # de-normalise (optional)\n\n    # Build Image\n    mosaic = np.full((int(ns * h), int(ns * w), 3), 255, dtype=np.uint8)  # init\n    for i, im in enumerate(images):\n        if i == max_subplots:  # if last batch has fewer images than we expect\n            break\n        x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin\n        im = im.transpose(1, 2, 0)\n        mosaic[y:y + h, x:x + w, :] = im\n\n    # Resize (optional)\n    scale = max_size / ns / max(h, w)\n    if scale < 1:\n        h = math.ceil(scale * h)\n        w = math.ceil(scale * w)\n        mosaic = cv2.resize(mosaic, tuple(int(x * ns) for x in (w, h)))\n\n    # Annotate\n    fs = int((h + w) * ns * 0.01)  # font size\n    annotator = Annotator(mosaic, line_width=round(fs / 10), font_size=fs, pil=True, example=names)\n    for i in range(i + 1):\n        x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin\n        annotator.rectangle([x, y, x + w, y + h], None, (255, 255, 255), width=2)  # borders\n        if paths:\n            annotator.text((x + 5, y + 5 + h), text=Path(paths[i]).name[:40], txt_color=(220, 220, 220))  # filenames\n        if len(targets) > 0:\n            idx = targets[:, 0] == i\n            ti = targets[idx]  # image targets\n\n            boxes = xywh2xyxy(ti[:, 2:6]).T\n            classes = ti[:, 1].astype('int')\n            labels = ti.shape[1] == 6  # labels if no conf column\n            conf = None if labels else ti[:, 6]  # check for confidence presence (label vs pred)\n\n            if boxes.shape[1]:\n                if boxes.max() <= 1.01:  # if normalized with tolerance 0.01\n                    boxes[[0, 2]] *= w  # scale to pixels\n                    boxes[[1, 3]] *= h\n                elif scale < 1:  # absolute coords need scale if image scales\n                    boxes *= scale\n            boxes[[0, 2]] += x\n            boxes[[1, 3]] += y\n            for j, box in enumerate(boxes.T.tolist()):\n                cls = classes[j]\n                color = colors(cls)\n                cls = names[cls] if names else cls\n                if labels or conf[j] > 0.25:  # 0.25 conf thresh\n                    label = f'{cls}' if labels else f'{cls} {conf[j]:.1f}'\n                    annotator.box_label(box, label, color=color)\n\n            # Plot masks\n            if len(masks):\n                if masks.max() > 1.0:  # mean that masks are overlap\n                    image_masks = masks[[i]]  # (1, 640, 640)\n                    nl = len(ti)\n                    index = np.arange(nl).reshape(nl, 1, 1) + 1\n                    image_masks = np.repeat(image_masks, nl, axis=0)\n                    image_masks = np.where(image_masks == index, 1.0, 0.0)\n                else:\n                    image_masks = masks[idx]\n\n                im = np.asarray(annotator.im).copy()\n                for j, box in enumerate(boxes.T.tolist()):\n                    if labels or conf[j] > 0.25:  # 0.25 conf thresh\n                        color = colors(classes[j])\n                        mh, mw = image_masks[j].shape\n                        if mh != h or mw != w:\n                            mask = image_masks[j].astype(np.uint8)\n                            mask = cv2.resize(mask, (w, h))\n                            mask = mask.astype(bool)\n                        else:\n                            mask = image_masks[j].astype(bool)\n                        with contextlib.suppress(Exception):\n                            im[y:y + h, x:x + w, :][mask] = im[y:y + h, x:x + w, :][mask] * 0.4 + np.array(color) * 0.6\n                annotator.fromarray(im)\n    annotator.im.save(fname)  # save", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def plot_results_with_masks(file=\"path/to/results.csv\", dir=\"\", best=True):\n    # Plot training results.csv. Usage: from utils.plots import *; plot_results('path/to/results.csv')\n    save_dir = Path(file).parent if file else Path(dir)\n    fig, ax = plt.subplots(2, 8, figsize=(18, 6), tight_layout=True)\n    ax = ax.ravel()\n    files = list(save_dir.glob(\"results*.csv\"))\n    assert len(files), f\"No results.csv files found in {save_dir.resolve()}, nothing to plot.\"\n    for f in files:\n        try:\n            data = pd.read_csv(f)\n            index = np.argmax(0.9 * data.values[:, 8] + 0.1 * data.values[:, 7] + 0.9 * data.values[:, 12] +\n                              0.1 * data.values[:, 11])\n            s = [x.strip() for x in data.columns]\n            x = data.values[:, 0]\n            for i, j in enumerate([1, 2, 3, 4, 5, 6, 9, 10, 13, 14, 15, 16, 7, 8, 11, 12]):\n                y = data.values[:, j]\n                # y[y == 0] = np.nan  # don't show zero values\n                ax[i].plot(x, y, marker=\".\", label=f.stem, linewidth=2, markersize=2)\n                if best:\n                    # best\n                    ax[i].scatter(index, y[index], color=\"r\", label=f\"best:{index}\", marker=\"*\", linewidth=3)\n                    ax[i].set_title(s[j] + f\"\\n{round(y[index], 5)}\")\n                else:\n                    # last\n                    ax[i].scatter(x[-1], y[-1], color=\"r\", label=\"last\", marker=\"*\", linewidth=3)\n                    ax[i].set_title(s[j] + f\"\\n{round(y[-1], 5)}\")\n                # if j in [8, 9, 10]:  # share train and val loss y axes\n                #     ax[i].get_shared_y_axes().join(ax[i], ax[i - 5])\n        except Exception as e:\n            print(f\"Warning: Plotting error for {f}: {e}\")\n    ax[1].legend()\n    fig.savefig(save_dir / \"results.png\", dpi=200)\n    plt.close()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def crop_mask(masks, boxes):\n    \"\"\"\n    \"Crop\" predicted masks by zeroing out everything not in the predicted bbox.\n    Vectorized by Chong (thanks Chong).\n\n    Args:\n        - masks should be a size [h, w, n] tensor of masks\n        - boxes should be a size [n, 4] tensor of bbox coords in relative point form\n    \"\"\"\n\n    n, h, w = masks.shape\n    x1, y1, x2, y2 = torch.chunk(boxes[:, :, None], 4, 1)  # x1 shape(1,1,n)\n    r = torch.arange(w, device=masks.device, dtype=x1.dtype)[None, None, :]  # rows shape(1,w,1)\n    c = torch.arange(h, device=masks.device, dtype=x1.dtype)[None, :, None]  # cols shape(h,1,1)\n\n    return masks * ((r >= x1) * (r < x2) * (c >= y1) * (c < y2))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def process_mask_upsample(protos, masks_in, bboxes, shape):\n    \"\"\"\n    Crop after upsample.\n    proto_out: [mask_dim, mask_h, mask_w]\n    out_masks: [n, mask_dim], n is number of masks after nms\n    bboxes: [n, 4], n is number of masks after nms\n    shape:input_image_size, (h, w)\n\n    return: h, w, n\n    \"\"\"\n\n    c, mh, mw = protos.shape  # CHW\n    masks = (masks_in @ protos.float().view(c, -1)).sigmoid().view(-1, mh, mw)\n    masks = F.interpolate(masks[None], shape, mode='bilinear', align_corners=False)[0]  # CHW\n    masks = crop_mask(masks, bboxes)  # CHW\n    return masks.gt_(0.5)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def process_mask(protos, masks_in, bboxes, shape, upsample=False):\n    \"\"\"\n    Crop before upsample.\n    proto_out: [mask_dim, mask_h, mask_w]\n    out_masks: [n, mask_dim], n is number of masks after nms\n    bboxes: [n, 4], n is number of masks after nms\n    shape:input_image_size, (h, w)\n\n    return: h, w, n\n    \"\"\"\n\n    c, mh, mw = protos.shape  # CHW\n    ih, iw = shape\n    masks = (masks_in @ protos.float().view(c, -1)).sigmoid().view(-1, mh, mw)  # CHW\n\n    downsampled_bboxes = bboxes.clone()\n    downsampled_bboxes[:, 0] *= mw / iw\n    downsampled_bboxes[:, 2] *= mw / iw\n    downsampled_bboxes[:, 3] *= mh / ih\n    downsampled_bboxes[:, 1] *= mh / ih\n\n    masks = crop_mask(masks, downsampled_bboxes)  # CHW\n    if upsample:\n        masks = F.interpolate(masks[None], shape, mode='bilinear', align_corners=False)[0]  # CHW\n    return masks.gt_(0.5)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def scale_image(im1_shape, masks, im0_shape, ratio_pad=None):\n    \"\"\"\n    img1_shape: model input shape, [h, w]\n    img0_shape: origin pic shape, [h, w, 3]\n    masks: [h, w, num]\n    \"\"\"\n    # Rescale coordinates (xyxy) from im1_shape to im0_shape\n    if ratio_pad is None:  # calculate from im0_shape\n        gain = min(im1_shape[0] / im0_shape[0], im1_shape[1] / im0_shape[1])  # gain  = old / new\n        pad = (im1_shape[1] - im0_shape[1] * gain) / 2, (im1_shape[0] - im0_shape[0] * gain) / 2  # wh padding\n    else:\n        pad = ratio_pad[1]\n    top, left = int(pad[1]), int(pad[0])  # y, x\n    bottom, right = int(im1_shape[0] - pad[1]), int(im1_shape[1] - pad[0])\n\n    if len(masks.shape) < 2:\n        raise ValueError(f'\"len of masks shape\" should be 2 or 3, but got {len(masks.shape)}')\n    masks = masks[top:bottom, left:right]\n    # masks = masks.permute(2, 0, 1).contiguous()\n    # masks = F.interpolate(masks[None], im0_shape[:2], mode='bilinear', align_corners=False)[0]\n    # masks = masks.permute(1, 2, 0).contiguous()\n    masks = cv2.resize(masks, (im0_shape[1], im0_shape[0]))\n\n    if len(masks.shape) == 2:\n        masks = masks[:, :, None]\n    return masks", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def mask_iou(mask1, mask2, eps=1e-7):\n    \"\"\"\n    mask1: [N, n] m1 means number of predicted objects\n    mask2: [M, n] m2 means number of gt objects\n    Note: n means image_w x image_h\n\n    return: masks iou, [N, M]\n    \"\"\"\n    intersection = torch.matmul(mask1, mask2.t()).clamp(0)\n    union = (mask1.sum(1)[:, None] + mask2.sum(1)[None]) - intersection  # (area1 + area2) - intersection\n    return intersection / (union + eps)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def masks_iou(mask1, mask2, eps=1e-7):\n    \"\"\"\n    mask1: [N, n] m1 means number of predicted objects\n    mask2: [N, n] m2 means number of gt objects\n    Note: n means image_w x image_h\n\n    return: masks iou, (N, )\n    \"\"\"\n    intersection = (mask1 * mask2).sum(1).clamp(0)  # (N, )\n    union = (mask1.sum(1) + mask2.sum(1))[None] - intersection  # (area1 + area2) - intersection\n    return intersection / (union + eps)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def masks2segments(masks, strategy='largest'):\n    # Convert masks(n,160,160) into segments(n,xy)\n    segments = []\n    for x in masks.int().cpu().numpy().astype('uint8'):\n        c = cv2.findContours(x, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[0]\n        if c:\n            if strategy == 'concat':  # concatenate all segments\n                c = np.concatenate([x.reshape(-1, 2) for x in c])\n            elif strategy == 'largest':  # select largest segment\n                c = np.array(c[np.array([len(x) for x in c]).argmax()]).reshape(-1, 2)\n        else:\n            c = np.zeros((0, 2))  # no segments found\n        segments.append(c.astype('float32'))\n    return segments", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def mixup(im, labels, segments, im2, labels2, segments2):\n    # Applies MixUp augmentation https://arxiv.org/pdf/1710.09412.pdf\n    r = np.random.beta(32.0, 32.0)  # mixup ratio, alpha=beta=32.0\n    im = (im * r + im2 * (1 - r)).astype(np.uint8)\n    labels = np.concatenate((labels, labels2), 0)\n    segments = np.concatenate((segments, segments2), 0)\n    return im, labels, segments", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def random_perspective(im,\n                       targets=(),\n                       segments=(),\n                       degrees=10,\n                       translate=.1,\n                       scale=.1,\n                       shear=10,\n                       perspective=0.0,\n                       border=(0, 0)):\n    # torchvision.transforms.RandomAffine(degrees=(-10, 10), translate=(.1, .1), scale=(.9, 1.1), shear=(-10, 10))\n    # targets = [cls, xyxy]\n\n    height = im.shape[0] + border[0] * 2  # shape(h,w,c)\n    width = im.shape[1] + border[1] * 2\n\n    # Center\n    C = np.eye(3)\n    C[0, 2] = -im.shape[1] / 2  # x translation (pixels)\n    C[1, 2] = -im.shape[0] / 2  # y translation (pixels)\n\n    # Perspective\n    P = np.eye(3)\n    P[2, 0] = random.uniform(-perspective, perspective)  # x perspective (about y)\n    P[2, 1] = random.uniform(-perspective, perspective)  # y perspective (about x)\n\n    # Rotation and Scale\n    R = np.eye(3)\n    a = random.uniform(-degrees, degrees)\n    # a += random.choice([-180, -90, 0, 90])  # add 90deg rotations to small rotations\n    s = random.uniform(1 - scale, 1 + scale)\n    # s = 2 ** random.uniform(-scale, scale)\n    R[:2] = cv2.getRotationMatrix2D(angle=a, center=(0, 0), scale=s)\n\n    # Shear\n    S = np.eye(3)\n    S[0, 1] = math.tan(random.uniform(-shear, shear) * math.pi / 180)  # x shear (deg)\n    S[1, 0] = math.tan(random.uniform(-shear, shear) * math.pi / 180)  # y shear (deg)\n\n    # Translation\n    T = np.eye(3)\n    T[0, 2] = (random.uniform(0.5 - translate, 0.5 + translate) * width)  # x translation (pixels)\n    T[1, 2] = (random.uniform(0.5 - translate, 0.5 + translate) * height)  # y translation (pixels)\n\n    # Combined rotation matrix\n    M = T @ S @ R @ P @ C  # order of operations (right to left) is IMPORTANT\n    if (border[0] != 0) or (border[1] != 0) or (M != np.eye(3)).any():  # image changed\n        if perspective:\n            im = cv2.warpPerspective(im, M, dsize=(width, height), borderValue=(114, 114, 114))\n        else:  # affine\n            im = cv2.warpAffine(im, M[:2], dsize=(width, height), borderValue=(114, 114, 114))\n\n    # Visualize\n    # import matplotlib.pyplot as plt\n    # ax = plt.subplots(1, 2, figsize=(12, 6))[1].ravel()\n    # ax[0].imshow(im[:, :, ::-1])  # base\n    # ax[1].imshow(im2[:, :, ::-1])  # warped\n\n    # Transform label coordinates\n    n = len(targets)\n    new_segments = []\n    if n:\n        new = np.zeros((n, 4))\n        segments = resample_segments(segments)  # upsample\n        for i, segment in enumerate(segments):\n            xy = np.ones((len(segment), 3))\n            xy[:, :2] = segment\n            xy = xy @ M.T  # transform\n            xy = (xy[:, :2] / xy[:, 2:3] if perspective else xy[:, :2])  # perspective rescale or affine\n\n            # clip\n            new[i] = segment2box(xy, width, height)\n            new_segments.append(xy)\n\n        # filter candidates\n        i = box_candidates(box1=targets[:, 1:5].T * s, box2=new.T, area_thr=0.01)\n        targets = targets[i]\n        targets[:, 1:5] = new[i]\n        new_segments = np.array(new_segments)[i]\n\n    return im, targets, new_segments", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def emojis(str=''):\n    # Return platform-dependent emoji-safe version of string\n    return str.encode().decode('ascii', 'ignore') if platform.system() == 'Windows' else str", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def threaded(func):\n    # Multi-threads a target function and returns thread. Usage: @threaded decorator\n    def wrapper(*args, **kwargs):\n        thread = threading.Thread(target=func, args=args, kwargs=kwargs, daemon=True)\n        thread.start()\n        return thread\n\n    return wrapper", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def join_threads(verbose=False):\n    # Join all daemon threads, i.e. atexit.register(lambda: join_threads())\n    main_thread = threading.current_thread()\n    for t in threading.enumerate():\n        if t is not main_thread:\n            if verbose:\n                print(f'Joining thread {t.name}')\n            t.join()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def notebook_init(verbose=True):\n    # Check system software and hardware\n    print('Checking setup...')\n\n    import os\n    import shutil\n\n    from utils.general import check_font, check_requirements, is_colab\n    from utils.torch_utils import select_device  # imports\n\n    check_font()\n\n    import psutil\n    from IPython import display  # to display images and clear console output\n\n    if is_colab():\n        shutil.rmtree('/content/sample_data', ignore_errors=True)  # remove colab /sample_data directory\n\n    # System info\n    if verbose:\n        gb = 1 << 30  # bytes to GiB (1024 ** 3)\n        ram = psutil.virtual_memory().total\n        total, used, free = shutil.disk_usage(\"/\")\n        display.clear_output()\n        s = f'({os.cpu_count()} CPUs, {ram / gb:.1f} GB RAM, {(total - free) / gb:.1f}/{total / gb:.1f} GB disk)'\n    else:\n        s = ''\n\n    select_device(newline=False)\n    print(emojis(f'Setup complete \u2705 {s}'))\n    return display", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, msg=''):\n        self.msg = msg", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __enter__(self):\n        pass", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __exit__(self, exc_type, value, traceback):\n        if value:\n            print(emojis(f\"{self.msg}{': ' if self.msg else ''}{value}\"))\n        return True", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def wrapper(*args, **kwargs):\n        thread = threading.Thread(target=func, args=args, kwargs=kwargs, daemon=True)\n        thread.start()\n        return thread", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def is_url(url, check=True):\n    # Check if string is URL and check if URL exists\n    try:\n        url = str(url)\n        result = urllib.parse.urlparse(url)\n        assert all([result.scheme, result.netloc])  # check if is url\n        return (urllib.request.urlopen(url).getcode() == 200) if check else True  # check if exists online\n    except (AssertionError, urllib.request.HTTPError):\n        return False", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def gsutil_getsize(url=''):\n    # gs://bucket/file size https://cloud.google.com/storage/docs/gsutil/commands/du\n    s = subprocess.check_output(f'gsutil du {url}', shell=True).decode('utf-8')\n    return eval(s.split(' ')[0]) if len(s) else 0  # bytes", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def url_getsize(url='https://ultralytics.com/images/bus.jpg'):\n    # Return downloadable file size in bytes\n    response = requests.head(url, allow_redirects=True)\n    return int(response.headers.get('content-length', -1))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def safe_download(file, url, url2=None, min_bytes=1E0, error_msg=''):\n    # Attempts to download file from url or url2, checks and removes incomplete downloads < min_bytes\n    from utils.general import LOGGER\n\n    file = Path(file)\n    assert_msg = f\"Downloaded file '{file}' does not exist or size is < min_bytes={min_bytes}\"\n    try:  # url1\n        LOGGER.info(f'Downloading {url} to {file}...')\n        torch.hub.download_url_to_file(url, str(file), progress=LOGGER.level <= logging.INFO)\n        assert file.exists() and file.stat().st_size > min_bytes, assert_msg  # check\n    except Exception as e:  # url2\n        if file.exists():\n            file.unlink()  # remove partial downloads\n        LOGGER.info(f'ERROR: {e}\\nRe-attempting {url2 or url} to {file}...')\n        os.system(f\"curl -# -L '{url2 or url}' -o '{file}' --retry 3 -C -\")  # curl download, retry and resume on fail\n    finally:\n        if not file.exists() or file.stat().st_size < min_bytes:  # check\n            if file.exists():\n                file.unlink()  # remove partial downloads\n            LOGGER.info(f\"ERROR: {assert_msg}\\n{error_msg}\")\n        LOGGER.info('')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def attempt_download(file, repo='ultralytics/yolov5', release='v7.0'):\n    # Attempt file download from GitHub release assets if not found locally. release = 'latest', 'v7.0', etc.\n    from utils.general import LOGGER\n\n    def github_assets(repository, version='latest'):\n        # Return GitHub repo tag (i.e. 'v7.0') and assets (i.e. ['yolov5s.pt', 'yolov5m.pt', ...])\n        if version != 'latest':\n            version = f'tags/{version}'  # i.e. tags/v7.0\n        response = requests.get(f'https://api.github.com/repos/{repository}/releases/{version}').json()  # github api\n        return response['tag_name'], [x['name'] for x in response['assets']]  # tag, assets\n\n    file = Path(str(file).strip().replace(\"'\", ''))\n    if not file.exists():\n        # URL specified\n        name = Path(urllib.parse.unquote(str(file))).name  # decode '%2F' to '/' etc.\n        if str(file).startswith(('http:/', 'https:/')):  # download\n            url = str(file).replace(':/', '://')  # Pathlib turns :// -> :/\n            file = name.split('?')[0]  # parse authentication https://url.com/file.txt?auth...\n            if Path(file).is_file():\n                LOGGER.info(f'Found {url} locally at {file}')  # file already exists\n            else:\n                safe_download(file=file, url=url, min_bytes=1E5)\n            return file\n\n        # GitHub assets\n        assets = [f'yolov5{size}{suffix}.pt' for size in 'nsmlx' for suffix in ('', '6', '-cls', '-seg')]  # default\n        try:\n            tag, assets = github_assets(repo, release)\n        except Exception:\n            try:\n                tag, assets = github_assets(repo)  # latest release\n            except Exception:\n                try:\n                    tag = subprocess.check_output('git tag', shell=True, stderr=subprocess.STDOUT).decode().split()[-1]\n                except Exception:\n                    tag = release\n\n        file.parent.mkdir(parents=True, exist_ok=True)  # make parent dir (if required)\n        if name in assets:\n            url3 = 'https://drive.google.com/drive/folders/1EFQTEUeXWSFww0luse2jB9M1QNZQGwNl'  # backup gdrive mirror\n            safe_download(\n                file,\n                url=f'https://github.com/{repo}/releases/download/{tag}/{name}',\n                min_bytes=1E5,\n                error_msg=f'{file} missing, try downloading from https://github.com/{repo}/releases/{tag} or {url3}')\n\n    return str(file)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def github_assets(repository, version='latest'):\n        # Return GitHub repo tag (i.e. 'v7.0') and assets (i.e. ['yolov5s.pt', 'yolov5m.pt', ...])\n        if version != 'latest':\n            version = f'tags/{version}'  # i.e. tags/v7.0\n        response = requests.get(f'https://api.github.com/repos/{repository}/releases/{version}').json()  # github api\n        return response['tag_name'], [x['name'] for x in response['assets']]  # tag, assets", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def smooth_BCE(eps=0.1):  # https://github.com/ultralytics/yolov3/issues/238#issuecomment-598028441\n    # return positive, negative label smoothing BCE targets\n    return 1.0 - 0.5 * eps, 0.5 * eps", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, alpha=0.05):\n        super().__init__()\n        self.loss_fcn = nn.BCEWithLogitsLoss(reduction='none')  # must be nn.BCEWithLogitsLoss()\n        self.alpha = alpha", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, pred, true):\n        loss = self.loss_fcn(pred, true)\n        pred = torch.sigmoid(pred)  # prob from logits\n        dx = pred - true  # reduce only missing label effects\n        # dx = (pred - true).abs()  # reduce missing label and false label effects\n        alpha_factor = 1 - torch.exp((dx - 1) / (self.alpha + 1e-4))\n        loss *= alpha_factor\n        return loss.mean()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, loss_fcn, gamma=1.5, alpha=0.25):\n        super().__init__()\n        self.loss_fcn = loss_fcn  # must be nn.BCEWithLogitsLoss()\n        self.gamma = gamma\n        self.alpha = alpha\n        self.reduction = loss_fcn.reduction\n        self.loss_fcn.reduction = 'none'  # required to apply FL to each element", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, pred, true):\n        loss = self.loss_fcn(pred, true)\n        # p_t = torch.exp(-loss)\n        # loss *= self.alpha * (1.000001 - p_t) ** self.gamma  # non-zero power for gradient stability\n\n        # TF implementation https://github.com/tensorflow/addons/blob/v0.7.1/tensorflow_addons/losses/focal_loss.py\n        pred_prob = torch.sigmoid(pred)  # prob from logits\n        p_t = true * pred_prob + (1 - true) * (1 - pred_prob)\n        alpha_factor = true * self.alpha + (1 - true) * (1 - self.alpha)\n        modulating_factor = (1.0 - p_t) ** self.gamma\n        loss *= alpha_factor * modulating_factor\n\n        if self.reduction == 'mean':\n            return loss.mean()\n        elif self.reduction == 'sum':\n            return loss.sum()\n        else:  # 'none'\n            return loss", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, loss_fcn, gamma=1.5, alpha=0.25):\n        super().__init__()\n        self.loss_fcn = loss_fcn  # must be nn.BCEWithLogitsLoss()\n        self.gamma = gamma\n        self.alpha = alpha\n        self.reduction = loss_fcn.reduction\n        self.loss_fcn.reduction = 'none'  # required to apply FL to each element", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, pred, true):\n        loss = self.loss_fcn(pred, true)\n\n        pred_prob = torch.sigmoid(pred)  # prob from logits\n        alpha_factor = true * self.alpha + (1 - true) * (1 - self.alpha)\n        modulating_factor = torch.abs(true - pred_prob) ** self.gamma\n        loss *= alpha_factor * modulating_factor\n\n        if self.reduction == 'mean':\n            return loss.mean()\n        elif self.reduction == 'sum':\n            return loss.sum()\n        else:  # 'none'\n            return loss", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, model, autobalance=False):\n        device = next(model.parameters()).device  # get model device\n        h = model.hyp  # hyperparameters\n\n        # Define criteria\n        BCEcls = nn.BCEWithLogitsLoss(pos_weight=torch.tensor([h['cls_pw']], device=device))\n        BCEobj = nn.BCEWithLogitsLoss(pos_weight=torch.tensor([h['obj_pw']], device=device))\n\n        # Class label smoothing https://arxiv.org/pdf/1902.04103.pdf eqn 3\n        self.cp, self.cn = smooth_BCE(eps=h.get('label_smoothing', 0.0))  # positive, negative BCE targets\n\n        # Focal loss\n        g = h['fl_gamma']  # focal loss gamma\n        if g > 0:\n            BCEcls, BCEobj = FocalLoss(BCEcls, g), FocalLoss(BCEobj, g)\n\n        m = de_parallel(model).model[-1]  # Detect() module\n        self.balance = {3: [4.0, 1.0, 0.4]}.get(m.nl, [4.0, 1.0, 0.25, 0.06, 0.02])  # P3-P7\n        self.ssi = list(m.stride).index(16) if autobalance else 0  # stride 16 index\n        self.BCEcls, self.BCEobj, self.gr, self.hyp, self.autobalance = BCEcls, BCEobj, 1.0, h, autobalance\n        self.na = m.na  # number of anchors\n        self.nc = m.nc  # number of classes\n        self.nl = m.nl  # number of layers\n        self.anchors = m.anchors\n        self.device = device", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __call__(self, p, targets):  # predictions, targets\n        lcls = torch.zeros(1, device=self.device)  # class loss\n        lbox = torch.zeros(1, device=self.device)  # box loss\n        lobj = torch.zeros(1, device=self.device)  # object loss\n        tcls, tbox, indices, anchors = self.build_targets(p, targets)  # targets\n\n        # Losses\n        for i, pi in enumerate(p):  # layer index, layer predictions\n            b, a, gj, gi = indices[i]  # image, anchor, gridy, gridx\n            tobj = torch.zeros(pi.shape[:4], dtype=pi.dtype, device=self.device)  # target obj\n\n            n = b.shape[0]  # number of targets\n            if n:\n                # pxy, pwh, _, pcls = pi[b, a, gj, gi].tensor_split((2, 4, 5), dim=1)  # faster, requires torch 1.8.0\n                pxy, pwh, _, pcls = pi[b, a, gj, gi].split((2, 2, 1, self.nc), 1)  # target-subset of predictions\n\n                # Regression\n                pxy = pxy.sigmoid() * 2 - 0.5\n                pwh = (pwh.sigmoid() * 2) ** 2 * anchors[i]\n                pbox = torch.cat((pxy, pwh), 1)  # predicted box\n                iou = bbox_iou(pbox, tbox[i], CIoU=True).squeeze()  # iou(prediction, target)\n                lbox += (1.0 - iou).mean()  # iou loss\n\n                # Objectness\n                iou = iou.detach().clamp(0).type(tobj.dtype)\n                if self.sort_obj_iou:\n                    j = iou.argsort()\n                    b, a, gj, gi, iou = b[j], a[j], gj[j], gi[j], iou[j]\n                if self.gr < 1:\n                    iou = (1.0 - self.gr) + self.gr * iou\n                tobj[b, a, gj, gi] = iou  # iou ratio\n\n                # Classification\n                if self.nc > 1:  # cls loss (only if multiple classes)\n                    t = torch.full_like(pcls, self.cn, device=self.device)  # targets\n                    t[range(n), tcls[i]] = self.cp\n                    lcls += self.BCEcls(pcls, t)  # BCE\n\n                # Append targets to text file\n                # with open('targets.txt', 'a') as file:\n                #     [file.write('%11.5g ' * 4 % tuple(x) + '\\n') for x in torch.cat((txy[i], twh[i]), 1)]\n\n            obji = self.BCEobj(pi[..., 4], tobj)\n            lobj += obji * self.balance[i]  # obj loss\n            if self.autobalance:\n                self.balance[i] = self.balance[i] * 0.9999 + 0.0001 / obji.detach().item()\n\n        if self.autobalance:\n            self.balance = [x / self.balance[self.ssi] for x in self.balance]\n        lbox *= self.hyp['box']\n        lobj *= self.hyp['obj']\n        lcls *= self.hyp['cls']\n        bs = tobj.shape[0]  # batch size\n\n        return (lbox + lobj + lcls) * bs, torch.cat((lbox, lobj, lcls)).detach()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def build_targets(self, p, targets):\n        # Build targets for compute_loss(), input targets(image,class,x,y,w,h)\n        na, nt = self.na, targets.shape[0]  # number of anchors, targets\n        tcls, tbox, indices, anch = [], [], [], []\n        gain = torch.ones(7, device=self.device)  # normalized to gridspace gain\n        ai = torch.arange(na, device=self.device).float().view(na, 1).repeat(1, nt)  # same as .repeat_interleave(nt)\n        targets = torch.cat((targets.repeat(na, 1, 1), ai[..., None]), 2)  # append anchor indices\n\n        g = 0.5  # bias\n        off = torch.tensor(\n            [\n                [0, 0],\n                [1, 0],\n                [0, 1],\n                [-1, 0],\n                [0, -1],  # j,k,l,m\n                # [1, 1], [1, -1], [-1, 1], [-1, -1],  # jk,jm,lk,lm\n            ],\n            device=self.device).float() * g  # offsets\n\n        for i in range(self.nl):\n            anchors, shape = self.anchors[i], p[i].shape\n            gain[2:6] = torch.tensor(shape)[[3, 2, 3, 2]]  # xyxy gain\n\n            # Match targets to anchors\n            t = targets * gain  # shape(3,n,7)\n            if nt:\n                # Matches\n                r = t[..., 4:6] / anchors[:, None]  # wh ratio\n                j = torch.max(r, 1 / r).max(2)[0] < self.hyp['anchor_t']  # compare\n                # j = wh_iou(anchors, t[:, 4:6]) > model.hyp['iou_t']  # iou(3,n)=wh_iou(anchors(3,2), gwh(n,2))\n                t = t[j]  # filter\n\n                # Offsets\n                gxy = t[:, 2:4]  # grid xy\n                gxi = gain[[2, 3]] - gxy  # inverse\n                j, k = ((gxy % 1 < g) & (gxy > 1)).T\n                l, m = ((gxi % 1 < g) & (gxi > 1)).T\n                j = torch.stack((torch.ones_like(j), j, k, l, m))\n                t = t.repeat((5, 1, 1))[j]\n                offsets = (torch.zeros_like(gxy)[None] + off[:, None])[j]\n            else:\n                t = targets[0]\n                offsets = 0\n\n            # Define\n            bc, gxy, gwh, a = t.chunk(4, 1)  # (image, class), grid xy, grid wh, anchors\n            a, (b, c) = a.long().view(-1), bc.long().T  # anchors, image, class\n            gij = (gxy - offsets).long()\n            gi, gj = gij.T  # grid indices\n\n            # Append\n            indices.append((b, a, gj.clamp_(0, shape[2] - 1), gi.clamp_(0, shape[3] - 1)))  # image, anchor, grid\n            tbox.append(torch.cat((gxy - gij, gwh), 1))  # box\n            anch.append(anchors[a])  # anchors\n            tcls.append(c)  # class\n\n        return tcls, tbox, indices, anch", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_pil_font(font=FONT, size=10):\n    # Return a PIL TrueType Font, downloading to CONFIG_DIR if necessary\n    font = Path(font)\n    font = font if font.exists() else (CONFIG_DIR / font.name)\n    try:\n        return ImageFont.truetype(str(font) if font.exists() else font.name, size)\n    except Exception:  # download if missing\n        try:\n            check_font(font)\n            return ImageFont.truetype(str(font), size)\n        except TypeError:\n            check_requirements('Pillow>=8.4.0')  # known issue https://github.com/ultralytics/yolov5/issues/5374\n        except URLError:  # not online\n            return ImageFont.load_default()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def feature_visualization(x, module_type, stage, n=32, save_dir=Path('runs/detect/exp')):\n    \"\"\"\n    x:              Features to be visualized\n    module_type:    Module type\n    stage:          Module stage within model\n    n:              Maximum number of feature maps to plot\n    save_dir:       Directory to save results\n    \"\"\"\n    if 'Detect' not in module_type:\n        batch, channels, height, width = x.shape  # batch, channels, height, width\n        if height > 1 and width > 1:\n            f = save_dir / f\"stage{stage}_{module_type.split('.')[-1]}_features.png\"  # filename\n\n            blocks = torch.chunk(x[0].cpu(), channels, dim=0)  # select batch index 0, block by channels\n            n = min(n, channels)  # number of plots\n            fig, ax = plt.subplots(math.ceil(n / 8), 8, tight_layout=True)  # 8 rows x n/8 cols\n            ax = ax.ravel()\n            plt.subplots_adjust(wspace=0.05, hspace=0.05)\n            for i in range(n):\n                ax[i].imshow(blocks[i].squeeze())  # cmap='gray'\n                ax[i].axis('off')\n\n            LOGGER.info(f'Saving {f}... ({n}/{channels})')\n            plt.savefig(f, dpi=300, bbox_inches='tight')\n            plt.close()\n            np.save(str(f.with_suffix('.npy')), x[0].cpu().numpy())  # npy save", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def hist2d(x, y, n=100):\n    # 2d histogram used in labels.png and evolve.png\n    xedges, yedges = np.linspace(x.min(), x.max(), n), np.linspace(y.min(), y.max(), n)\n    hist, xedges, yedges = np.histogram2d(x, y, (xedges, yedges))\n    xidx = np.clip(np.digitize(x, xedges) - 1, 0, hist.shape[0] - 1)\n    yidx = np.clip(np.digitize(y, yedges) - 1, 0, hist.shape[1] - 1)\n    return np.log(hist[xidx, yidx])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def butter_lowpass_filtfilt(data, cutoff=1500, fs=50000, order=5):\n    from scipy.signal import butter, filtfilt\n\n    # https://stackoverflow.com/questions/28536191/how-to-filter-smooth-with-scipy-numpy\n    def butter_lowpass(cutoff, fs, order):\n        nyq = 0.5 * fs\n        normal_cutoff = cutoff / nyq\n        return butter(order, normal_cutoff, btype='low', analog=False)\n\n    b, a = butter_lowpass(cutoff, fs, order=order)\n    return filtfilt(b, a, data)  # forward-backward filter", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def output_to_target(output, max_det=300):\n    # Convert model output to target format [batch_id, class_id, x, y, w, h, conf] for plotting\n    targets = []\n    for i, o in enumerate(output):\n        box, conf, cls = o[:max_det, :6].cpu().split((4, 1, 1), 1)\n        j = torch.full((conf.shape[0], 1), i)\n        targets.append(torch.cat((j, cls, xyxy2xywh(box), conf), 1))\n    return torch.cat(targets, 0).numpy()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def plot_images(images, targets, paths=None, fname='images.jpg', names=None):\n    # Plot image grid with labels\n    if isinstance(images, torch.Tensor):\n        images = images.cpu().float().numpy()\n    if isinstance(targets, torch.Tensor):\n        targets = targets.cpu().numpy()\n\n    max_size = 1920  # max image size\n    max_subplots = 16  # max image subplots, i.e. 4x4\n    bs, _, h, w = images.shape  # batch size, _, height, width\n    bs = min(bs, max_subplots)  # limit plot images\n    ns = np.ceil(bs ** 0.5)  # number of subplots (square)\n    if np.max(images[0]) <= 1:\n        images *= 255  # de-normalise (optional)\n\n    # Build Image\n    mosaic = np.full((int(ns * h), int(ns * w), 3), 255, dtype=np.uint8)  # init\n    for i, im in enumerate(images):\n        if i == max_subplots:  # if last batch has fewer images than we expect\n            break\n        x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin\n        im = im.transpose(1, 2, 0)\n        mosaic[y:y + h, x:x + w, :] = im\n\n    # Resize (optional)\n    scale = max_size / ns / max(h, w)\n    if scale < 1:\n        h = math.ceil(scale * h)\n        w = math.ceil(scale * w)\n        mosaic = cv2.resize(mosaic, tuple(int(x * ns) for x in (w, h)))\n\n    # Annotate\n    fs = int((h + w) * ns * 0.01)  # font size\n    annotator = Annotator(mosaic, line_width=round(fs / 10), font_size=fs, pil=True, example=names)\n    for i in range(i + 1):\n        x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin\n        annotator.rectangle([x, y, x + w, y + h], None, (255, 255, 255), width=2)  # borders\n        if paths:\n            annotator.text((x + 5, y + 5), text=Path(paths[i]).name[:40], txt_color=(220, 220, 220))  # filenames\n        if len(targets) > 0:\n            ti = targets[targets[:, 0] == i]  # image targets\n            boxes = xywh2xyxy(ti[:, 2:6]).T\n            classes = ti[:, 1].astype('int')\n            labels = ti.shape[1] == 6  # labels if no conf column\n            conf = None if labels else ti[:, 6]  # check for confidence presence (label vs pred)\n\n            if boxes.shape[1]:\n                if boxes.max() <= 1.01:  # if normalized with tolerance 0.01\n                    boxes[[0, 2]] *= w  # scale to pixels\n                    boxes[[1, 3]] *= h\n                elif scale < 1:  # absolute coords need scale if image scales\n                    boxes *= scale\n            boxes[[0, 2]] += x\n            boxes[[1, 3]] += y\n            for j, box in enumerate(boxes.T.tolist()):\n                cls = classes[j]\n                color = colors(cls)\n                cls = names[cls] if names else cls\n                if labels or conf[j] > 0.25:  # 0.25 conf thresh\n                    label = f'{cls}' if labels else f'{cls} {conf[j]:.1f}'\n                    annotator.box_label(box, label, color=color)\n    annotator.im.save(fname)  # save", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def plot_lr_scheduler(optimizer, scheduler, epochs=300, save_dir=''):\n    # Plot LR simulating training for full epochs\n    optimizer, scheduler = copy(optimizer), copy(scheduler)  # do not modify originals\n    y = []\n    for _ in range(epochs):\n        scheduler.step()\n        y.append(optimizer.param_groups[0]['lr'])\n    plt.plot(y, '.-', label='LR')\n    plt.xlabel('epoch')\n    plt.ylabel('LR')\n    plt.grid()\n    plt.xlim(0, epochs)\n    plt.ylim(0)\n    plt.savefig(Path(save_dir) / 'LR.png', dpi=200)\n    plt.close()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def plot_val_txt():  # from utils.plots import *; plot_val()\n    # Plot val.txt histograms\n    x = np.loadtxt('val.txt', dtype=np.float32)\n    box = xyxy2xywh(x[:, :4])\n    cx, cy = box[:, 0], box[:, 1]\n\n    fig, ax = plt.subplots(1, 1, figsize=(6, 6), tight_layout=True)\n    ax.hist2d(cx, cy, bins=600, cmax=10, cmin=0)\n    ax.set_aspect('equal')\n    plt.savefig('hist2d.png', dpi=300)\n\n    fig, ax = plt.subplots(1, 2, figsize=(12, 6), tight_layout=True)\n    ax[0].hist(cx, bins=600)\n    ax[1].hist(cy, bins=600)\n    plt.savefig('hist1d.png', dpi=200)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def plot_targets_txt():  # from utils.plots import *; plot_targets_txt()\n    # Plot targets.txt histograms\n    x = np.loadtxt('targets.txt', dtype=np.float32).T\n    s = ['x targets', 'y targets', 'width targets', 'height targets']\n    fig, ax = plt.subplots(2, 2, figsize=(8, 8), tight_layout=True)\n    ax = ax.ravel()\n    for i in range(4):\n        ax[i].hist(x[i], bins=100, label=f'{x[i].mean():.3g} +/- {x[i].std():.3g}')\n        ax[i].legend()\n        ax[i].set_title(s[i])\n    plt.savefig('targets.jpg', dpi=200)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def plot_val_study(file='', dir='', x=None):  # from utils.plots import *; plot_val_study()\n    # Plot file=study.txt generated by val.py (or plot all study*.txt in dir)\n    save_dir = Path(file).parent if file else Path(dir)\n    plot2 = False  # plot additional results\n    if plot2:\n        ax = plt.subplots(2, 4, figsize=(10, 6), tight_layout=True)[1].ravel()\n\n    fig2, ax2 = plt.subplots(1, 1, figsize=(8, 4), tight_layout=True)\n    # for f in [save_dir / f'study_coco_{x}.txt' for x in ['yolov5n6', 'yolov5s6', 'yolov5m6', 'yolov5l6', 'yolov5x6']]:\n    for f in sorted(save_dir.glob('study*.txt')):\n        y = np.loadtxt(f, dtype=np.float32, usecols=[0, 1, 2, 3, 7, 8, 9], ndmin=2).T\n        x = np.arange(y.shape[1]) if x is None else np.array(x)\n        if plot2:\n            s = ['P', 'R', 'mAP@.5', 'mAP@.5:.95', 't_preprocess (ms/img)', 't_inference (ms/img)', 't_NMS (ms/img)']\n            for i in range(7):\n                ax[i].plot(x, y[i], '.-', linewidth=2, markersize=8)\n                ax[i].set_title(s[i])\n\n        j = y[3].argmax() + 1\n        ax2.plot(y[5, 1:j],\n                 y[3, 1:j] * 1E2,\n                 '.-',\n                 linewidth=2,\n                 markersize=8,\n                 label=f.stem.replace('study_coco_', '').replace('yolo', 'YOLO'))\n\n    ax2.plot(1E3 / np.array([209, 140, 97, 58, 35, 18]), [34.6, 40.5, 43.0, 47.5, 49.7, 51.5],\n             'k.-',\n             linewidth=2,\n             markersize=8,\n             alpha=.25,\n             label='EfficientDet')\n\n    ax2.grid(alpha=0.2)\n    ax2.set_yticks(np.arange(20, 60, 5))\n    ax2.set_xlim(0, 57)\n    ax2.set_ylim(25, 55)\n    ax2.set_xlabel('GPU Speed (ms/img)')\n    ax2.set_ylabel('COCO AP val')\n    ax2.legend(loc='lower right')\n    f = save_dir / 'study.png'\n    print(f'Saving {f}...')\n    plt.savefig(f, dpi=300)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def plot_labels(labels, names=(), save_dir=Path('')):\n    # plot dataset labels\n    LOGGER.info(f\"Plotting labels to {save_dir / 'labels.jpg'}... \")\n    c, b = labels[:, 0], labels[:, 1:].transpose()  # classes, boxes\n    nc = int(c.max() + 1)  # number of classes\n    x = pd.DataFrame(b.transpose(), columns=['x', 'y', 'width', 'height'])\n\n    # seaborn correlogram\n    sn.pairplot(x, corner=True, diag_kind='auto', kind='hist', diag_kws=dict(bins=50), plot_kws=dict(pmax=0.9))\n    plt.savefig(save_dir / 'labels_correlogram.jpg', dpi=200)\n    plt.close()\n\n    # matplotlib labels\n    matplotlib.use('svg')  # faster\n    ax = plt.subplots(2, 2, figsize=(8, 8), tight_layout=True)[1].ravel()\n    y = ax[0].hist(c, bins=np.linspace(0, nc, nc + 1) - 0.5, rwidth=0.8)\n    with contextlib.suppress(Exception):  # color histogram bars by class\n        [y[2].patches[i].set_color([x / 255 for x in colors(i)]) for i in range(nc)]  # known issue #3195\n    ax[0].set_ylabel('instances')\n    if 0 < len(names) < 30:\n        ax[0].set_xticks(range(len(names)))\n        ax[0].set_xticklabels(list(names.values()), rotation=90, fontsize=10)\n    else:\n        ax[0].set_xlabel('classes')\n    sn.histplot(x, x='x', y='y', ax=ax[2], bins=50, pmax=0.9)\n    sn.histplot(x, x='width', y='height', ax=ax[3], bins=50, pmax=0.9)\n\n    # rectangles\n    labels[:, 1:3] = 0.5  # center\n    labels[:, 1:] = xywh2xyxy(labels[:, 1:]) * 2000\n    img = Image.fromarray(np.ones((2000, 2000, 3), dtype=np.uint8) * 255)\n    for cls, *box in labels[:1000]:\n        ImageDraw.Draw(img).rectangle(box, width=1, outline=colors(cls))  # plot\n    ax[1].imshow(img)\n    ax[1].axis('off')\n\n    for a in [0, 1, 2, 3]:\n        for s in ['top', 'right', 'left', 'bottom']:\n            ax[a].spines[s].set_visible(False)\n\n    plt.savefig(save_dir / 'labels.jpg', dpi=200)\n    matplotlib.use('Agg')\n    plt.close()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def imshow_cls(im, labels=None, pred=None, names=None, nmax=25, verbose=False, f=Path('images.jpg')):\n    # Show classification image grid with labels (optional) and predictions (optional)\n    from utils.augmentations import denormalize\n\n    names = names or [f'class{i}' for i in range(1000)]\n    blocks = torch.chunk(denormalize(im.clone()).cpu().float(), len(im),\n                         dim=0)  # select batch index 0, block by channels\n    n = min(len(blocks), nmax)  # number of plots\n    m = min(8, round(n ** 0.5))  # 8 x 8 default\n    fig, ax = plt.subplots(math.ceil(n / m), m)  # 8 rows x n/8 cols\n    ax = ax.ravel() if m > 1 else [ax]\n    # plt.subplots_adjust(wspace=0.05, hspace=0.05)\n    for i in range(n):\n        ax[i].imshow(blocks[i].squeeze().permute((1, 2, 0)).numpy().clip(0.0, 1.0))\n        ax[i].axis('off')\n        if labels is not None:\n            s = names[labels[i]] + (f'\u2014{names[pred[i]]}' if pred is not None else '')\n            ax[i].set_title(s, fontsize=8, verticalalignment='top')\n    plt.savefig(f, dpi=300, bbox_inches='tight')\n    plt.close()\n    if verbose:\n        LOGGER.info(f\"Saving {f}\")\n        if labels is not None:\n            LOGGER.info('True:     ' + ' '.join(f'{names[i]:3s}' for i in labels[:nmax]))\n        if pred is not None:\n            LOGGER.info('Predicted:' + ' '.join(f'{names[i]:3s}' for i in pred[:nmax]))\n    return f", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def plot_evolve(evolve_csv='path/to/evolve.csv'):  # from utils.plots import *; plot_evolve()\n    # Plot evolve.csv hyp evolution results\n    evolve_csv = Path(evolve_csv)\n    data = pd.read_csv(evolve_csv)\n    keys = [x.strip() for x in data.columns]\n    x = data.values\n    f = fitness(x)\n    j = np.argmax(f)  # max fitness index\n    plt.figure(figsize=(10, 12), tight_layout=True)\n    matplotlib.rc('font', **{'size': 8})\n    print(f'Best results from row {j} of {evolve_csv}:')\n    for i, k in enumerate(keys[7:]):\n        v = x[:, 7 + i]\n        mu = v[j]  # best single result\n        plt.subplot(6, 5, i + 1)\n        plt.scatter(v, f, c=hist2d(v, f, 20), cmap='viridis', alpha=.8, edgecolors='none')\n        plt.plot(mu, f.max(), 'k+', markersize=15)\n        plt.title(f'{k} = {mu:.3g}', fontdict={'size': 9})  # limit to 40 characters\n        if i % 5 != 0:\n            plt.yticks([])\n        print(f'{k:>15}: {mu:.3g}')\n    f = evolve_csv.with_suffix('.png')  # filename\n    plt.savefig(f, dpi=200)\n    plt.close()\n    print(f'Saved {f}')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def plot_results(file='path/to/results.csv', dir=''):\n    # Plot training results.csv. Usage: from utils.plots import *; plot_results('path/to/results.csv')\n    save_dir = Path(file).parent if file else Path(dir)\n    fig, ax = plt.subplots(2, 5, figsize=(12, 6), tight_layout=True)\n    ax = ax.ravel()\n    files = list(save_dir.glob('results*.csv'))\n    assert len(files), f'No results.csv files found in {save_dir.resolve()}, nothing to plot.'\n    for f in files:\n        try:\n            data = pd.read_csv(f)\n            s = [x.strip() for x in data.columns]\n            x = data.values[:, 0]\n            for i, j in enumerate([1, 2, 3, 4, 5, 8, 9, 10, 6, 7]):\n                y = data.values[:, j].astype('float')\n                # y[y == 0] = np.nan  # don't show zero values\n                ax[i].plot(x, y, marker='.', label=f.stem, linewidth=2, markersize=8)\n                ax[i].set_title(s[j], fontsize=12)\n                # if j in [8, 9, 10]:  # share train and val loss y axes\n                #     ax[i].get_shared_y_axes().join(ax[i], ax[i - 5])\n        except Exception as e:\n            LOGGER.info(f'Warning: Plotting error for {f}: {e}')\n    ax[1].legend()\n    fig.savefig(save_dir / 'results.png', dpi=200)\n    plt.close()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def profile_idetection(start=0, stop=0, labels=(), save_dir=''):\n    # Plot iDetection '*.txt' per-image logs. from utils.plots import *; profile_idetection()\n    ax = plt.subplots(2, 4, figsize=(12, 6), tight_layout=True)[1].ravel()\n    s = ['Images', 'Free Storage (GB)', 'RAM Usage (GB)', 'Battery', 'dt_raw (ms)', 'dt_smooth (ms)', 'real-world FPS']\n    files = list(Path(save_dir).glob('frames*.txt'))\n    for fi, f in enumerate(files):\n        try:\n            results = np.loadtxt(f, ndmin=2).T[:, 90:-30]  # clip first and last rows\n            n = results.shape[1]  # number of rows\n            x = np.arange(start, min(stop, n) if stop else n)\n            results = results[:, x]\n            t = (results[0] - results[0].min())  # set t0=0s\n            results[0] = x\n            for i, a in enumerate(ax):\n                if i < len(results):\n                    label = labels[fi] if len(labels) else f.stem.replace('frames_', '')\n                    a.plot(t, results[i], marker='.', label=label, linewidth=1, markersize=5)\n                    a.set_title(s[i])\n                    a.set_xlabel('time (s)')\n                    # if fi == len(files) - 1:\n                    #     a.set_ylim(bottom=0)\n                    for side in ['top', 'right']:\n                        a.spines[side].set_visible(False)\n                else:\n                    a.remove()\n        except Exception as e:\n            print(f'Warning: Plotting error for {f}; {e}')\n    ax[1].legend()\n    plt.savefig(Path(save_dir) / 'idetection_profile.png', dpi=200)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def save_one_box(xyxy, im, file=Path('im.jpg'), gain=1.02, pad=10, square=False, BGR=False, save=True):\n    # Save image crop as {file} with crop size multiple {gain} and {pad} pixels. Save and/or return crop\n    xyxy = torch.tensor(xyxy).view(-1, 4)\n    b = xyxy2xywh(xyxy)  # boxes\n    if square:\n        b[:, 2:] = b[:, 2:].max(1)[0].unsqueeze(1)  # attempt rectangle to square\n    b[:, 2:] = b[:, 2:] * gain + pad  # box wh * gain + pad\n    xyxy = xywh2xyxy(b).long()\n    clip_boxes(xyxy, im.shape)\n    crop = im[int(xyxy[0, 1]):int(xyxy[0, 3]), int(xyxy[0, 0]):int(xyxy[0, 2]), ::(1 if BGR else -1)]\n    if save:\n        file.parent.mkdir(parents=True, exist_ok=True)  # make directory\n        f = str(increment_path(file).with_suffix('.jpg'))\n        # cv2.imwrite(f, crop)  # save BGR, https://github.com/ultralytics/yolov5/issues/7007 chroma subsampling issue\n        Image.fromarray(crop[..., ::-1]).save(f, quality=95, subsampling=0)  # save RGB\n    return crop", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self):\n        # hex = matplotlib.colors.TABLEAU_COLORS.values()\n        hexs = ('FF3838', 'FF9D97', 'FF701F', 'FFB21D', 'CFD231', '48F90A', '92CC17', '3DDB86', '1A9334', '00D4BB',\n                '2C99A8', '00C2FF', '344593', '6473FF', '0018EC', '8438FF', '520085', 'CB38FF', 'FF95C8', 'FF37C7')\n        self.palette = [self.hex2rgb(f'#{c}') for c in hexs]\n        self.n = len(self.palette)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __call__(self, i, bgr=False):\n        c = self.palette[int(i) % self.n]\n        return (c[2], c[1], c[0]) if bgr else c", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def hex2rgb(h):  # rgb order (PIL)\n        return tuple(int(h[1 + i:1 + i + 2], 16) for i in (0, 2, 4))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, im, line_width=None, font_size=None, font='Arial.ttf', pil=False, example='abc'):\n        assert im.data.contiguous, 'Image not contiguous. Apply np.ascontiguousarray(im) to Annotator() input images.'\n        non_ascii = not is_ascii(example)  # non-latin labels, i.e. asian, arabic, cyrillic\n        self.pil = pil or non_ascii\n        if self.pil:  # use PIL\n            self.im = im if isinstance(im, Image.Image) else Image.fromarray(im)\n            self.draw = ImageDraw.Draw(self.im)\n            self.font = check_pil_font(font='Arial.Unicode.ttf' if non_ascii else font,\n                                       size=font_size or max(round(sum(self.im.size) / 2 * 0.035), 12))\n        else:  # use cv2\n            self.im = im\n        self.lw = line_width or max(round(sum(im.shape) / 2 * 0.003), 2)  # line width", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def box_label(self, box, label='', color=(128, 128, 128), txt_color=(255, 255, 255)):\n        # Add one xyxy box to image with label\n        if self.pil or not is_ascii(label):\n            self.draw.rectangle(box, width=self.lw, outline=color)  # box\n            if label:\n                w, h = self.font.getsize(label)  # text width, height\n                outside = box[1] - h >= 0  # label fits outside box\n                self.draw.rectangle(\n                    (box[0], box[1] - h if outside else box[1], box[0] + w + 1,\n                     box[1] + 1 if outside else box[1] + h + 1),\n                    fill=color,\n                )\n                # self.draw.text((box[0], box[1]), label, fill=txt_color, font=self.font, anchor='ls')  # for PIL>8.0\n                self.draw.text((box[0], box[1] - h if outside else box[1]), label, fill=txt_color, font=self.font)\n        else:  # cv2\n            p1, p2 = (int(box[0]), int(box[1])), (int(box[2]), int(box[3]))\n            cv2.rectangle(self.im, p1, p2, color, thickness=self.lw, lineType=cv2.LINE_AA)\n            if label:\n                tf = max(self.lw - 1, 1)  # font thickness\n                w, h = cv2.getTextSize(label, 0, fontScale=self.lw / 3, thickness=tf)[0]  # text width, height\n                outside = p1[1] - h >= 3\n                p2 = p1[0] + w, p1[1] - h - 3 if outside else p1[1] + h + 3\n                cv2.rectangle(self.im, p1, p2, color, -1, cv2.LINE_AA)  # filled\n                cv2.putText(self.im,\n                            label, (p1[0], p1[1] - 2 if outside else p1[1] + h + 2),\n                            0,\n                            self.lw / 3,\n                            txt_color,\n                            thickness=tf,\n                            lineType=cv2.LINE_AA)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def masks(self, masks, colors, im_gpu=None, alpha=0.5):\n        \"\"\"Plot masks at once.\n        Args:\n            masks (tensor): predicted masks on cuda, shape: [n, h, w]\n            colors (List[List[Int]]): colors for predicted masks, [[r, g, b] * n]\n            im_gpu (tensor): img is in cuda, shape: [3, h, w], range: [0, 1]\n            alpha (float): mask transparency: 0.0 fully transparent, 1.0 opaque\n        \"\"\"\n        if self.pil:\n            # convert to numpy first\n            self.im = np.asarray(self.im).copy()\n        if im_gpu is None:\n            # Add multiple masks of shape(h,w,n) with colors list([r,g,b], [r,g,b], ...)\n            if len(masks) == 0:\n                return\n            if isinstance(masks, torch.Tensor):\n                masks = torch.as_tensor(masks, dtype=torch.uint8)\n                masks = masks.permute(1, 2, 0).contiguous()\n                masks = masks.cpu().numpy()\n            # masks = np.ascontiguousarray(masks.transpose(1, 2, 0))\n            masks = scale_image(masks.shape[:2], masks, self.im.shape)\n            masks = np.asarray(masks, dtype=np.float32)\n            colors = np.asarray(colors, dtype=np.float32)  # shape(n,3)\n            s = masks.sum(2, keepdims=True).clip(0, 1)  # add all masks together\n            masks = (masks @ colors).clip(0, 255)  # (h,w,n) @ (n,3) = (h,w,3)\n            self.im[:] = masks * alpha + self.im * (1 - s * alpha)\n        else:\n            if len(masks) == 0:\n                self.im[:] = im_gpu.permute(1, 2, 0).contiguous().cpu().numpy() * 255\n            colors = torch.tensor(colors, device=im_gpu.device, dtype=torch.float32) / 255.0\n            colors = colors[:, None, None]  # shape(n,1,1,3)\n            masks = masks.unsqueeze(3)  # shape(n,h,w,1)\n            masks_color = masks * (colors * alpha)  # shape(n,h,w,3)\n\n            inv_alph_masks = (1 - masks * alpha).cumprod(0)  # shape(n,h,w,1)\n            mcs = (masks_color * inv_alph_masks).sum(0) * 2  # mask color summand shape(n,h,w,3)\n\n            im_gpu = im_gpu.flip(dims=[0])  # flip channel\n            im_gpu = im_gpu.permute(1, 2, 0).contiguous()  # shape(h,w,3)\n            im_gpu = im_gpu * inv_alph_masks[-1] + mcs\n            im_mask = (im_gpu * 255).byte().cpu().numpy()\n            self.im[:] = scale_image(im_gpu.shape, im_mask, self.im.shape)\n        if self.pil:\n            # convert im back to PIL and update draw\n            self.fromarray(self.im)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def rectangle(self, xy, fill=None, outline=None, width=1):\n        # Add rectangle to image (PIL-only)\n        self.draw.rectangle(xy, fill, outline, width)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def text(self, xy, text, txt_color=(255, 255, 255), anchor='top'):\n        # Add text to image (PIL-only)\n        if anchor == 'bottom':  # start y from font bottom\n            w, h = self.font.getsize(text)  # text width, height\n            xy[1] += 1 - h\n        self.draw.text(xy, text, fill=txt_color, font=self.font)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def fromarray(self, im):\n        # Update self.im from a numpy array\n        self.im = im if isinstance(im, Image.Image) else Image.fromarray(im)\n        self.draw = ImageDraw.Draw(self.im)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def result(self):\n        # Return annotated image as array\n        return np.asarray(self.im)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def butter_lowpass(cutoff, fs, order):\n        nyq = 0.5 * fs\n        normal_cutoff = cutoff / nyq\n        return butter(order, normal_cutoff, btype='low', analog=False)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self):\n        # Define the available callbacks\n        self._callbacks = {\n            'on_pretrain_routine_start': [],\n            'on_pretrain_routine_end': [],\n            'on_train_start': [],\n            'on_train_epoch_start': [],\n            'on_train_batch_start': [],\n            'optimizer_step': [],\n            'on_before_zero_grad': [],\n            'on_train_batch_end': [],\n            'on_train_epoch_end': [],\n            'on_val_start': [],\n            'on_val_batch_start': [],\n            'on_val_image_end': [],\n            'on_val_batch_end': [],\n            'on_val_end': [],\n            'on_fit_epoch_end': [],  # fit = train + val\n            'on_model_save': [],\n            'on_train_end': [],\n            'on_params_update': [],\n            'teardown': [],}\n        self.stop_training = False  # set True to interrupt training", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def register_action(self, hook, name='', callback=None):\n        \"\"\"\n        Register a new action to a callback hook\n\n        Args:\n            hook: The callback hook name to register the action to\n            name: The name of the action for later reference\n            callback: The callback to fire\n        \"\"\"\n        assert hook in self._callbacks, f\"hook '{hook}' not found in callbacks {self._callbacks}\"\n        assert callable(callback), f\"callback '{callback}' is not callable\"\n        self._callbacks[hook].append({'name': name, 'callback': callback})", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def get_registered_actions(self, hook=None):\n        \"\"\"\"\n        Returns all the registered actions by callback hook\n\n        Args:\n            hook: The name of the hook to check, defaults to all\n        \"\"\"\n        return self._callbacks[hook] if hook else self._callbacks", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def run(self, hook, *args, thread=False, **kwargs):\n        \"\"\"\n        Loop through the registered actions and fire all callbacks on main thread\n\n        Args:\n            hook: The name of the hook to check, defaults to all\n            args: Arguments to receive from YOLOv5\n            thread: (boolean) Run callbacks in daemon thread\n            kwargs: Keyword Arguments to receive from YOLOv5\n        \"\"\"\n\n        assert hook in self._callbacks, f\"hook '{hook}' not found in callbacks {self._callbacks}\"\n        for logger in self._callbacks[hook]:\n            if thread:\n                threading.Thread(target=logger['callback'], args=args, kwargs=kwargs, daemon=True).start()\n            else:\n                logger['callback'](*args, **kwargs)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def predict(model):\n    if request.method != \"POST\":\n        return\n\n    if request.files.get(\"image\"):\n        # Method 1\n        # with request.files[\"image\"] as f:\n        #     im = Image.open(io.BytesIO(f.read()))\n\n        # Method 2\n        im_file = request.files[\"image\"]\n        im_bytes = im_file.read()\n        im = Image.open(io.BytesIO(im_bytes))\n\n        if model in models:\n            results = models[model](im, size=640)  # reduce size=320 for faster inference\n            return results.pandas().xyxy[0].to_json(orient=\"records\")", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_anchor_order(m):\n    # Check anchor order against stride order for YOLOv5 Detect() module m, and correct if necessary\n    a = m.anchors.prod(-1).mean(-1).view(-1)  # mean anchor area per output layer\n    da = a[-1] - a[0]  # delta a\n    ds = m.stride[-1] - m.stride[0]  # delta s\n    if da and (da.sign() != ds.sign()):  # same order\n        LOGGER.info(f'{PREFIX}Reversing anchor order')\n        m.anchors[:] = m.anchors.flip(0)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_anchors(dataset, model, thr=4.0, imgsz=640):\n    # Check anchor fit to data, recompute if necessary\n    m = model.module.model[-1] if hasattr(model, 'module') else model.model[-1]  # Detect()\n    shapes = imgsz * dataset.shapes / dataset.shapes.max(1, keepdims=True)\n    scale = np.random.uniform(0.9, 1.1, size=(shapes.shape[0], 1))  # augment scale\n    wh = torch.tensor(np.concatenate([l[:, 3:5] * s for s, l in zip(shapes * scale, dataset.labels)])).float()  # wh\n\n    def metric(k):  # compute metric\n        r = wh[:, None] / k[None]\n        x = torch.min(r, 1 / r).min(2)[0]  # ratio metric\n        best = x.max(1)[0]  # best_x\n        aat = (x > 1 / thr).float().sum(1).mean()  # anchors above threshold\n        bpr = (best > 1 / thr).float().mean()  # best possible recall\n        return bpr, aat\n\n    stride = m.stride.to(m.anchors.device).view(-1, 1, 1)  # model strides\n    anchors = m.anchors.clone() * stride  # current anchors\n    bpr, aat = metric(anchors.cpu().view(-1, 2))\n    s = f'\\n{PREFIX}{aat:.2f} anchors/target, {bpr:.3f} Best Possible Recall (BPR). '\n    if bpr > 0.98:  # threshold to recompute\n        LOGGER.info(f'{s}Current anchors are a good fit to dataset \u2705')\n    else:\n        LOGGER.info(f'{s}Anchors are a poor fit to dataset \u26a0\ufe0f, attempting to improve...')\n        na = m.anchors.numel() // 2  # number of anchors\n        anchors = kmean_anchors(dataset, n=na, img_size=imgsz, thr=thr, gen=1000, verbose=False)\n        new_bpr = metric(anchors)[0]\n        if new_bpr > bpr:  # replace anchors\n            anchors = torch.tensor(anchors, device=m.anchors.device).type_as(m.anchors)\n            m.anchors[:] = anchors.clone().view_as(m.anchors)\n            check_anchor_order(m)  # must be in pixel-space (not grid-space)\n            m.anchors /= stride\n            s = f'{PREFIX}Done \u2705 (optional: update model *.yaml to use these anchors in the future)'\n        else:\n            s = f'{PREFIX}Done \u26a0\ufe0f (original anchors better than new anchors, proceeding with original anchors)'\n        LOGGER.info(s)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def kmean_anchors(dataset='./data/coco128.yaml', n=9, img_size=640, thr=4.0, gen=1000, verbose=True):\n    \"\"\" Creates kmeans-evolved anchors from training dataset\n\n        Arguments:\n            dataset: path to data.yaml, or a loaded dataset\n            n: number of anchors\n            img_size: image size used for training\n            thr: anchor-label wh ratio threshold hyperparameter hyp['anchor_t'] used for training, default=4.0\n            gen: generations to evolve anchors using genetic algorithm\n            verbose: print all results\n\n        Return:\n            k: kmeans evolved anchors\n\n        Usage:\n            from utils.autoanchor import *; _ = kmean_anchors()\n    \"\"\"\n    from scipy.cluster.vq import kmeans\n\n    npr = np.random\n    thr = 1 / thr\n\n    def metric(k, wh):  # compute metrics\n        r = wh[:, None] / k[None]\n        x = torch.min(r, 1 / r).min(2)[0]  # ratio metric\n        # x = wh_iou(wh, torch.tensor(k))  # iou metric\n        return x, x.max(1)[0]  # x, best_x\n\n    def anchor_fitness(k):  # mutation fitness\n        _, best = metric(torch.tensor(k, dtype=torch.float32), wh)\n        return (best * (best > thr).float()).mean()  # fitness\n\n    def print_results(k, verbose=True):\n        k = k[np.argsort(k.prod(1))]  # sort small to large\n        x, best = metric(k, wh0)\n        bpr, aat = (best > thr).float().mean(), (x > thr).float().mean() * n  # best possible recall, anch > thr\n        s = f'{PREFIX}thr={thr:.2f}: {bpr:.4f} best possible recall, {aat:.2f} anchors past thr\\n' \\\n            f'{PREFIX}n={n}, img_size={img_size}, metric_all={x.mean():.3f}/{best.mean():.3f}-mean/best, ' \\\n            f'past_thr={x[x > thr].mean():.3f}-mean: '\n        for x in k:\n            s += '%i,%i, ' % (round(x[0]), round(x[1]))\n        if verbose:\n            LOGGER.info(s[:-2])\n        return k\n\n    if isinstance(dataset, str):  # *.yaml file\n        with open(dataset, errors='ignore') as f:\n            data_dict = yaml.safe_load(f)  # model dict\n        from utils.dataloaders import LoadImagesAndLabels\n        dataset = LoadImagesAndLabels(data_dict['train'], augment=True, rect=True)\n\n    # Get label wh\n    shapes = img_size * dataset.shapes / dataset.shapes.max(1, keepdims=True)\n    wh0 = np.concatenate([l[:, 3:5] * s for s, l in zip(shapes, dataset.labels)])  # wh\n\n    # Filter\n    i = (wh0 < 3.0).any(1).sum()\n    if i:\n        LOGGER.info(f'{PREFIX}WARNING \u26a0\ufe0f Extremely small objects found: {i} of {len(wh0)} labels are <3 pixels in size')\n    wh = wh0[(wh0 >= 2.0).any(1)].astype(np.float32)  # filter > 2 pixels\n    # wh = wh * (npr.rand(wh.shape[0], 1) * 0.9 + 0.1)  # multiply by random scale 0-1\n\n    # Kmeans init\n    try:\n        LOGGER.info(f'{PREFIX}Running kmeans for {n} anchors on {len(wh)} points...')\n        assert n <= len(wh)  # apply overdetermined constraint\n        s = wh.std(0)  # sigmas for whitening\n        k = kmeans(wh / s, n, iter=30)[0] * s  # points\n        assert n == len(k)  # kmeans may return fewer points than requested if wh is insufficient or too similar\n    except Exception:\n        LOGGER.warning(f'{PREFIX}WARNING \u26a0\ufe0f switching strategies from kmeans to random init')\n        k = np.sort(npr.rand(n * 2)).reshape(n, 2) * img_size  # random init\n    wh, wh0 = (torch.tensor(x, dtype=torch.float32) for x in (wh, wh0))\n    k = print_results(k, verbose=False)\n\n    # Plot\n    # k, d = [None] * 20, [None] * 20\n    # for i in tqdm(range(1, 21)):\n    #     k[i-1], d[i-1] = kmeans(wh / s, i)  # points, mean distance\n    # fig, ax = plt.subplots(1, 2, figsize=(14, 7), tight_layout=True)\n    # ax = ax.ravel()\n    # ax[0].plot(np.arange(1, 21), np.array(d) ** 2, marker='.')\n    # fig, ax = plt.subplots(1, 2, figsize=(14, 7))  # plot wh\n    # ax[0].hist(wh[wh[:, 0]<100, 0],400)\n    # ax[1].hist(wh[wh[:, 1]<100, 1],400)\n    # fig.savefig('wh.png', dpi=200)\n\n    # Evolve\n    f, sh, mp, s = anchor_fitness(k), k.shape, 0.9, 0.1  # fitness, generations, mutation prob, sigma\n    pbar = tqdm(range(gen), bar_format=TQDM_BAR_FORMAT)  # progress bar\n    for _ in pbar:\n        v = np.ones(sh)\n        while (v == 1).all():  # mutate until a change occurs (prevent duplicates)\n            v = ((npr.random(sh) < mp) * random.random() * npr.randn(*sh) * s + 1).clip(0.3, 3.0)\n        kg = (k.copy() * v).clip(min=2.0)\n        fg = anchor_fitness(kg)\n        if fg > f:\n            f, k = fg, kg.copy()\n            pbar.desc = f'{PREFIX}Evolving anchors with Genetic Algorithm: fitness = {f:.4f}'\n            if verbose:\n                print_results(k, verbose)\n\n    return print_results(k).astype(np.float32)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def metric(k):  # compute metric\n        r = wh[:, None] / k[None]\n        x = torch.min(r, 1 / r).min(2)[0]  # ratio metric\n        best = x.max(1)[0]  # best_x\n        aat = (x > 1 / thr).float().sum(1).mean()  # anchors above threshold\n        bpr = (best > 1 / thr).float().mean()  # best possible recall\n        return bpr, aat", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def metric(k, wh):  # compute metrics\n        r = wh[:, None] / k[None]\n        x = torch.min(r, 1 / r).min(2)[0]  # ratio metric\n        # x = wh_iou(wh, torch.tensor(k))  # iou metric\n        return x, x.max(1)[0]  # x, best_x", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def anchor_fitness(k):  # mutation fitness\n        _, best = metric(torch.tensor(k, dtype=torch.float32), wh)\n        return (best * (best > thr).float()).mean()  # fitness", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def print_results(k, verbose=True):\n        k = k[np.argsort(k.prod(1))]  # sort small to large\n        x, best = metric(k, wh0)\n        bpr, aat = (best > thr).float().mean(), (x > thr).float().mean() * n  # best possible recall, anch > thr\n        s = f'{PREFIX}thr={thr:.2f}: {bpr:.4f} best possible recall, {aat:.2f} anchors past thr\\n' \\\n            f'{PREFIX}n={n}, img_size={img_size}, metric_all={x.mean():.3f}/{best.mean():.3f}-mean/best, ' \\\n            f'past_thr={x[x > thr].mean():.3f}-mean: '\n        for x in k:\n            s += '%i,%i, ' % (round(x[0]), round(x[1]))\n        if verbose:\n            LOGGER.info(s[:-2])\n        return k", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def smart_inference_mode(torch_1_9=check_version(torch.__version__, '1.9.0')):\n    # Applies torch.inference_mode() decorator if torch>=1.9.0 else torch.no_grad() decorator\n    def decorate(fn):\n        return (torch.inference_mode if torch_1_9 else torch.no_grad)()(fn)\n\n    return decorate", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def smartCrossEntropyLoss(label_smoothing=0.0):\n    # Returns nn.CrossEntropyLoss with label smoothing enabled for torch>=1.10.0\n    if check_version(torch.__version__, '1.10.0'):\n        return nn.CrossEntropyLoss(label_smoothing=label_smoothing)\n    if label_smoothing > 0:\n        LOGGER.warning(f'WARNING \u26a0\ufe0f label smoothing {label_smoothing} requires torch>=1.10.0')\n    return nn.CrossEntropyLoss()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def smart_DDP(model):\n    # Model DDP creation with checks\n    assert not check_version(torch.__version__, '1.12.0', pinned=True), \\\n        'torch==1.12.0 torchvision==0.13.0 DDP training is not supported due to a known issue. ' \\\n        'Please upgrade or downgrade torch to use DDP. See https://github.com/ultralytics/yolov5/issues/8395'\n    if check_version(torch.__version__, '1.11.0'):\n        return DDP(model, device_ids=[LOCAL_RANK], output_device=LOCAL_RANK, static_graph=True)\n    else:\n        return DDP(model, device_ids=[LOCAL_RANK], output_device=LOCAL_RANK)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def reshape_classifier_output(model, n=1000):\n    # Update a TorchVision classification model to class count 'n' if required\n    from models.common import Classify\n    name, m = list((model.model if hasattr(model, 'model') else model).named_children())[-1]  # last module\n    if isinstance(m, Classify):  # YOLOv5 Classify() head\n        if m.linear.out_features != n:\n            m.linear = nn.Linear(m.linear.in_features, n)\n    elif isinstance(m, nn.Linear):  # ResNet, EfficientNet\n        if m.out_features != n:\n            setattr(model, name, nn.Linear(m.in_features, n))\n    elif isinstance(m, nn.Sequential):\n        types = [type(x) for x in m]\n        if nn.Linear in types:\n            i = types.index(nn.Linear)  # nn.Linear index\n            if m[i].out_features != n:\n                m[i] = nn.Linear(m[i].in_features, n)\n        elif nn.Conv2d in types:\n            i = types.index(nn.Conv2d)  # nn.Conv2d index\n            if m[i].out_channels != n:\n                m[i] = nn.Conv2d(m[i].in_channels, n, m[i].kernel_size, m[i].stride, bias=m[i].bias is not None)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def torch_distributed_zero_first(local_rank: int):\n    # Decorator to make all processes in distributed training wait for each local_master to do something\n    if local_rank not in [-1, 0]:\n        dist.barrier(device_ids=[local_rank])\n    yield\n    if local_rank == 0:\n        dist.barrier(device_ids=[0])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def device_count():\n    # Returns number of CUDA devices available. Safe version of torch.cuda.device_count(). Supports Linux and Windows\n    assert platform.system() in ('Linux', 'Windows'), 'device_count() only supported on Linux or Windows'\n    try:\n        cmd = 'nvidia-smi -L | wc -l' if platform.system() == 'Linux' else 'nvidia-smi -L | find /c /v \"\"'  # Windows\n        return int(subprocess.run(cmd, shell=True, capture_output=True, check=True).stdout.decode().split()[-1])\n    except Exception:\n        return 0", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def select_device(device='', batch_size=0, newline=True):\n    # device = None or 'cpu' or 0 or '0' or '0,1,2,3'\n    s = f'YOLOv5 \ud83d\ude80 {git_describe() or file_date()} Python-{platform.python_version()} torch-{torch.__version__} '\n    device = str(device).strip().lower().replace('cuda:', '').replace('none', '')  # to string, 'cuda:0' to '0'\n    cpu = device == 'cpu'\n    mps = device == 'mps'  # Apple Metal Performance Shaders (MPS)\n    if cpu or mps:\n        os.environ['CUDA_VISIBLE_DEVICES'] = '-1'  # force torch.cuda.is_available() = False\n    elif device:  # non-cpu device requested\n        os.environ['CUDA_VISIBLE_DEVICES'] = device  # set environment variable - must be before assert is_available()\n        assert torch.cuda.is_available() and torch.cuda.device_count() >= len(device.replace(',', '')), \\\n            f\"Invalid CUDA '--device {device}' requested, use '--device cpu' or pass valid CUDA device(s)\"\n\n    if not cpu and not mps and torch.cuda.is_available():  # prefer GPU if available\n        devices = device.split(',') if device else '0'  # range(torch.cuda.device_count())  # i.e. 0,1,6,7\n        n = len(devices)  # device count\n        if n > 1 and batch_size > 0:  # check batch_size is divisible by device_count\n            assert batch_size % n == 0, f'batch-size {batch_size} not multiple of GPU count {n}'\n        space = ' ' * (len(s) + 1)\n        for i, d in enumerate(devices):\n            p = torch.cuda.get_device_properties(i)\n            s += f\"{'' if i == 0 else space}CUDA:{d} ({p.name}, {p.total_memory / (1 << 20):.0f}MiB)\\n\"  # bytes to MB\n        arg = 'cuda:0'\n    elif mps and getattr(torch, 'has_mps', False) and torch.backends.mps.is_available():  # prefer MPS if available\n        s += 'MPS\\n'\n        arg = 'mps'\n    else:  # revert to CPU\n        s += 'CPU\\n'\n        arg = 'cpu'\n\n    if not newline:\n        s = s.rstrip()\n    LOGGER.info(s)\n    return torch.device(arg)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def time_sync():\n    # PyTorch-accurate time\n    if torch.cuda.is_available():\n        torch.cuda.synchronize()\n    return time.time()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def profile(input, ops, n=10, device=None):\n    \"\"\" YOLOv5 speed/memory/FLOPs profiler\n    Usage:\n        input = torch.randn(16, 3, 640, 640)\n        m1 = lambda x: x * torch.sigmoid(x)\n        m2 = nn.SiLU()\n        profile(input, [m1, m2], n=100)  # profile over 100 iterations\n    \"\"\"\n    results = []\n    if not isinstance(device, torch.device):\n        device = select_device(device)\n    print(f\"{'Params':>12s}{'GFLOPs':>12s}{'GPU_mem (GB)':>14s}{'forward (ms)':>14s}{'backward (ms)':>14s}\"\n          f\"{'input':>24s}{'output':>24s}\")\n\n    for x in input if isinstance(input, list) else [input]:\n        x = x.to(device)\n        x.requires_grad = True\n        for m in ops if isinstance(ops, list) else [ops]:\n            m = m.to(device) if hasattr(m, 'to') else m  # device\n            m = m.half() if hasattr(m, 'half') and isinstance(x, torch.Tensor) and x.dtype is torch.float16 else m\n            tf, tb, t = 0, 0, [0, 0, 0]  # dt forward, backward\n            try:\n                flops = thop.profile(m, inputs=(x,), verbose=False)[0] / 1E9 * 2  # GFLOPs\n            except Exception:\n                flops = 0\n\n            try:\n                for _ in range(n):\n                    t[0] = time_sync()\n                    y = m(x)\n                    t[1] = time_sync()\n                    try:\n                        _ = (sum(yi.sum() for yi in y) if isinstance(y, list) else y).sum().backward()\n                        t[2] = time_sync()\n                    except Exception:  # no backward method\n                        # print(e)  # for debug\n                        t[2] = float('nan')\n                    tf += (t[1] - t[0]) * 1000 / n  # ms per op forward\n                    tb += (t[2] - t[1]) * 1000 / n  # ms per op backward\n                mem = torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0  # (GB)\n                s_in, s_out = (tuple(x.shape) if isinstance(x, torch.Tensor) else 'list' for x in (x, y))  # shapes\n                p = sum(x.numel() for x in m.parameters()) if isinstance(m, nn.Module) else 0  # parameters\n                print(f'{p:12}{flops:12.4g}{mem:>14.3f}{tf:14.4g}{tb:14.4g}{str(s_in):>24s}{str(s_out):>24s}')\n                results.append([p, flops, mem, tf, tb, s_in, s_out])\n            except Exception as e:\n                print(e)\n                results.append(None)\n            torch.cuda.empty_cache()\n    return results", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def is_parallel(model):\n    # Returns True if model is of type DP or DDP\n    return type(model) in (nn.parallel.DataParallel, nn.parallel.DistributedDataParallel)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def de_parallel(model):\n    # De-parallelize a model: returns single-GPU model if model is of type DP or DDP\n    return model.module if is_parallel(model) else model", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def initialize_weights(model):\n    for m in model.modules():\n        t = type(m)\n        if t is nn.Conv2d:\n            pass  # nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')\n        elif t is nn.BatchNorm2d:\n            m.eps = 1e-3\n            m.momentum = 0.03\n        elif t in [nn.Hardswish, nn.LeakyReLU, nn.ReLU, nn.ReLU6, nn.SiLU]:\n            m.inplace = True", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def find_modules(model, mclass=nn.Conv2d):\n    # Finds layer indices matching module class 'mclass'\n    return [i for i, m in enumerate(model.module_list) if isinstance(m, mclass)]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def sparsity(model):\n    # Return global model sparsity\n    a, b = 0, 0\n    for p in model.parameters():\n        a += p.numel()\n        b += (p == 0).sum()\n    return b / a", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def prune(model, amount=0.3):\n    # Prune model to requested global sparsity\n    import torch.nn.utils.prune as prune\n    for name, m in model.named_modules():\n        if isinstance(m, nn.Conv2d):\n            prune.l1_unstructured(m, name='weight', amount=amount)  # prune\n            prune.remove(m, 'weight')  # make permanent\n    LOGGER.info(f'Model pruned to {sparsity(model):.3g} global sparsity')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def fuse_conv_and_bn(conv, bn):\n    # Fuse Conv2d() and BatchNorm2d() layers https://tehnokv.com/posts/fusing-batchnorm-and-conv/\n    fusedconv = nn.Conv2d(conv.in_channels,\n                          conv.out_channels,\n                          kernel_size=conv.kernel_size,\n                          stride=conv.stride,\n                          padding=conv.padding,\n                          dilation=conv.dilation,\n                          groups=conv.groups,\n                          bias=True).requires_grad_(False).to(conv.weight.device)\n\n    # Prepare filters\n    w_conv = conv.weight.clone().view(conv.out_channels, -1)\n    w_bn = torch.diag(bn.weight.div(torch.sqrt(bn.eps + bn.running_var)))\n    fusedconv.weight.copy_(torch.mm(w_bn, w_conv).view(fusedconv.weight.shape))\n\n    # Prepare spatial bias\n    b_conv = torch.zeros(conv.weight.size(0), device=conv.weight.device) if conv.bias is None else conv.bias\n    b_bn = bn.bias - bn.weight.mul(bn.running_mean).div(torch.sqrt(bn.running_var + bn.eps))\n    fusedconv.bias.copy_(torch.mm(w_bn, b_conv.reshape(-1, 1)).reshape(-1) + b_bn)\n\n    return fusedconv", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def model_info(model, verbose=False, imgsz=640):\n    # Model information. img_size may be int or list, i.e. img_size=640 or img_size=[640, 320]\n    n_p = sum(x.numel() for x in model.parameters())  # number parameters\n    n_g = sum(x.numel() for x in model.parameters() if x.requires_grad)  # number gradients\n    if verbose:\n        print(f\"{'layer':>5} {'name':>40} {'gradient':>9} {'parameters':>12} {'shape':>20} {'mu':>10} {'sigma':>10}\")\n        for i, (name, p) in enumerate(model.named_parameters()):\n            name = name.replace('module_list.', '')\n            print('%5g %40s %9s %12g %20s %10.3g %10.3g' %\n                  (i, name, p.requires_grad, p.numel(), list(p.shape), p.mean(), p.std()))\n\n    try:  # FLOPs\n        p = next(model.parameters())\n        stride = max(int(model.stride.max()), 32) if hasattr(model, 'stride') else 32  # max stride\n        im = torch.empty((1, p.shape[1], stride, stride), device=p.device)  # input image in BCHW format\n        flops = thop.profile(deepcopy(model), inputs=(im,), verbose=False)[0] / 1E9 * 2  # stride GFLOPs\n        imgsz = imgsz if isinstance(imgsz, list) else [imgsz, imgsz]  # expand if int/float\n        fs = f', {flops * imgsz[0] / stride * imgsz[1] / stride:.1f} GFLOPs'  # 640x640 GFLOPs\n    except Exception:\n        fs = ''\n\n    name = Path(model.yaml_file).stem.replace('yolov5', 'YOLOv5') if hasattr(model, 'yaml_file') else 'Model'\n    LOGGER.info(f\"{name} summary: {len(list(model.modules()))} layers, {n_p} parameters, {n_g} gradients{fs}\")", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def scale_img(img, ratio=1.0, same_shape=False, gs=32):  # img(16,3,256,416)\n    # Scales img(bs,3,y,x) by ratio constrained to gs-multiple\n    if ratio == 1.0:\n        return img\n    h, w = img.shape[2:]\n    s = (int(h * ratio), int(w * ratio))  # new size\n    img = F.interpolate(img, size=s, mode='bilinear', align_corners=False)  # resize\n    if not same_shape:  # pad/crop img\n        h, w = (math.ceil(x * ratio / gs) * gs for x in (h, w))\n    return F.pad(img, [0, w - s[1], 0, h - s[0]], value=0.447)  # value = imagenet mean", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def copy_attr(a, b, include=(), exclude=()):\n    # Copy attributes from b to a, options to only include [...] and to exclude [...]\n    for k, v in b.__dict__.items():\n        if (len(include) and k not in include) or k.startswith('_') or k in exclude:\n            continue\n        else:\n            setattr(a, k, v)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def smart_optimizer(model, name='Adam', lr=0.001, momentum=0.9, decay=1e-5):\n    # YOLOv5 3-param group optimizer: 0) weights with decay, 1) weights no decay, 2) biases no decay\n    g = [], [], []  # optimizer parameter groups\n    bn = tuple(v for k, v in nn.__dict__.items() if 'Norm' in k)  # normalization layers, i.e. BatchNorm2d()\n    for v in model.modules():\n        for p_name, p in v.named_parameters(recurse=0):\n            if p_name == 'bias':  # bias (no decay)\n                g[2].append(p)\n            elif p_name == 'weight' and isinstance(v, bn):  # weight (no decay)\n                g[1].append(p)\n            else:\n                g[0].append(p)  # weight (with decay)\n\n    if name == 'Adam':\n        optimizer = torch.optim.Adam(g[2], lr=lr, betas=(momentum, 0.999))  # adjust beta1 to momentum\n    elif name == 'AdamW':\n        optimizer = torch.optim.AdamW(g[2], lr=lr, betas=(momentum, 0.999), weight_decay=0.0)\n    elif name == 'RMSProp':\n        optimizer = torch.optim.RMSprop(g[2], lr=lr, momentum=momentum)\n    elif name == 'SGD':\n        optimizer = torch.optim.SGD(g[2], lr=lr, momentum=momentum, nesterov=True)\n    else:\n        raise NotImplementedError(f'Optimizer {name} not implemented.')\n\n    optimizer.add_param_group({'params': g[0], 'weight_decay': decay})  # add g0 with weight_decay\n    optimizer.add_param_group({'params': g[1], 'weight_decay': 0.0})  # add g1 (BatchNorm2d weights)\n    LOGGER.info(f\"{colorstr('optimizer:')} {type(optimizer).__name__}(lr={lr}) with parameter groups \"\n                f\"{len(g[1])} weight(decay=0.0), {len(g[0])} weight(decay={decay}), {len(g[2])} bias\")\n    return optimizer", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def smart_hub_load(repo='ultralytics/yolov5', model='yolov5s', **kwargs):\n    # YOLOv5 torch.hub.load() wrapper with smart error/issue handling\n    if check_version(torch.__version__, '1.9.1'):\n        kwargs['skip_validation'] = True  # validation causes GitHub API rate limit errors\n    if check_version(torch.__version__, '1.12.0'):\n        kwargs['trust_repo'] = True  # argument required starting in torch 0.12\n    try:\n        return torch.hub.load(repo, model, **kwargs)\n    except Exception:\n        return torch.hub.load(repo, model, force_reload=True, **kwargs)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def smart_resume(ckpt, optimizer, ema=None, weights='yolov5s.pt', epochs=300, resume=True):\n    # Resume training from a partially trained checkpoint\n    best_fitness = 0.0\n    start_epoch = ckpt['epoch'] + 1\n    if ckpt['optimizer'] is not None:\n        optimizer.load_state_dict(ckpt['optimizer'])  # optimizer\n        best_fitness = ckpt['best_fitness']\n    if ema and ckpt.get('ema'):\n        ema.ema.load_state_dict(ckpt['ema'].float().state_dict())  # EMA\n        ema.updates = ckpt['updates']\n    if resume:\n        assert start_epoch > 0, f'{weights} training to {epochs} epochs is finished, nothing to resume.\\n' \\\n                                f\"Start a new training without --resume, i.e. 'python train.py --weights {weights}'\"\n        LOGGER.info(f'Resuming training from {weights} from epoch {start_epoch} to {epochs} total epochs')\n    if epochs < start_epoch:\n        LOGGER.info(f\"{weights} has been trained for {ckpt['epoch']} epochs. Fine-tuning for {epochs} more epochs.\")\n        epochs += ckpt['epoch']  # finetune additional epochs\n    return best_fitness, start_epoch, epochs", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def decorate(fn):\n        return (torch.inference_mode if torch_1_9 else torch.no_grad)()(fn)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, patience=30):\n        self.best_fitness = 0.0  # i.e. mAP\n        self.best_epoch = 0\n        self.patience = patience or float('inf')  # epochs to wait after fitness stops improving to stop\n        self.possible_stop = False  # possible stop may occur next epoch", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __call__(self, epoch, fitness):\n        if fitness >= self.best_fitness:  # >= 0 to allow for early zero-fitness stage of training\n            self.best_epoch = epoch\n            self.best_fitness = fitness\n        delta = epoch - self.best_epoch  # epochs without improvement\n        self.possible_stop = delta >= (self.patience - 1)  # possible stop may occur next epoch\n        stop = delta >= self.patience  # stop training if patience exceeded\n        if stop:\n            LOGGER.info(f'Stopping training early as no improvement observed in last {self.patience} epochs. '\n                        f'Best results observed at epoch {self.best_epoch}, best model saved as best.pt.\\n'\n                        f'To update EarlyStopping(patience={self.patience}) pass a new patience value, '\n                        f'i.e. `python train.py --patience 300` or use `--patience 0` to disable EarlyStopping.')\n        return stop", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, model, decay=0.9999, tau=2000, updates=0):\n        # Create EMA\n        self.ema = deepcopy(de_parallel(model)).eval()  # FP32 EMA\n        self.updates = updates  # number of EMA updates\n        self.decay = lambda x: decay * (1 - math.exp(-x / tau))  # decay exponential ramp (to help early epochs)\n        for p in self.ema.parameters():\n            p.requires_grad_(False)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def update(self, model):\n        # Update EMA parameters\n        self.updates += 1\n        d = self.decay(self.updates)\n\n        msd = de_parallel(model).state_dict()  # model state_dict\n        for k, v in self.ema.state_dict().items():\n            if v.dtype.is_floating_point:  # true for FP16 and FP32\n                v *= d\n                v += (1 - d) * msd[k].detach()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def update_attr(self, model, include=(), exclude=('process_group', 'reducer')):\n        # Update EMA attributes\n        copy_attr(self.ema, model, include, exclude)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def is_ascii(s=''):\n    # Is string composed of all ASCII (no UTF) characters? (note str().isascii() introduced in python 3.7)\n    s = str(s)  # convert list, tuple, None, etc. to str\n    return len(s.encode().decode('ascii', 'ignore')) == len(s)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def is_chinese(s='\u4eba\u5de5\u667a\u80fd'):\n    # Is string composed of any Chinese characters?\n    return bool(re.search('[\\u4e00-\\u9fff]', str(s)))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def is_colab():\n    # Is environment a Google Colab instance?\n    return 'google.colab' in sys.modules", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def is_notebook():\n    # Is environment a Jupyter notebook? Verified on Colab, Jupyterlab, Kaggle, Paperspace\n    ipython_type = str(type(IPython.get_ipython()))\n    return 'colab' in ipython_type or 'zmqshell' in ipython_type", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def is_kaggle():\n    # Is environment a Kaggle Notebook?\n    return os.environ.get('PWD') == '/kaggle/working' and os.environ.get('KAGGLE_URL_BASE') == 'https://www.kaggle.com'", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def is_docker() -> bool:\n    \"\"\"Check if the process runs inside a docker container.\"\"\"\n    if Path(\"/.dockerenv\").exists():\n        return True\n    try:  # check if docker is in control groups\n        with open(\"/proc/self/cgroup\") as file:\n            return any(\"docker\" in line for line in file)\n    except OSError:\n        return False", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def is_writeable(dir, test=False):\n    # Return True if directory has write permissions, test opening a file with write permissions if test=True\n    if not test:\n        return os.access(dir, os.W_OK)  # possible issues on Windows\n    file = Path(dir) / 'tmp.txt'\n    try:\n        with open(file, 'w'):  # open file with write permissions\n            pass\n        file.unlink()  # remove file\n        return True\n    except OSError:\n        return False", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def set_logging(name=LOGGING_NAME, verbose=True):\n    # sets up logging for the given name\n    rank = int(os.getenv('RANK', -1))  # rank in world for Multi-GPU trainings\n    level = logging.INFO if verbose and rank in {-1, 0} else logging.ERROR\n    logging.config.dictConfig({\n        \"version\": 1,\n        \"disable_existing_loggers\": False,\n        \"formatters\": {\n            name: {\n                \"format\": \"%(message)s\"}},\n        \"handlers\": {\n            name: {\n                \"class\": \"logging.StreamHandler\",\n                \"formatter\": name,\n                \"level\": level,}},\n        \"loggers\": {\n            name: {\n                \"level\": level,\n                \"handlers\": [name],\n                \"propagate\": False,}}})", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def user_config_dir(dir='Ultralytics', env_var='YOLOV5_CONFIG_DIR'):\n    # Return path of user configuration directory. Prefer environment variable if exists. Make dir if required.\n    env = os.getenv(env_var)\n    if env:\n        path = Path(env)  # use environment variable\n    else:\n        cfg = {'Windows': 'AppData/Roaming', 'Linux': '.config', 'Darwin': 'Library/Application Support'}  # 3 OS dirs\n        path = Path.home() / cfg.get(platform.system(), '')  # OS-specific config dir\n        path = (path if is_writeable(path) else Path('/tmp')) / dir  # GCP and AWS lambda fix, only /tmp is writeable\n    path.mkdir(exist_ok=True)  # make if required\n    return path", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def methods(instance):\n    # Get class/instance methods\n    return [f for f in dir(instance) if callable(getattr(instance, f)) and not f.startswith(\"__\")]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def print_args(args: Optional[dict] = None, show_file=True, show_func=False):\n    # Print function arguments (optional args dict)\n    x = inspect.currentframe().f_back  # previous frame\n    file, _, func, _, _ = inspect.getframeinfo(x)\n    if args is None:  # get args automatically\n        args, _, _, frm = inspect.getargvalues(x)\n        args = {k: v for k, v in frm.items() if k in args}\n    try:\n        file = Path(file).resolve().relative_to(ROOT).with_suffix('')\n    except ValueError:\n        file = Path(file).stem\n    s = (f'{file}: ' if show_file else '') + (f'{func}: ' if show_func else '')\n    LOGGER.info(colorstr(s) + ', '.join(f'{k}={v}' for k, v in args.items()))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def init_seeds(seed=0, deterministic=False):\n    # Initialize random number generator (RNG) seeds https://pytorch.org/docs/stable/notes/randomness.html\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)  # for Multi-GPU, exception safe\n    # torch.backends.cudnn.benchmark = True  # AutoBatch problem https://github.com/ultralytics/yolov5/issues/9287\n    if deterministic and check_version(torch.__version__, '1.12.0'):  # https://github.com/ultralytics/yolov5/pull/8213\n        torch.use_deterministic_algorithms(True)\n        torch.backends.cudnn.deterministic = True\n        os.environ['CUBLAS_WORKSPACE_CONFIG'] = ':4096:8'\n        os.environ['PYTHONHASHSEED'] = str(seed)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def intersect_dicts(da, db, exclude=()):\n    # Dictionary intersection of matching keys and shapes, omitting 'exclude' keys, using da values\n    return {k: v for k, v in da.items() if k in db and all(x not in k for x in exclude) and v.shape == db[k].shape}", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def get_default_args(func):\n    # Get func() default arguments\n    signature = inspect.signature(func)\n    return {k: v.default for k, v in signature.parameters.items() if v.default is not inspect.Parameter.empty}", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def get_latest_run(search_dir='.'):\n    # Return path to most recent 'last.pt' in /runs (i.e. to --resume from)\n    last_list = glob.glob(f'{search_dir}/**/last*.pt', recursive=True)\n    return max(last_list, key=os.path.getctime) if last_list else ''", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def file_age(path=__file__):\n    # Return days since last file update\n    dt = (datetime.now() - datetime.fromtimestamp(Path(path).stat().st_mtime))  # delta\n    return dt.days  # + dt.seconds / 86400  # fractional days", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def file_date(path=__file__):\n    # Return human-readable file modification date, i.e. '2021-3-26'\n    t = datetime.fromtimestamp(Path(path).stat().st_mtime)\n    return f'{t.year}-{t.month}-{t.day}'", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def file_size(path):\n    # Return file/dir size (MB)\n    mb = 1 << 20  # bytes to MiB (1024 ** 2)\n    path = Path(path)\n    if path.is_file():\n        return path.stat().st_size / mb\n    elif path.is_dir():\n        return sum(f.stat().st_size for f in path.glob('**/*') if f.is_file()) / mb\n    else:\n        return 0.0", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_online():\n    # Check internet connectivity\n    import socket\n\n    def run_once():\n        # Check once\n        try:\n            socket.create_connection((\"1.1.1.1\", 443), 5)  # check host accessibility\n            return True\n        except OSError:\n            return False\n\n    return run_once() or run_once()  # check twice to increase robustness to intermittent connectivity issues", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def git_describe(path=ROOT):  # path must be a directory\n    # Return human-readable git description, i.e. v5.0-5-g3e25f1e https://git-scm.com/docs/git-describe\n    try:\n        assert (Path(path) / '.git').is_dir()\n        return check_output(f'git -C {path} describe --tags --long --always', shell=True).decode()[:-1]\n    except Exception:\n        return ''", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_git_status(repo='ultralytics/yolov5', branch='master'):\n    # YOLOv5 status check, recommend 'git pull' if code is out of date\n    url = f'https://github.com/{repo}'\n    msg = f', for updates see {url}'\n    s = colorstr('github: ')  # string\n    assert Path('.git').exists(), s + 'skipping check (not a git repository)' + msg\n    assert check_online(), s + 'skipping check (offline)' + msg\n\n    splits = re.split(pattern=r'\\s', string=check_output('git remote -v', shell=True).decode())\n    matches = [repo in s for s in splits]\n    if any(matches):\n        remote = splits[matches.index(True) - 1]\n    else:\n        remote = 'ultralytics'\n        check_output(f'git remote add {remote} {url}', shell=True)\n    check_output(f'git fetch {remote}', shell=True, timeout=5)  # git fetch\n    local_branch = check_output('git rev-parse --abbrev-ref HEAD', shell=True).decode().strip()  # checked out\n    n = int(check_output(f'git rev-list {local_branch}..{remote}/{branch} --count', shell=True))  # commits behind\n    if n > 0:\n        pull = 'git pull' if remote == 'origin' else f'git pull {remote} {branch}'\n        s += f\"\u26a0\ufe0f YOLOv5 is out of date by {n} commit{'s' * (n > 1)}. Use `{pull}` or `git clone {url}` to update.\"\n    else:\n        s += f'up to date with {url} \u2705'\n    LOGGER.info(s)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_git_info(path='.'):\n    # YOLOv5 git info check, return {remote, branch, commit}\n    check_requirements('gitpython')\n    import git\n    try:\n        repo = git.Repo(path)\n        remote = repo.remotes.origin.url.replace('.git', '')  # i.e. 'https://github.com/ultralytics/yolov5'\n        commit = repo.head.commit.hexsha  # i.e. '3134699c73af83aac2a481435550b968d5792c0d'\n        try:\n            branch = repo.active_branch.name  # i.e. 'main'\n        except TypeError:  # not on any branch\n            branch = None  # i.e. 'detached HEAD' state\n        return {'remote': remote, 'branch': branch, 'commit': commit}\n    except git.exc.InvalidGitRepositoryError:  # path is not a git dir\n        return {'remote': None, 'branch': None, 'commit': None}", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_python(minimum='3.7.0'):\n    # Check current python version vs. required python version\n    check_version(platform.python_version(), minimum, name='Python ', hard=True)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_version(current='0.0.0', minimum='0.0.0', name='version ', pinned=False, hard=False, verbose=False):\n    # Check version vs. required version\n    current, minimum = (pkg.parse_version(x) for x in (current, minimum))\n    result = (current == minimum) if pinned else (current >= minimum)  # bool\n    s = f'WARNING \u26a0\ufe0f {name}{minimum} is required by YOLOv5, but {name}{current} is currently installed'  # string\n    if hard:\n        assert result, emojis(s)  # assert min requirements met\n    if verbose and not result:\n        LOGGER.warning(s)\n    return result", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_requirements(requirements=ROOT / 'requirements.txt', exclude=(), install=True, cmds=''):\n    # Check installed dependencies meet YOLOv5 requirements (pass *.txt file or list of packages or single package str)\n    prefix = colorstr('red', 'bold', 'requirements:')\n    check_python()  # check python version\n    if isinstance(requirements, Path):  # requirements.txt file\n        file = requirements.resolve()\n        assert file.exists(), f\"{prefix} {file} not found, check failed.\"\n        with file.open() as f:\n            requirements = [f'{x.name}{x.specifier}' for x in pkg.parse_requirements(f) if x.name not in exclude]\n    elif isinstance(requirements, str):\n        requirements = [requirements]\n\n    s = ''\n    n = 0\n    for r in requirements:\n        try:\n            pkg.require(r)\n        except (pkg.VersionConflict, pkg.DistributionNotFound):  # exception if requirements not met\n            s += f'\"{r}\" '\n            n += 1\n\n    if s and install and AUTOINSTALL:  # check environment variable\n        LOGGER.info(f\"{prefix} YOLOv5 requirement{'s' * (n > 1)} {s}not found, attempting AutoUpdate...\")\n        try:\n            # assert check_online(), \"AutoUpdate skipped (offline)\"\n            LOGGER.info(check_output(f'pip install {s} {cmds}', shell=True).decode())\n            source = file if 'file' in locals() else requirements\n            s = f\"{prefix} {n} package{'s' * (n > 1)} updated per {source}\\n\" \\\n                f\"{prefix} \u26a0\ufe0f {colorstr('bold', 'Restart runtime or rerun command for updates to take effect')}\\n\"\n            LOGGER.info(s)\n        except Exception as e:\n            LOGGER.warning(f'{prefix} \u274c {e}')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_img_size(imgsz, s=32, floor=0):\n    # Verify image size is a multiple of stride s in each dimension\n    if isinstance(imgsz, int):  # integer i.e. img_size=640\n        new_size = max(make_divisible(imgsz, int(s)), floor)\n    else:  # list i.e. img_size=[640, 480]\n        imgsz = list(imgsz)  # convert to list if tuple\n        new_size = [max(make_divisible(x, int(s)), floor) for x in imgsz]\n    if new_size != imgsz:\n        LOGGER.warning(f'WARNING \u26a0\ufe0f --img-size {imgsz} must be multiple of max stride {s}, updating to {new_size}')\n    return new_size", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_imshow(warn=False):\n    # Check if environment supports image displays\n    try:\n        assert not is_notebook()\n        assert not is_docker()\n        cv2.imshow('test', np.zeros((1, 1, 3)))\n        cv2.waitKey(1)\n        cv2.destroyAllWindows()\n        cv2.waitKey(1)\n        return True\n    except Exception as e:\n        if warn:\n            LOGGER.warning(f'WARNING \u26a0\ufe0f Environment does not support cv2.imshow() or PIL Image.show()\\n{e}')\n        return False", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_suffix(file='yolov5s.pt', suffix=('.pt',), msg=''):\n    # Check file(s) for acceptable suffix\n    if file and suffix:\n        if isinstance(suffix, str):\n            suffix = [suffix]\n        for f in file if isinstance(file, (list, tuple)) else [file]:\n            s = Path(f).suffix.lower()  # file suffix\n            if len(s):\n                assert s in suffix, f\"{msg}{f} acceptable suffix is {suffix}\"", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_yaml(file, suffix=('.yaml', '.yml')):\n    # Search/download YAML file (if necessary) and return path, checking suffix\n    return check_file(file, suffix)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_file(file, suffix=''):\n    # Search/download file (if necessary) and return path\n    check_suffix(file, suffix)  # optional\n    file = str(file)  # convert to str()\n    if os.path.isfile(file) or not file:  # exists\n        return file\n    elif file.startswith(('http:/', 'https:/')):  # download\n        url = file  # warning: Pathlib turns :// -> :/\n        file = Path(urllib.parse.unquote(file).split('?')[0]).name  # '%2F' to '/', split https://url.com/file.txt?auth\n        if os.path.isfile(file):\n            LOGGER.info(f'Found {url} locally at {file}')  # file already exists\n        else:\n            LOGGER.info(f'Downloading {url} to {file}...')\n            torch.hub.download_url_to_file(url, file)\n            assert Path(file).exists() and Path(file).stat().st_size > 0, f'File download failed: {url}'  # check\n        return file\n    elif file.startswith('clearml://'):  # ClearML Dataset ID\n        assert 'clearml' in sys.modules, \"ClearML is not installed, so cannot use ClearML dataset. Try running 'pip install clearml'.\"\n        return file\n    else:  # search\n        files = []\n        for d in 'data', 'models', 'utils':  # search directories\n            files.extend(glob.glob(str(ROOT / d / '**' / file), recursive=True))  # find file\n        assert len(files), f'File not found: {file}'  # assert file was found\n        assert len(files) == 1, f\"Multiple files match '{file}', specify exact path: {files}\"  # assert unique\n        return files[0]  # return file", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_font(font=FONT, progress=False):\n    # Download font to CONFIG_DIR if necessary\n    font = Path(font)\n    file = CONFIG_DIR / font.name\n    if not font.exists() and not file.exists():\n        url = f'https://ultralytics.com/assets/{font.name}'\n        LOGGER.info(f'Downloading {url} to {file}...')\n        torch.hub.download_url_to_file(url, str(file), progress=progress)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_dataset(data, autodownload=True):\n    # Download, check and/or unzip dataset if not found locally\n\n    # Download (optional)\n    extract_dir = ''\n    if isinstance(data, (str, Path)) and (is_zipfile(data) or is_tarfile(data)):\n        download(data, dir=f'{DATASETS_DIR}/{Path(data).stem}', unzip=True, delete=False, curl=False, threads=1)\n        data = next((DATASETS_DIR / Path(data).stem).rglob('*.yaml'))\n        extract_dir, autodownload = data.parent, False\n\n    # Read yaml (optional)\n    if isinstance(data, (str, Path)):\n        data = yaml_load(data)  # dictionary\n\n    # Checks\n    for k in 'train', 'val', 'names':\n        assert k in data, emojis(f\"data.yaml '{k}:' field missing \u274c\")\n    if isinstance(data['names'], (list, tuple)):  # old array format\n        data['names'] = dict(enumerate(data['names']))  # convert to dict\n    assert all(isinstance(k, int) for k in data['names'].keys()), 'data.yaml names keys must be integers, i.e. 2: car'\n    data['nc'] = len(data['names'])\n\n    # Resolve paths\n    path = Path(extract_dir or data.get('path') or '')  # optional 'path' default to '.'\n    if not path.is_absolute():\n        path = (ROOT / path).resolve()\n        data['path'] = path  # download scripts\n    for k in 'train', 'val', 'test':\n        if data.get(k):  # prepend path\n            if isinstance(data[k], str):\n                x = (path / data[k]).resolve()\n                if not x.exists() and data[k].startswith('../'):\n                    x = (path / data[k][3:]).resolve()\n                data[k] = str(x)\n            else:\n                data[k] = [str((path / x).resolve()) for x in data[k]]\n\n    # Parse yaml\n    train, val, test, s = (data.get(x) for x in ('train', 'val', 'test', 'download'))\n    if val:\n        val = [Path(x).resolve() for x in (val if isinstance(val, list) else [val])]  # val path\n        if not all(x.exists() for x in val):\n            LOGGER.info('\\nDataset not found \u26a0\ufe0f, missing paths %s' % [str(x) for x in val if not x.exists()])\n            if not s or not autodownload:\n                raise Exception('Dataset not found \u274c')\n            t = time.time()\n            if s.startswith('http') and s.endswith('.zip'):  # URL\n                f = Path(s).name  # filename\n                LOGGER.info(f'Downloading {s} to {f}...')\n                torch.hub.download_url_to_file(s, f)\n                Path(DATASETS_DIR).mkdir(parents=True, exist_ok=True)  # create root\n                unzip_file(f, path=DATASETS_DIR)  # unzip\n                Path(f).unlink()  # remove zip\n                r = None  # success\n            elif s.startswith('bash '):  # bash script\n                LOGGER.info(f'Running {s} ...')\n                r = os.system(s)\n            else:  # python script\n                r = exec(s, {'yaml': data})  # return None\n            dt = f'({round(time.time() - t, 1)}s)'\n            s = f\"success \u2705 {dt}, saved to {colorstr('bold', DATASETS_DIR)}\" if r in (0, None) else f\"failure {dt} \u274c\"\n            LOGGER.info(f\"Dataset download {s}\")\n    check_font('Arial.ttf' if is_ascii(data['names']) else 'Arial.Unicode.ttf', progress=True)  # download fonts\n    return data  # dictionary", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def check_amp(model):\n    # Check PyTorch Automatic Mixed Precision (AMP) functionality. Return True on correct operation\n    from models.common import AutoShape, DetectMultiBackend\n\n    def amp_allclose(model, im):\n        # All close FP32 vs AMP results\n        m = AutoShape(model, verbose=False)  # model\n        a = m(im).xywhn[0]  # FP32 inference\n        m.amp = True\n        b = m(im).xywhn[0]  # AMP inference\n        return a.shape == b.shape and torch.allclose(a, b, atol=0.1)  # close to 10% absolute tolerance\n\n    prefix = colorstr('AMP: ')\n    device = next(model.parameters()).device  # get model device\n    if device.type in ('cpu', 'mps'):\n        return False  # AMP only used on CUDA devices\n    f = ROOT / 'data' / 'images' / 'bus.jpg'  # image to check\n    im = f if f.exists() else 'https://ultralytics.com/images/bus.jpg' if check_online() else np.ones((640, 640, 3))\n    try:\n        assert amp_allclose(deepcopy(model), im) or amp_allclose(DetectMultiBackend('yolov5n.pt', device), im)\n        LOGGER.info(f'{prefix}checks passed \u2705')\n        return True\n    except Exception:\n        help_url = 'https://github.com/ultralytics/yolov5/issues/7908'\n        LOGGER.warning(f'{prefix}checks failed \u274c, disabling Automatic Mixed Precision. See {help_url}')\n        return False", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def yaml_load(file='data.yaml'):\n    # Single-line safe yaml loading\n    with open(file, errors='ignore') as f:\n        return yaml.safe_load(f)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def yaml_save(file='data.yaml', data={}):\n    # Single-line safe yaml saving\n    with open(file, 'w') as f:\n        yaml.safe_dump({k: str(v) if isinstance(v, Path) else v for k, v in data.items()}, f, sort_keys=False)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def unzip_file(file, path=None, exclude=('.DS_Store', '__MACOSX')):\n    # Unzip a *.zip file to path/, excluding files containing strings in exclude list\n    if path is None:\n        path = Path(file).parent  # default path\n    with ZipFile(file) as zipObj:\n        for f in zipObj.namelist():  # list all archived filenames in the zip\n            if all(x not in f for x in exclude):\n                zipObj.extract(f, path=path)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def url2file(url):\n    # Convert URL to filename, i.e. https://url.com/file.txt?auth -> file.txt\n    url = str(Path(url)).replace(':/', '://')  # Pathlib turns :// -> :/\n    return Path(urllib.parse.unquote(url)).name.split('?')[0]  # '%2F' to '/', split https://url.com/file.txt?auth", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def download(url, dir='.', unzip=True, delete=True, curl=False, threads=1, retry=3):\n    # Multithreaded file download and unzip function, used in data.yaml for autodownload\n    def download_one(url, dir):\n        # Download 1 file\n        success = True\n        if os.path.isfile(url):\n            f = Path(url)  # filename\n        else:  # does not exist\n            f = dir / Path(url).name\n            LOGGER.info(f'Downloading {url} to {f}...')\n            for i in range(retry + 1):\n                if curl:\n                    s = 'sS' if threads > 1 else ''  # silent\n                    r = os.system(\n                        f'curl -# -{s}L \"{url}\" -o \"{f}\" --retry 9 -C -')  # curl download with retry, continue\n                    success = r == 0\n                else:\n                    torch.hub.download_url_to_file(url, f, progress=threads == 1)  # torch download\n                    success = f.is_file()\n                if success:\n                    break\n                elif i < retry:\n                    LOGGER.warning(f'\u26a0\ufe0f Download failure, retrying {i + 1}/{retry} {url}...')\n                else:\n                    LOGGER.warning(f'\u274c Failed to download {url}...')\n\n        if unzip and success and (f.suffix == '.gz' or is_zipfile(f) or is_tarfile(f)):\n            LOGGER.info(f'Unzipping {f}...')\n            if is_zipfile(f):\n                unzip_file(f, dir)  # unzip\n            elif is_tarfile(f):\n                os.system(f'tar xf {f} --directory {f.parent}')  # unzip\n            elif f.suffix == '.gz':\n                os.system(f'tar xfz {f} --directory {f.parent}')  # unzip\n            if delete:\n                f.unlink()  # remove zip\n\n    dir = Path(dir)\n    dir.mkdir(parents=True, exist_ok=True)  # make directory\n    if threads > 1:\n        pool = ThreadPool(threads)\n        pool.imap(lambda x: download_one(*x), zip(url, repeat(dir)))  # multithreaded\n        pool.close()\n        pool.join()\n    else:\n        for u in [url] if isinstance(url, (str, Path)) else url:\n            download_one(u, dir)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def make_divisible(x, divisor):\n    # Returns nearest x divisible by divisor\n    if isinstance(divisor, torch.Tensor):\n        divisor = int(divisor.max())  # to int\n    return math.ceil(x / divisor) * divisor", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def clean_str(s):\n    # Cleans a string by replacing special characters with underscore _\n    return re.sub(pattern=\"[|@#!\u00a1\u00b7$\u20ac%&()=?\u00bf^*;:,\u00a8\u00b4><+]\", repl=\"_\", string=s)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def one_cycle(y1=0.0, y2=1.0, steps=100):\n    # lambda function for sinusoidal ramp from y1 to y2 https://arxiv.org/pdf/1812.01187.pdf\n    return lambda x: ((1 - math.cos(x * math.pi / steps)) / 2) * (y2 - y1) + y1", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def colorstr(*input):\n    # Colors a string https://en.wikipedia.org/wiki/ANSI_escape_code, i.e.  colorstr('blue', 'hello world')\n    *args, string = input if len(input) > 1 else ('blue', 'bold', input[0])  # color arguments, string\n    colors = {\n        'black': '\\033[30m',  # basic colors\n        'red': '\\033[31m',\n        'green': '\\033[32m',\n        'yellow': '\\033[33m',\n        'blue': '\\033[34m',\n        'magenta': '\\033[35m',\n        'cyan': '\\033[36m',\n        'white': '\\033[37m',\n        'bright_black': '\\033[90m',  # bright colors\n        'bright_red': '\\033[91m',\n        'bright_green': '\\033[92m',\n        'bright_yellow': '\\033[93m',\n        'bright_blue': '\\033[94m',\n        'bright_magenta': '\\033[95m',\n        'bright_cyan': '\\033[96m',\n        'bright_white': '\\033[97m',\n        'end': '\\033[0m',  # misc\n        'bold': '\\033[1m',\n        'underline': '\\033[4m'}\n    return ''.join(colors[x] for x in args) + f'{string}' + colors['end']", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def labels_to_class_weights(labels, nc=80):\n    # Get class weights (inverse frequency) from training labels\n    if labels[0] is None:  # no labels loaded\n        return torch.Tensor()\n\n    labels = np.concatenate(labels, 0)  # labels.shape = (866643, 5) for COCO\n    classes = labels[:, 0].astype(int)  # labels = [class xywh]\n    weights = np.bincount(classes, minlength=nc)  # occurrences per class\n\n    # Prepend gridpoint count (for uCE training)\n    # gpi = ((320 / 32 * np.array([1, 2, 4])) ** 2 * 3).sum()  # gridpoints per image\n    # weights = np.hstack([gpi * len(labels)  - weights.sum() * 9, weights * 9]) ** 0.5  # prepend gridpoints to start\n\n    weights[weights == 0] = 1  # replace empty bins with 1\n    weights = 1 / weights  # number of targets per class\n    weights /= weights.sum()  # normalize\n    return torch.from_numpy(weights).float()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def labels_to_image_weights(labels, nc=80, class_weights=np.ones(80)):\n    # Produces image weights based on class_weights and image contents\n    # Usage: index = random.choices(range(n), weights=image_weights, k=1)  # weighted image sample\n    class_counts = np.array([np.bincount(x[:, 0].astype(int), minlength=nc) for x in labels])\n    return (class_weights.reshape(1, nc) * class_counts).sum(1)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def coco80_to_coco91_class():  # converts 80-index (val2014) to 91-index (paper)\n    # https://tech.amikelive.com/node-718/what-object-categories-labels-are-in-coco-dataset/\n    # a = np.loadtxt('data/coco.names', dtype='str', delimiter='\\n')\n    # b = np.loadtxt('data/coco_paper.names', dtype='str', delimiter='\\n')\n    # x1 = [list(a[i] == b).index(True) + 1 for i in range(80)]  # darknet to coco\n    # x2 = [list(b[i] == a).index(True) if any(b[i] == a) else None for i in range(91)]  # coco to darknet\n    return [\n        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 28, 31, 32, 33, 34,\n        35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n        64, 65, 67, 70, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 84, 85, 86, 87, 88, 89, 90]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def xyxy2xywh(x):\n    # Convert nx4 boxes from [x1, y1, x2, y2] to [x, y, w, h] where xy1=top-left, xy2=bottom-right\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[:, 0] = (x[:, 0] + x[:, 2]) / 2  # x center\n    y[:, 1] = (x[:, 1] + x[:, 3]) / 2  # y center\n    y[:, 2] = x[:, 2] - x[:, 0]  # width\n    y[:, 3] = x[:, 3] - x[:, 1]  # height\n    return y", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def xywh2xyxy(x):\n    # Convert nx4 boxes from [x, y, w, h] to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[:, 0] = x[:, 0] - x[:, 2] / 2  # top left x\n    y[:, 1] = x[:, 1] - x[:, 3] / 2  # top left y\n    y[:, 2] = x[:, 0] + x[:, 2] / 2  # bottom right x\n    y[:, 3] = x[:, 1] + x[:, 3] / 2  # bottom right y\n    return y", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def xywhn2xyxy(x, w=640, h=640, padw=0, padh=0):\n    # Convert nx4 boxes from [x, y, w, h] normalized to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[:, 0] = w * (x[:, 0] - x[:, 2] / 2) + padw  # top left x\n    y[:, 1] = h * (x[:, 1] - x[:, 3] / 2) + padh  # top left y\n    y[:, 2] = w * (x[:, 0] + x[:, 2] / 2) + padw  # bottom right x\n    y[:, 3] = h * (x[:, 1] + x[:, 3] / 2) + padh  # bottom right y\n    return y", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def xyxy2xywhn(x, w=640, h=640, clip=False, eps=0.0):\n    # Convert nx4 boxes from [x1, y1, x2, y2] to [x, y, w, h] normalized where xy1=top-left, xy2=bottom-right\n    if clip:\n        clip_boxes(x, (h - eps, w - eps))  # warning: inplace clip\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[:, 0] = ((x[:, 0] + x[:, 2]) / 2) / w  # x center\n    y[:, 1] = ((x[:, 1] + x[:, 3]) / 2) / h  # y center\n    y[:, 2] = (x[:, 2] - x[:, 0]) / w  # width\n    y[:, 3] = (x[:, 3] - x[:, 1]) / h  # height\n    return y", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def xyn2xy(x, w=640, h=640, padw=0, padh=0):\n    # Convert normalized segments into pixel segments, shape (n,2)\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[:, 0] = w * x[:, 0] + padw  # top left x\n    y[:, 1] = h * x[:, 1] + padh  # top left y\n    return y", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def segment2box(segment, width=640, height=640):\n    # Convert 1 segment label to 1 box label, applying inside-image constraint, i.e. (xy1, xy2, ...) to (xyxy)\n    x, y = segment.T  # segment xy\n    inside = (x >= 0) & (y >= 0) & (x <= width) & (y <= height)\n    x, y, = x[inside], y[inside]\n    return np.array([x.min(), y.min(), x.max(), y.max()]) if any(x) else np.zeros((1, 4))  # xyxy", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def segments2boxes(segments):\n    # Convert segment labels to box labels, i.e. (cls, xy1, xy2, ...) to (cls, xywh)\n    boxes = []\n    for s in segments:\n        x, y = s.T  # segment xy\n        boxes.append([x.min(), y.min(), x.max(), y.max()])  # cls, xyxy\n    return xyxy2xywh(np.array(boxes))  # cls, xywh", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def resample_segments(segments, n=1000):\n    # Up-sample an (n,2) segment\n    for i, s in enumerate(segments):\n        s = np.concatenate((s, s[0:1, :]), axis=0)\n        x = np.linspace(0, len(s) - 1, n)\n        xp = np.arange(len(s))\n        segments[i] = np.concatenate([np.interp(x, xp, s[:, i]) for i in range(2)]).reshape(2, -1).T  # segment xy\n    return segments", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def scale_boxes(img1_shape, boxes, img0_shape, ratio_pad=None):\n    # Rescale boxes (xyxy) from img1_shape to img0_shape\n    if ratio_pad is None:  # calculate from img0_shape\n        gain = min(img1_shape[0] / img0_shape[0], img1_shape[1] / img0_shape[1])  # gain  = old / new\n        pad = (img1_shape[1] - img0_shape[1] * gain) / 2, (img1_shape[0] - img0_shape[0] * gain) / 2  # wh padding\n    else:\n        gain = ratio_pad[0][0]\n        pad = ratio_pad[1]\n\n    boxes[:, [0, 2]] -= pad[0]  # x padding\n    boxes[:, [1, 3]] -= pad[1]  # y padding\n    boxes[:, :4] /= gain\n    clip_boxes(boxes, img0_shape)\n    return boxes", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def scale_segments(img1_shape, segments, img0_shape, ratio_pad=None, normalize=False):\n    # Rescale coords (xyxy) from img1_shape to img0_shape\n    if ratio_pad is None:  # calculate from img0_shape\n        gain = min(img1_shape[0] / img0_shape[0], img1_shape[1] / img0_shape[1])  # gain  = old / new\n        pad = (img1_shape[1] - img0_shape[1] * gain) / 2, (img1_shape[0] - img0_shape[0] * gain) / 2  # wh padding\n    else:\n        gain = ratio_pad[0][0]\n        pad = ratio_pad[1]\n\n    segments[:, 0] -= pad[0]  # x padding\n    segments[:, 1] -= pad[1]  # y padding\n    segments /= gain\n    clip_segments(segments, img0_shape)\n    if normalize:\n        segments[:, 0] /= img0_shape[1]  # width\n        segments[:, 1] /= img0_shape[0]  # height\n    return segments", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def clip_boxes(boxes, shape):\n    # Clip boxes (xyxy) to image shape (height, width)\n    if isinstance(boxes, torch.Tensor):  # faster individually\n        boxes[:, 0].clamp_(0, shape[1])  # x1\n        boxes[:, 1].clamp_(0, shape[0])  # y1\n        boxes[:, 2].clamp_(0, shape[1])  # x2\n        boxes[:, 3].clamp_(0, shape[0])  # y2\n    else:  # np.array (faster grouped)\n        boxes[:, [0, 2]] = boxes[:, [0, 2]].clip(0, shape[1])  # x1, x2\n        boxes[:, [1, 3]] = boxes[:, [1, 3]].clip(0, shape[0])  # y1, y2", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def clip_segments(segments, shape):\n    # Clip segments (xy1,xy2,...) to image shape (height, width)\n    if isinstance(segments, torch.Tensor):  # faster individually\n        segments[:, 0].clamp_(0, shape[1])  # x\n        segments[:, 1].clamp_(0, shape[0])  # y\n    else:  # np.array (faster grouped)\n        segments[:, 0] = segments[:, 0].clip(0, shape[1])  # x\n        segments[:, 1] = segments[:, 1].clip(0, shape[0])  # y", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def non_max_suppression(\n        prediction,\n        conf_thres=0.25,\n        iou_thres=0.45,\n        classes=None,\n        agnostic=False,\n        multi_label=False,\n        labels=(),\n        max_det=300,\n        nm=0,  # number of masks\n):\n    \"\"\"Non-Maximum Suppression (NMS) on inference results to reject overlapping detections\n\n    Returns:\n         list of detections, on (n,6) tensor per image [xyxy, conf, cls]\n    \"\"\"\n\n    if isinstance(prediction, (list, tuple)):  # YOLOv5 model in validation model, output = (inference_out, loss_out)\n        prediction = prediction[0]  # select only inference output\n\n    device = prediction.device\n    mps = 'mps' in device.type  # Apple MPS\n    if mps:  # MPS not fully supported yet, convert tensors to CPU before NMS\n        prediction = prediction.cpu()\n    bs = prediction.shape[0]  # batch size\n    nc = prediction.shape[2] - nm - 5  # number of classes\n    xc = prediction[..., 4] > conf_thres  # candidates\n\n    # Checks\n    assert 0 <= conf_thres <= 1, f'Invalid Confidence threshold {conf_thres}, valid values are between 0.0 and 1.0'\n    assert 0 <= iou_thres <= 1, f'Invalid IoU {iou_thres}, valid values are between 0.0 and 1.0'\n\n    # Settings\n    # min_wh = 2  # (pixels) minimum box width and height\n    max_wh = 7680  # (pixels) maximum box width and height\n    max_nms = 30000  # maximum number of boxes into torchvision.ops.nms()\n    time_limit = 0.5 + 0.05 * bs  # seconds to quit after\n    redundant = True  # require redundant detections\n    multi_label &= nc > 1  # multiple labels per box (adds 0.5ms/img)\n    merge = False  # use merge-NMS\n\n    t = time.time()\n    mi = 5 + nc  # mask start index\n    output = [torch.zeros((0, 6 + nm), device=prediction.device)] * bs\n    for xi, x in enumerate(prediction):  # image index, image inference\n        # Apply constraints\n        # x[((x[..., 2:4] < min_wh) | (x[..., 2:4] > max_wh)).any(1), 4] = 0  # width-height\n        x = x[xc[xi]]  # confidence\n\n        # Cat apriori labels if autolabelling\n        if labels and len(labels[xi]):\n            lb = labels[xi]\n            v = torch.zeros((len(lb), nc + nm + 5), device=x.device)\n            v[:, :4] = lb[:, 1:5]  # box\n            v[:, 4] = 1.0  # conf\n            v[range(len(lb)), lb[:, 0].long() + 5] = 1.0  # cls\n            x = torch.cat((x, v), 0)\n\n        # If none remain process next image\n        if not x.shape[0]:\n            continue\n\n        # Compute conf\n        x[:, 5:] *= x[:, 4:5]  # conf = obj_conf * cls_conf\n\n        # Box/Mask\n        box = xywh2xyxy(x[:, :4])  # center_x, center_y, width, height) to (x1, y1, x2, y2)\n        mask = x[:, mi:]  # zero columns if no masks\n\n        # Detections matrix nx6 (xyxy, conf, cls)\n        if multi_label:\n            i, j = (x[:, 5:mi] > conf_thres).nonzero(as_tuple=False).T\n            x = torch.cat((box[i], x[i, 5 + j, None], j[:, None].float(), mask[i]), 1)\n        else:  # best class only\n            conf, j = x[:, 5:mi].max(1, keepdim=True)\n            x = torch.cat((box, conf, j.float(), mask), 1)[conf.view(-1) > conf_thres]\n\n        # Filter by class\n        if classes is not None:\n            x = x[(x[:, 5:6] == torch.tensor(classes, device=x.device)).any(1)]\n\n        # Apply finite constraint\n        # if not torch.isfinite(x).all():\n        #     x = x[torch.isfinite(x).all(1)]\n\n        # Check shape\n        n = x.shape[0]  # number of boxes\n        if not n:  # no boxes\n            continue\n        elif n > max_nms:  # excess boxes\n            x = x[x[:, 4].argsort(descending=True)[:max_nms]]  # sort by confidence\n        else:\n            x = x[x[:, 4].argsort(descending=True)]  # sort by confidence\n\n        # Batched NMS\n        c = x[:, 5:6] * (0 if agnostic else max_wh)  # classes\n        boxes, scores = x[:, :4] + c, x[:, 4]  # boxes (offset by class), scores\n        i = torchvision.ops.nms(boxes, scores, iou_thres)  # NMS\n        if i.shape[0] > max_det:  # limit detections\n            i = i[:max_det]\n        if merge and (1 < n < 3E3):  # Merge NMS (boxes merged using weighted mean)\n            # update boxes as boxes(i,4) = weights(i,n) * boxes(n,4)\n            iou = box_iou(boxes[i], boxes) > iou_thres  # iou matrix\n            weights = iou * scores[None]  # box weights\n            x[i, :4] = torch.mm(weights, x[:, :4]).float() / weights.sum(1, keepdim=True)  # merged boxes\n            if redundant:\n                i = i[iou.sum(1) > 1]  # require redundancy\n\n        output[xi] = x[i]\n        if mps:\n            output[xi] = output[xi].to(device)\n        if (time.time() - t) > time_limit:\n            LOGGER.warning(f'WARNING \u26a0\ufe0f NMS time limit {time_limit:.3f}s exceeded')\n            break  # time limit exceeded\n\n    return output", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def strip_optimizer(f='best.pt', s=''):  # from utils.general import *; strip_optimizer()\n    # Strip optimizer from 'f' to finalize training, optionally save as 's'\n    x = torch.load(f, map_location=torch.device('cpu'))\n    if x.get('ema'):\n        x['model'] = x['ema']  # replace model with ema\n    for k in 'optimizer', 'best_fitness', 'ema', 'updates':  # keys\n        x[k] = None\n    x['epoch'] = -1\n    x['model'].half()  # to FP16\n    for p in x['model'].parameters():\n        p.requires_grad = False\n    torch.save(x, s or f)\n    mb = os.path.getsize(s or f) / 1E6  # filesize\n    LOGGER.info(f\"Optimizer stripped from {f},{f' saved as {s},' if s else ''} {mb:.1f}MB\")", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def print_mutation(keys, results, hyp, save_dir, bucket, prefix=colorstr('evolve: ')):\n    evolve_csv = save_dir / 'evolve.csv'\n    evolve_yaml = save_dir / 'hyp_evolve.yaml'\n    keys = tuple(keys) + tuple(hyp.keys())  # [results + hyps]\n    keys = tuple(x.strip() for x in keys)\n    vals = results + tuple(hyp.values())\n    n = len(keys)\n\n    # Download (optional)\n    if bucket:\n        url = f'gs://{bucket}/evolve.csv'\n        if gsutil_getsize(url) > (evolve_csv.stat().st_size if evolve_csv.exists() else 0):\n            os.system(f'gsutil cp {url} {save_dir}')  # download evolve.csv if larger than local\n\n    # Log to evolve.csv\n    s = '' if evolve_csv.exists() else (('%20s,' * n % keys).rstrip(',') + '\\n')  # add header\n    with open(evolve_csv, 'a') as f:\n        f.write(s + ('%20.5g,' * n % vals).rstrip(',') + '\\n')\n\n    # Save yaml\n    with open(evolve_yaml, 'w') as f:\n        data = pd.read_csv(evolve_csv)\n        data = data.rename(columns=lambda x: x.strip())  # strip keys\n        i = np.argmax(fitness(data.values[:, :4]))  #\n        generations = len(data)\n        f.write('# YOLOv5 Hyperparameter Evolution Results\\n' + f'# Best generation: {i}\\n' +\n                f'# Last generation: {generations - 1}\\n' + '# ' + ', '.join(f'{x.strip():>20s}' for x in keys[:7]) +\n                '\\n' + '# ' + ', '.join(f'{x:>20.5g}' for x in data.values[i, :7]) + '\\n\\n')\n        yaml.safe_dump(data.loc[i][7:].to_dict(), f, sort_keys=False)\n\n    # Print to screen\n    LOGGER.info(prefix + f'{generations} generations finished, current result:\\n' + prefix +\n                ', '.join(f'{x.strip():>20s}' for x in keys) + '\\n' + prefix + ', '.join(f'{x:20.5g}'\n                                                                                         for x in vals) + '\\n\\n')\n\n    if bucket:\n        os.system(f'gsutil cp {evolve_csv} {evolve_yaml} gs://{bucket}')  # upload", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def apply_classifier(x, model, img, im0):\n    # Apply a second stage classifier to YOLO outputs\n    # Example model = torchvision.models.__dict__['efficientnet_b0'](pretrained=True).to(device).eval()\n    im0 = [im0] if isinstance(im0, np.ndarray) else im0\n    for i, d in enumerate(x):  # per image\n        if d is not None and len(d):\n            d = d.clone()\n\n            # Reshape and pad cutouts\n            b = xyxy2xywh(d[:, :4])  # boxes\n            b[:, 2:] = b[:, 2:].max(1)[0].unsqueeze(1)  # rectangle to square\n            b[:, 2:] = b[:, 2:] * 1.3 + 30  # pad\n            d[:, :4] = xywh2xyxy(b).long()\n\n            # Rescale boxes from img_size to im0 size\n            scale_boxes(img.shape[2:], d[:, :4], im0[i].shape)\n\n            # Classes\n            pred_cls1 = d[:, 5].long()\n            ims = []\n            for a in d:\n                cutout = im0[i][int(a[1]):int(a[3]), int(a[0]):int(a[2])]\n                im = cv2.resize(cutout, (224, 224))  # BGR\n\n                im = im[:, :, ::-1].transpose(2, 0, 1)  # BGR to RGB, to 3x416x416\n                im = np.ascontiguousarray(im, dtype=np.float32)  # uint8 to float32\n                im /= 255  # 0 - 255 to 0.0 - 1.0\n                ims.append(im)\n\n            pred_cls2 = model(torch.Tensor(ims).to(d.device)).argmax(1)  # classifier prediction\n            x[i] = x[i][pred_cls1 == pred_cls2]  # retain matching class detections\n\n    return x", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def increment_path(path, exist_ok=False, sep='', mkdir=False):\n    # Increment file or directory path, i.e. runs/exp --> runs/exp{sep}2, runs/exp{sep}3, ... etc.\n    path = Path(path)  # os-agnostic\n    if path.exists() and not exist_ok:\n        path, suffix = (path.with_suffix(''), path.suffix) if path.is_file() else (path, '')\n\n        # Method 1\n        for n in range(2, 9999):\n            p = f'{path}{sep}{n}{suffix}'  # increment path\n            if not os.path.exists(p):  #\n                break\n        path = Path(p)\n\n        # Method 2 (deprecated)\n        # dirs = glob.glob(f\"{path}{sep}*\")  # similar paths\n        # matches = [re.search(rf\"{path.stem}{sep}(\\d+)\", d) for d in dirs]\n        # i = [int(m.groups()[0]) for m in matches if m]  # indices\n        # n = max(i) + 1 if i else 2  # increment number\n        # path = Path(f\"{path}{sep}{n}{suffix}\")  # increment path\n\n    if mkdir:\n        path.mkdir(parents=True, exist_ok=True)  # make directory\n\n    return path", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def imread(path, flags=cv2.IMREAD_COLOR):\n    return cv2.imdecode(np.fromfile(path, np.uint8), flags)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def imwrite(path, im):\n    try:\n        cv2.imencode(Path(path).suffix, im)[1].tofile(path)\n        return True\n    except Exception:\n        return False", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def imshow(path, im):\n    imshow_(path.encode('unicode_escape').decode(), im)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, t=0.0):\n        self.t = t\n        self.cuda = torch.cuda.is_available()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __enter__(self):\n        self.start = self.time()\n        return self", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __exit__(self, type, value, traceback):\n        self.dt = self.time() - self.start  # delta-time\n        self.t += self.dt  # accumulate dt", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def time(self):\n        if self.cuda:\n            torch.cuda.synchronize()\n        return time.time()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, seconds, *, timeout_msg='', suppress_timeout_errors=True):\n        self.seconds = int(seconds)\n        self.timeout_message = timeout_msg\n        self.suppress = bool(suppress_timeout_errors)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _timeout_handler(self, signum, frame):\n        raise TimeoutError(self.timeout_message)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __enter__(self):\n        if platform.system() != 'Windows':  # not supported on Windows\n            signal.signal(signal.SIGALRM, self._timeout_handler)  # Set handler for SIGALRM\n            signal.alarm(self.seconds)  # start countdown for SIGALRM to be raised", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        if platform.system() != 'Windows':\n            signal.alarm(0)  # Cancel SIGALRM if it's scheduled\n            if self.suppress and exc_type is TimeoutError:  # Suppress TimeoutError\n                return True", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, new_dir):\n        self.dir = new_dir  # new dir\n        self.cwd = Path.cwd().resolve()  # current dir", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __enter__(self):\n        os.chdir(self.dir)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        os.chdir(self.cwd)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def run_once():\n        # Check once\n        try:\n            socket.create_connection((\"1.1.1.1\", 443), 5)  # check host accessibility\n            return True\n        except OSError:\n            return False", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def amp_allclose(model, im):\n        # All close FP32 vs AMP results\n        m = AutoShape(model, verbose=False)  # model\n        a = m(im).xywhn[0]  # FP32 inference\n        m.amp = True\n        b = m(im).xywhn[0]  # AMP inference\n        return a.shape == b.shape and torch.allclose(a, b, atol=0.1)  # close to 10% absolute tolerance", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def download_one(url, dir):\n        # Download 1 file\n        success = True\n        if os.path.isfile(url):\n            f = Path(url)  # filename\n        else:  # does not exist\n            f = dir / Path(url).name\n            LOGGER.info(f'Downloading {url} to {f}...')\n            for i in range(retry + 1):\n                if curl:\n                    s = 'sS' if threads > 1 else ''  # silent\n                    r = os.system(\n                        f'curl -# -{s}L \"{url}\" -o \"{f}\" --retry 9 -C -')  # curl download with retry, continue\n                    success = r == 0\n                else:\n                    torch.hub.download_url_to_file(url, f, progress=threads == 1)  # torch download\n                    success = f.is_file()\n                if success:\n                    break\n                elif i < retry:\n                    LOGGER.warning(f'\u26a0\ufe0f Download failure, retrying {i + 1}/{retry} {url}...')\n                else:\n                    LOGGER.warning(f'\u274c Failed to download {url}...')\n\n        if unzip and success and (f.suffix == '.gz' or is_zipfile(f) or is_tarfile(f)):\n            LOGGER.info(f'Unzipping {f}...')\n            if is_zipfile(f):\n                unzip_file(f, dir)  # unzip\n            elif is_tarfile(f):\n                os.system(f'tar xf {f} --directory {f.parent}')  # unzip\n            elif f.suffix == '.gz':\n                os.system(f'tar xfz {f} --directory {f.parent}')  # unzip\n            if delete:\n                f.unlink()  # remove zip", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def normalize(x, mean=IMAGENET_MEAN, std=IMAGENET_STD, inplace=False):\n    # Denormalize RGB images x per ImageNet stats in BCHW format, i.e. = (x - mean) / std\n    return TF.normalize(x, mean, std, inplace=inplace)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def denormalize(x, mean=IMAGENET_MEAN, std=IMAGENET_STD):\n    # Denormalize RGB images x per ImageNet stats in BCHW format, i.e. = x * std + mean\n    for i in range(3):\n        x[:, i] = x[:, i] * std[i] + mean[i]\n    return x", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def augment_hsv(im, hgain=0.5, sgain=0.5, vgain=0.5):\n    # HSV color-space augmentation\n    if hgain or sgain or vgain:\n        r = np.random.uniform(-1, 1, 3) * [hgain, sgain, vgain] + 1  # random gains\n        hue, sat, val = cv2.split(cv2.cvtColor(im, cv2.COLOR_BGR2HSV))\n        dtype = im.dtype  # uint8\n\n        x = np.arange(0, 256, dtype=r.dtype)\n        lut_hue = ((x * r[0]) % 180).astype(dtype)\n        lut_sat = np.clip(x * r[1], 0, 255).astype(dtype)\n        lut_val = np.clip(x * r[2], 0, 255).astype(dtype)\n\n        im_hsv = cv2.merge((cv2.LUT(hue, lut_hue), cv2.LUT(sat, lut_sat), cv2.LUT(val, lut_val)))\n        cv2.cvtColor(im_hsv, cv2.COLOR_HSV2BGR, dst=im)  # no return needed", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def hist_equalize(im, clahe=True, bgr=False):\n    # Equalize histogram on BGR image 'im' with im.shape(n,m,3) and range 0-255\n    yuv = cv2.cvtColor(im, cv2.COLOR_BGR2YUV if bgr else cv2.COLOR_RGB2YUV)\n    if clahe:\n        c = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\n        yuv[:, :, 0] = c.apply(yuv[:, :, 0])\n    else:\n        yuv[:, :, 0] = cv2.equalizeHist(yuv[:, :, 0])  # equalize Y channel histogram\n    return cv2.cvtColor(yuv, cv2.COLOR_YUV2BGR if bgr else cv2.COLOR_YUV2RGB)  # convert YUV image to RGB", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def replicate(im, labels):\n    # Replicate labels\n    h, w = im.shape[:2]\n    boxes = labels[:, 1:].astype(int)\n    x1, y1, x2, y2 = boxes.T\n    s = ((x2 - x1) + (y2 - y1)) / 2  # side length (pixels)\n    for i in s.argsort()[:round(s.size * 0.5)]:  # smallest indices\n        x1b, y1b, x2b, y2b = boxes[i]\n        bh, bw = y2b - y1b, x2b - x1b\n        yc, xc = int(random.uniform(0, h - bh)), int(random.uniform(0, w - bw))  # offset x, y\n        x1a, y1a, x2a, y2a = [xc, yc, xc + bw, yc + bh]\n        im[y1a:y2a, x1a:x2a] = im[y1b:y2b, x1b:x2b]  # im4[ymin:ymax, xmin:xmax]\n        labels = np.append(labels, [[labels[i, 0], x1a, y1a, x2a, y2a]], axis=0)\n\n    return im, labels", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def letterbox(im, new_shape=(640, 640), color=(114, 114, 114), auto=True, scaleFill=False, scaleup=True, stride=32):\n    # Resize and pad image while meeting stride-multiple constraints\n    shape = im.shape[:2]  # current shape [height, width]\n    if isinstance(new_shape, int):\n        new_shape = (new_shape, new_shape)\n\n    # Scale ratio (new / old)\n    r = min(new_shape[0] / shape[0], new_shape[1] / shape[1])\n    if not scaleup:  # only scale down, do not scale up (for better val mAP)\n        r = min(r, 1.0)\n\n    # Compute padding\n    ratio = r, r  # width, height ratios\n    new_unpad = int(round(shape[1] * r)), int(round(shape[0] * r))\n    dw, dh = new_shape[1] - new_unpad[0], new_shape[0] - new_unpad[1]  # wh padding\n    if auto:  # minimum rectangle\n        dw, dh = np.mod(dw, stride), np.mod(dh, stride)  # wh padding\n    elif scaleFill:  # stretch\n        dw, dh = 0.0, 0.0\n        new_unpad = (new_shape[1], new_shape[0])\n        ratio = new_shape[1] / shape[1], new_shape[0] / shape[0]  # width, height ratios\n\n    dw /= 2  # divide padding into 2 sides\n    dh /= 2\n\n    if shape[::-1] != new_unpad:  # resize\n        im = cv2.resize(im, new_unpad, interpolation=cv2.INTER_LINEAR)\n    top, bottom = int(round(dh - 0.1)), int(round(dh + 0.1))\n    left, right = int(round(dw - 0.1)), int(round(dw + 0.1))\n    im = cv2.copyMakeBorder(im, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)  # add border\n    return im, ratio, (dw, dh)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def random_perspective(im,\n                       targets=(),\n                       segments=(),\n                       degrees=10,\n                       translate=.1,\n                       scale=.1,\n                       shear=10,\n                       perspective=0.0,\n                       border=(0, 0)):\n    # torchvision.transforms.RandomAffine(degrees=(-10, 10), translate=(0.1, 0.1), scale=(0.9, 1.1), shear=(-10, 10))\n    # targets = [cls, xyxy]\n\n    height = im.shape[0] + border[0] * 2  # shape(h,w,c)\n    width = im.shape[1] + border[1] * 2\n\n    # Center\n    C = np.eye(3)\n    C[0, 2] = -im.shape[1] / 2  # x translation (pixels)\n    C[1, 2] = -im.shape[0] / 2  # y translation (pixels)\n\n    # Perspective\n    P = np.eye(3)\n    P[2, 0] = random.uniform(-perspective, perspective)  # x perspective (about y)\n    P[2, 1] = random.uniform(-perspective, perspective)  # y perspective (about x)\n\n    # Rotation and Scale\n    R = np.eye(3)\n    a = random.uniform(-degrees, degrees)\n    # a += random.choice([-180, -90, 0, 90])  # add 90deg rotations to small rotations\n    s = random.uniform(1 - scale, 1 + scale)\n    # s = 2 ** random.uniform(-scale, scale)\n    R[:2] = cv2.getRotationMatrix2D(angle=a, center=(0, 0), scale=s)\n\n    # Shear\n    S = np.eye(3)\n    S[0, 1] = math.tan(random.uniform(-shear, shear) * math.pi / 180)  # x shear (deg)\n    S[1, 0] = math.tan(random.uniform(-shear, shear) * math.pi / 180)  # y shear (deg)\n\n    # Translation\n    T = np.eye(3)\n    T[0, 2] = random.uniform(0.5 - translate, 0.5 + translate) * width  # x translation (pixels)\n    T[1, 2] = random.uniform(0.5 - translate, 0.5 + translate) * height  # y translation (pixels)\n\n    # Combined rotation matrix\n    M = T @ S @ R @ P @ C  # order of operations (right to left) is IMPORTANT\n    if (border[0] != 0) or (border[1] != 0) or (M != np.eye(3)).any():  # image changed\n        if perspective:\n            im = cv2.warpPerspective(im, M, dsize=(width, height), borderValue=(114, 114, 114))\n        else:  # affine\n            im = cv2.warpAffine(im, M[:2], dsize=(width, height), borderValue=(114, 114, 114))\n\n    # Visualize\n    # import matplotlib.pyplot as plt\n    # ax = plt.subplots(1, 2, figsize=(12, 6))[1].ravel()\n    # ax[0].imshow(im[:, :, ::-1])  # base\n    # ax[1].imshow(im2[:, :, ::-1])  # warped\n\n    # Transform label coordinates\n    n = len(targets)\n    if n:\n        use_segments = any(x.any() for x in segments)\n        new = np.zeros((n, 4))\n        if use_segments:  # warp segments\n            segments = resample_segments(segments)  # upsample\n            for i, segment in enumerate(segments):\n                xy = np.ones((len(segment), 3))\n                xy[:, :2] = segment\n                xy = xy @ M.T  # transform\n                xy = xy[:, :2] / xy[:, 2:3] if perspective else xy[:, :2]  # perspective rescale or affine\n\n                # clip\n                new[i] = segment2box(xy, width, height)\n\n        else:  # warp boxes\n            xy = np.ones((n * 4, 3))\n            xy[:, :2] = targets[:, [1, 2, 3, 4, 1, 4, 3, 2]].reshape(n * 4, 2)  # x1y1, x2y2, x1y2, x2y1\n            xy = xy @ M.T  # transform\n            xy = (xy[:, :2] / xy[:, 2:3] if perspective else xy[:, :2]).reshape(n, 8)  # perspective rescale or affine\n\n            # create new boxes\n            x = xy[:, [0, 2, 4, 6]]\n            y = xy[:, [1, 3, 5, 7]]\n            new = np.concatenate((x.min(1), y.min(1), x.max(1), y.max(1))).reshape(4, n).T\n\n            # clip\n            new[:, [0, 2]] = new[:, [0, 2]].clip(0, width)\n            new[:, [1, 3]] = new[:, [1, 3]].clip(0, height)\n\n        # filter candidates\n        i = box_candidates(box1=targets[:, 1:5].T * s, box2=new.T, area_thr=0.01 if use_segments else 0.10)\n        targets = targets[i]\n        targets[:, 1:5] = new[i]\n\n    return im, targets", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def copy_paste(im, labels, segments, p=0.5):\n    # Implement Copy-Paste augmentation https://arxiv.org/abs/2012.07177, labels as nx5 np.array(cls, xyxy)\n    n = len(segments)\n    if p and n:\n        h, w, c = im.shape  # height, width, channels\n        im_new = np.zeros(im.shape, np.uint8)\n        for j in random.sample(range(n), k=round(p * n)):\n            l, s = labels[j], segments[j]\n            box = w - l[3], l[2], w - l[1], l[4]\n            ioa = bbox_ioa(box, labels[:, 1:5])  # intersection over area\n            if (ioa < 0.30).all():  # allow 30% obscuration of existing labels\n                labels = np.concatenate((labels, [[l[0], *box]]), 0)\n                segments.append(np.concatenate((w - s[:, 0:1], s[:, 1:2]), 1))\n                cv2.drawContours(im_new, [segments[j].astype(np.int32)], -1, (1, 1, 1), cv2.FILLED)\n\n        result = cv2.flip(im, 1)  # augment segments (flip left-right)\n        i = cv2.flip(im_new, 1).astype(bool)\n        im[i] = result[i]  # cv2.imwrite('debug.jpg', im)  # debug\n\n    return im, labels, segments", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def cutout(im, labels, p=0.5):\n    # Applies image cutout augmentation https://arxiv.org/abs/1708.04552\n    if random.random() < p:\n        h, w = im.shape[:2]\n        scales = [0.5] * 1 + [0.25] * 2 + [0.125] * 4 + [0.0625] * 8 + [0.03125] * 16  # image size fraction\n        for s in scales:\n            mask_h = random.randint(1, int(h * s))  # create random masks\n            mask_w = random.randint(1, int(w * s))\n\n            # box\n            xmin = max(0, random.randint(0, w) - mask_w // 2)\n            ymin = max(0, random.randint(0, h) - mask_h // 2)\n            xmax = min(w, xmin + mask_w)\n            ymax = min(h, ymin + mask_h)\n\n            # apply random color mask\n            im[ymin:ymax, xmin:xmax] = [random.randint(64, 191) for _ in range(3)]\n\n            # return unobscured labels\n            if len(labels) and s > 0.03:\n                box = np.array([xmin, ymin, xmax, ymax], dtype=np.float32)\n                ioa = bbox_ioa(box, xywhn2xyxy(labels[:, 1:5], w, h))  # intersection over area\n                labels = labels[ioa < 0.60]  # remove >60% obscured labels\n\n    return labels", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def mixup(im, labels, im2, labels2):\n    # Applies MixUp augmentation https://arxiv.org/pdf/1710.09412.pdf\n    r = np.random.beta(32.0, 32.0)  # mixup ratio, alpha=beta=32.0\n    im = (im * r + im2 * (1 - r)).astype(np.uint8)\n    labels = np.concatenate((labels, labels2), 0)\n    return im, labels", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def box_candidates(box1, box2, wh_thr=2, ar_thr=100, area_thr=0.1, eps=1e-16):  # box1(4,n), box2(4,n)\n    # Compute candidate boxes: box1 before augment, box2 after augment, wh_thr (pixels), aspect_ratio_thr, area_ratio\n    w1, h1 = box1[2] - box1[0], box1[3] - box1[1]\n    w2, h2 = box2[2] - box2[0], box2[3] - box2[1]\n    ar = np.maximum(w2 / (h2 + eps), h2 / (w2 + eps))  # aspect ratio\n    return (w2 > wh_thr) & (h2 > wh_thr) & (w2 * h2 / (w1 * h1 + eps) > area_thr) & (ar < ar_thr)  # candidates", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def classify_albumentations(\n        augment=True,\n        size=224,\n        scale=(0.08, 1.0),\n        ratio=(0.75, 1.0 / 0.75),  # 0.75, 1.33\n        hflip=0.5,\n        vflip=0.0,\n        jitter=0.4,\n        mean=IMAGENET_MEAN,\n        std=IMAGENET_STD,\n        auto_aug=False):\n    # YOLOv5 classification Albumentations (optional, only used if package is installed)\n    prefix = colorstr('albumentations: ')\n    try:\n        import albumentations as A\n        from albumentations.pytorch import ToTensorV2\n        check_version(A.__version__, '1.0.3', hard=True)  # version requirement\n        if augment:  # Resize and crop\n            T = [A.RandomResizedCrop(height=size, width=size, scale=scale, ratio=ratio)]\n            if auto_aug:\n                # TODO: implement AugMix, AutoAug & RandAug in albumentation\n                LOGGER.info(f'{prefix}auto augmentations are currently not supported')\n            else:\n                if hflip > 0:\n                    T += [A.HorizontalFlip(p=hflip)]\n                if vflip > 0:\n                    T += [A.VerticalFlip(p=vflip)]\n                if jitter > 0:\n                    color_jitter = (float(jitter),) * 3  # repeat value for brightness, contrast, satuaration, 0 hue\n                    T += [A.ColorJitter(*color_jitter, 0)]\n        else:  # Use fixed crop for eval set (reproducibility)\n            T = [A.SmallestMaxSize(max_size=size), A.CenterCrop(height=size, width=size)]\n        T += [A.Normalize(mean=mean, std=std), ToTensorV2()]  # Normalize and convert to Tensor\n        LOGGER.info(prefix + ', '.join(f'{x}'.replace('always_apply=False, ', '') for x in T if x.p))\n        return A.Compose(T)\n\n    except ImportError:  # package not installed, skip\n        LOGGER.warning(f'{prefix}\u26a0\ufe0f not found, install with `pip install albumentations` (recommended)')\n    except Exception as e:\n        LOGGER.info(f'{prefix}{e}')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def classify_transforms(size=224):\n    # Transforms to apply if albumentations not installed\n    assert isinstance(size, int), f'ERROR: classify_transforms size {size} must be integer, not (list, tuple)'\n    # T.Compose([T.ToTensor(), T.Resize(size), T.CenterCrop(size), T.Normalize(IMAGENET_MEAN, IMAGENET_STD)])\n    return T.Compose([CenterCrop(size), ToTensor(), T.Normalize(IMAGENET_MEAN, IMAGENET_STD)])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, size=640):\n        self.transform = None\n        prefix = colorstr('albumentations: ')\n        try:\n            import albumentations as A\n            check_version(A.__version__, '1.0.3', hard=True)  # version requirement\n\n            T = [\n                A.RandomResizedCrop(height=size, width=size, scale=(0.8, 1.0), ratio=(0.9, 1.11), p=0.0),\n                A.Blur(p=0.01),\n                A.MedianBlur(p=0.01),\n                A.ToGray(p=0.01),\n                A.CLAHE(p=0.01),\n                A.RandomBrightnessContrast(p=0.0),\n                A.RandomGamma(p=0.0),\n                A.ImageCompression(quality_lower=75, p=0.0)]  # transforms\n            self.transform = A.Compose(T, bbox_params=A.BboxParams(format='yolo', label_fields=['class_labels']))\n\n            LOGGER.info(prefix + ', '.join(f'{x}'.replace('always_apply=False, ', '') for x in T if x.p))\n        except ImportError:  # package not installed, skip\n            pass\n        except Exception as e:\n            LOGGER.info(f'{prefix}{e}')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __call__(self, im, labels, p=1.0):\n        if self.transform and random.random() < p:\n            new = self.transform(image=im, bboxes=labels[:, 1:], class_labels=labels[:, 0])  # transformed\n            im, labels = new['image'], np.array([[c, *b] for c, b in zip(new['class_labels'], new['bboxes'])])\n        return im, labels", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, size=(640, 640), auto=False, stride=32):\n        super().__init__()\n        self.h, self.w = (size, size) if isinstance(size, int) else size\n        self.auto = auto  # pass max size integer, automatically solve for short side using stride\n        self.stride = stride  # used with auto", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __call__(self, im):  # im = np.array HWC\n        imh, imw = im.shape[:2]\n        r = min(self.h / imh, self.w / imw)  # ratio of new/old\n        h, w = round(imh * r), round(imw * r)  # resized image\n        hs, ws = (math.ceil(x / self.stride) * self.stride for x in (h, w)) if self.auto else self.h, self.w\n        top, left = round((hs - h) / 2 - 0.1), round((ws - w) / 2 - 0.1)\n        im_out = np.full((self.h, self.w, 3), 114, dtype=im.dtype)\n        im_out[top:top + h, left:left + w] = cv2.resize(im, (w, h), interpolation=cv2.INTER_LINEAR)\n        return im_out", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, size=640):\n        super().__init__()\n        self.h, self.w = (size, size) if isinstance(size, int) else size", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __call__(self, im):  # im = np.array HWC\n        imh, imw = im.shape[:2]\n        m = min(imh, imw)  # min dimension\n        top, left = (imh - m) // 2, (imw - m) // 2\n        return cv2.resize(im[top:top + m, left:left + m], (self.w, self.h), interpolation=cv2.INTER_LINEAR)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, half=False):\n        super().__init__()\n        self.half = half", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __call__(self, im):  # im = np.array HWC in BGR order\n        im = np.ascontiguousarray(im.transpose((2, 0, 1))[::-1])  # HWC to CHW -> BGR to RGB -> contiguous\n        im = torch.from_numpy(im)  # to torch\n        im = im.half() if self.half else im.float()  # uint8 to fp16/32\n        im /= 255.0  # 0-255 to 0.0-1.0\n        return im", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def attempt_load(weights, device=None, inplace=True, fuse=True):\n    # Loads an ensemble of models weights=[a,b,c] or a single model weights=[a] or weights=a\n    from models.yolo import Detect, Model\n\n    model = Ensemble()\n    for w in weights if isinstance(weights, list) else [weights]:\n        ckpt = torch.load(attempt_download(w), map_location='cpu')  # load\n        ckpt = (ckpt.get('ema') or ckpt['model']).to(device).float()  # FP32 model\n\n        # Model compatibility updates\n        if not hasattr(ckpt, 'stride'):\n            ckpt.stride = torch.tensor([32.])\n        if hasattr(ckpt, 'names') and isinstance(ckpt.names, (list, tuple)):\n            ckpt.names = dict(enumerate(ckpt.names))  # convert to dict\n\n        model.append(ckpt.fuse().eval() if fuse and hasattr(ckpt, 'fuse') else ckpt.eval())  # model in eval mode\n\n    # Module compatibility updates\n    for m in model.modules():\n        t = type(m)\n        if t in (nn.Hardswish, nn.LeakyReLU, nn.ReLU, nn.ReLU6, nn.SiLU, Detect, Model):\n            m.inplace = inplace  # torch 1.7.0 compatibility\n            if t is Detect and not isinstance(m.anchor_grid, list):\n                delattr(m, 'anchor_grid')\n                setattr(m, 'anchor_grid', [torch.zeros(1)] * m.nl)\n        elif t is nn.Upsample and not hasattr(m, 'recompute_scale_factor'):\n            m.recompute_scale_factor = None  # torch 1.11.0 compatibility\n\n    # Return model\n    if len(model) == 1:\n        return model[-1]\n\n    # Return detection ensemble\n    print(f'Ensemble created with {weights}\\n')\n    for k in 'names', 'nc', 'yaml':\n        setattr(model, k, getattr(model[0], k))\n    model.stride = model[torch.argmax(torch.tensor([m.stride.max() for m in model])).int()].stride  # max stride\n    assert all(model[0].nc == m.nc for m in model), f'Models have different class counts: {[m.nc for m in model]}'\n    return model", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, n, weight=False):  # n: number of inputs\n        super().__init__()\n        self.weight = weight  # apply weights boolean\n        self.iter = range(n - 1)  # iter object\n        if weight:\n            self.w = nn.Parameter(-torch.arange(1.0, n) / 2, requires_grad=True)  # layer weights", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        y = x[0]  # no weight\n        if self.weight:\n            w = torch.sigmoid(self.w) * 2\n            for i in self.iter:\n                y = y + x[i + 1] * w[i]\n        else:\n            for i in self.iter:\n                y = y + x[i + 1]\n        return y", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=(1, 3), s=1, equal_ch=True):  # ch_in, ch_out, kernel, stride, ch_strategy\n        super().__init__()\n        n = len(k)  # number of convolutions\n        if equal_ch:  # equal c_ per group\n            i = torch.linspace(0, n - 1E-6, c2).floor()  # c2 indices\n            c_ = [(i == g).sum() for g in range(n)]  # intermediate channels\n        else:  # equal weight.numel() per group\n            b = [c2] + [0] * n\n            a = np.eye(n + 1, n, k=-1)\n            a -= np.roll(a, 1, axis=1)\n            a *= np.array(k) ** 2\n            a[0] = 1\n            c_ = np.linalg.lstsq(a, b, rcond=None)[0].round()  # solve for equal weight indices, ax = b\n\n        self.m = nn.ModuleList([\n            nn.Conv2d(c1, int(c_), k, s, k // 2, groups=math.gcd(c1, int(c_)), bias=False) for k, c_ in zip(k, c_)])\n        self.bn = nn.BatchNorm2d(c2)\n        self.act = nn.SiLU()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        return self.act(self.bn(torch.cat([m(x) for m in self.m], 1)))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self):\n        super().__init__()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x, augment=False, profile=False, visualize=False):\n        y = [module(x, augment, profile, visualize)[0] for module in self]\n        # y = torch.stack(y).max(0)[0]  # max ensemble\n        # y = torch.stack(y).mean(0)  # mean ensemble\n        y = torch.cat(y, 1)  # nms ensemble\n        return y, None  # inference, train output", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_model(d, ch, model, imgsz):  # model_dict, input_channels(3)\n    LOGGER.info(f\"\\n{'':>3}{'from':>18}{'n':>3}{'params':>10}  {'module':<40}{'arguments':<30}\")\n    anchors, nc, gd, gw = d['anchors'], d['nc'], d['depth_multiple'], d['width_multiple']\n    na = (len(anchors[0]) // 2) if isinstance(anchors, list) else anchors  # number of anchors\n    no = na * (nc + 5)  # number of outputs = anchors * (classes + 5)\n\n    layers, save, c2 = [], [], ch[-1]  # layers, savelist, ch out\n    for i, (f, n, m, args) in enumerate(d['backbone'] + d['head']):  # from, number, module, args\n        m_str = m\n        m = eval(m) if isinstance(m, str) else m  # eval strings\n        for j, a in enumerate(args):\n            try:\n                args[j] = eval(a) if isinstance(a, str) else a  # eval strings\n            except NameError:\n                pass\n\n        n = max(round(n * gd), 1) if n > 1 else n  # depth gain\n        if m in [\n                nn.Conv2d, Conv, DWConv, DWConvTranspose2d, Bottleneck, SPP, SPPF, MixConv2d, Focus, CrossConv,\n                BottleneckCSP, C3, C3x]:\n            c1, c2 = ch[f], args[0]\n            c2 = make_divisible(c2 * gw, 8) if c2 != no else c2\n\n            args = [c1, c2, *args[1:]]\n            if m in [BottleneckCSP, C3, C3x]:\n                args.insert(2, n)\n                n = 1\n        elif m is nn.BatchNorm2d:\n            args = [ch[f]]\n        elif m is Concat:\n            c2 = sum(ch[-1 if x == -1 else x + 1] for x in f)\n        elif m in [Detect, Segment]:\n            args.append([ch[x + 1] for x in f])\n            if isinstance(args[1], int):  # number of anchors\n                args[1] = [list(range(args[1] * 2))] * len(f)\n            if m is Segment:\n                args[3] = make_divisible(args[3] * gw, 8)\n            args.append(imgsz)\n        else:\n            c2 = ch[f]\n\n        tf_m = eval('TF' + m_str.replace('nn.', ''))\n        m_ = keras.Sequential([tf_m(*args, w=model.model[i][j]) for j in range(n)]) if n > 1 \\\n            else tf_m(*args, w=model.model[i])  # module\n\n        torch_m_ = nn.Sequential(*(m(*args) for _ in range(n))) if n > 1 else m(*args)  # module\n        t = str(m)[8:-2].replace('__main__.', '')  # module type\n        np = sum(x.numel() for x in torch_m_.parameters())  # number params\n        m_.i, m_.f, m_.type, m_.np = i, f, t, np  # attach index, 'from' index, type, number params\n        LOGGER.info(f'{i:>3}{str(f):>18}{str(n):>3}{np:>10}  {t:<40}{str(args):<30}')  # print\n        save.extend(x % i for x in ([f] if isinstance(f, int) else f) if x != -1)  # append to savelist\n        layers.append(m_)\n        ch.append(c2)\n    return keras.Sequential(layers), sorted(save)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def activations(act=nn.SiLU):\n    # Returns TF activation from input PyTorch activation\n    if isinstance(act, nn.LeakyReLU):\n        return lambda x: keras.activations.relu(x, alpha=0.1)\n    elif isinstance(act, nn.Hardswish):\n        return lambda x: x * tf.nn.relu6(x + 3) * 0.166666667\n    elif isinstance(act, (nn.SiLU, SiLU)):\n        return lambda x: keras.activations.swish(x)\n    else:\n        raise Exception(f'no matching TensorFlow activation found for PyTorch activation {act}')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def representative_dataset_gen(dataset, ncalib=100):\n    # Representative dataset generator for use with converter.representative_dataset, returns a generator of np arrays\n    for n, (path, img, im0s, vid_cap, string) in enumerate(dataset):\n        im = np.transpose(img, [1, 2, 0])\n        im = np.expand_dims(im, axis=0).astype(np.float32)\n        im /= 255\n        yield [im]\n        if n >= ncalib:\n            break", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run(\n        weights=ROOT / 'yolov5s.pt',  # weights path\n        imgsz=(640, 640),  # inference size h,w\n        batch_size=1,  # batch size\n        dynamic=False,  # dynamic batch size\n):\n    # PyTorch model\n    im = torch.zeros((batch_size, 3, *imgsz))  # BCHW image\n    model = attempt_load(weights, device=torch.device('cpu'), inplace=True, fuse=False)\n    _ = model(im)  # inference\n    model.info()\n\n    # TensorFlow model\n    im = tf.zeros((batch_size, *imgsz, 3))  # BHWC image\n    tf_model = TFModel(cfg=model.yaml, model=model, nc=model.nc, imgsz=imgsz)\n    _ = tf_model.predict(im)  # inference\n\n    # Keras model\n    im = keras.Input(shape=(*imgsz, 3), batch_size=None if dynamic else batch_size)\n    keras_model = keras.Model(inputs=im, outputs=tf_model.predict(im))\n    keras_model.summary()\n\n    LOGGER.info('PyTorch, TensorFlow and Keras models successfully verified.\\nUse export.py for TF model export.')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_opt():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--weights', type=str, default=ROOT / 'yolov5s.pt', help='weights path')\n    parser.add_argument('--imgsz', '--img', '--img-size', nargs='+', type=int, default=[640], help='inference size h,w')\n    parser.add_argument('--batch-size', type=int, default=1, help='batch size')\n    parser.add_argument('--dynamic', action='store_true', help='dynamic batch size')\n    opt = parser.parse_args()\n    opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # expand\n    print_args(vars(opt))\n    return opt", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(opt):\n    run(**vars(opt))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, w=None):\n        super().__init__()\n        self.bn = keras.layers.BatchNormalization(\n            beta_initializer=keras.initializers.Constant(w.bias.numpy()),\n            gamma_initializer=keras.initializers.Constant(w.weight.numpy()),\n            moving_mean_initializer=keras.initializers.Constant(w.running_mean.numpy()),\n            moving_variance_initializer=keras.initializers.Constant(w.running_var.numpy()),\n            epsilon=w.eps)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        return self.bn(inputs)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, pad):\n        super().__init__()\n        if isinstance(pad, int):\n            self.pad = tf.constant([[0, 0], [pad, pad], [pad, pad], [0, 0]])\n        else:  # tuple/list\n            self.pad = tf.constant([[0, 0], [pad[0], pad[0]], [pad[1], pad[1]], [0, 0]])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        return tf.pad(inputs, self.pad, mode='constant', constant_values=0)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True, w=None):\n        # ch_in, ch_out, weights, kernel, stride, padding, groups\n        super().__init__()\n        assert g == 1, \"TF v2.2 Conv2D does not support 'groups' argument\"\n        # TensorFlow convolution padding is inconsistent with PyTorch (e.g. k=3 s=2 'SAME' padding)\n        # see https://stackoverflow.com/questions/52975843/comparing-conv2d-with-padding-between-tensorflow-and-pytorch\n        conv = keras.layers.Conv2D(\n            filters=c2,\n            kernel_size=k,\n            strides=s,\n            padding='SAME' if s == 1 else 'VALID',\n            use_bias=not hasattr(w, 'bn'),\n            kernel_initializer=keras.initializers.Constant(w.conv.weight.permute(2, 3, 1, 0).numpy()),\n            bias_initializer='zeros' if hasattr(w, 'bn') else keras.initializers.Constant(w.conv.bias.numpy()))\n        self.conv = conv if s == 1 else keras.Sequential([TFPad(autopad(k, p)), conv])\n        self.bn = TFBN(w.bn) if hasattr(w, 'bn') else tf.identity\n        self.act = activations(w.act) if act else tf.identity", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        return self.act(self.bn(self.conv(inputs)))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=1, s=1, p=None, act=True, w=None):\n        # ch_in, ch_out, weights, kernel, stride, padding, groups\n        super().__init__()\n        assert c2 % c1 == 0, f'TFDWConv() output={c2} must be a multiple of input={c1} channels'\n        conv = keras.layers.DepthwiseConv2D(\n            kernel_size=k,\n            depth_multiplier=c2 // c1,\n            strides=s,\n            padding='SAME' if s == 1 else 'VALID',\n            use_bias=not hasattr(w, 'bn'),\n            depthwise_initializer=keras.initializers.Constant(w.conv.weight.permute(2, 3, 1, 0).numpy()),\n            bias_initializer='zeros' if hasattr(w, 'bn') else keras.initializers.Constant(w.conv.bias.numpy()))\n        self.conv = conv if s == 1 else keras.Sequential([TFPad(autopad(k, p)), conv])\n        self.bn = TFBN(w.bn) if hasattr(w, 'bn') else tf.identity\n        self.act = activations(w.act) if act else tf.identity", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        return self.act(self.bn(self.conv(inputs)))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=1, s=1, p1=0, p2=0, w=None):\n        # ch_in, ch_out, weights, kernel, stride, padding, groups\n        super().__init__()\n        assert c1 == c2, f'TFDWConv() output={c2} must be equal to input={c1} channels'\n        assert k == 4 and p1 == 1, 'TFDWConv() only valid for k=4 and p1=1'\n        weight, bias = w.weight.permute(2, 3, 1, 0).numpy(), w.bias.numpy()\n        self.c1 = c1\n        self.conv = [\n            keras.layers.Conv2DTranspose(filters=1,\n                                         kernel_size=k,\n                                         strides=s,\n                                         padding='VALID',\n                                         output_padding=p2,\n                                         use_bias=True,\n                                         kernel_initializer=keras.initializers.Constant(weight[..., i:i + 1]),\n                                         bias_initializer=keras.initializers.Constant(bias[i])) for i in range(c1)]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        return tf.concat([m(x) for m, x in zip(self.conv, tf.split(inputs, self.c1, 3))], 3)[:, 1:-1, 1:-1]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True, w=None):\n        # ch_in, ch_out, kernel, stride, padding, groups\n        super().__init__()\n        self.conv = TFConv(c1 * 4, c2, k, s, p, g, act, w.conv)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):  # x(b,w,h,c) -> y(b,w/2,h/2,4c)\n        # inputs = inputs / 255  # normalize 0-255 to 0-1\n        inputs = [inputs[:, ::2, ::2, :], inputs[:, 1::2, ::2, :], inputs[:, ::2, 1::2, :], inputs[:, 1::2, 1::2, :]]\n        return self.conv(tf.concat(inputs, 3))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, shortcut=True, g=1, e=0.5, w=None):  # ch_in, ch_out, shortcut, groups, expansion\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = TFConv(c1, c_, 1, 1, w=w.cv1)\n        self.cv2 = TFConv(c_, c2, 3, 1, g=g, w=w.cv2)\n        self.add = shortcut and c1 == c2", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        return inputs + self.cv2(self.cv1(inputs)) if self.add else self.cv2(self.cv1(inputs))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=3, s=1, g=1, e=1.0, shortcut=False, w=None):\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = TFConv(c1, c_, (1, k), (1, s), w=w.cv1)\n        self.cv2 = TFConv(c_, c2, (k, 1), (s, 1), g=g, w=w.cv2)\n        self.add = shortcut and c1 == c2", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        return inputs + self.cv2(self.cv1(inputs)) if self.add else self.cv2(self.cv1(inputs))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k, s=1, g=1, bias=True, w=None):\n        super().__init__()\n        assert g == 1, \"TF v2.2 Conv2D does not support 'groups' argument\"\n        self.conv = keras.layers.Conv2D(filters=c2,\n                                        kernel_size=k,\n                                        strides=s,\n                                        padding='VALID',\n                                        use_bias=bias,\n                                        kernel_initializer=keras.initializers.Constant(\n                                            w.weight.permute(2, 3, 1, 0).numpy()),\n                                        bias_initializer=keras.initializers.Constant(w.bias.numpy()) if bias else None)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        return self.conv(inputs)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5, w=None):\n        # ch_in, ch_out, number, shortcut, groups, expansion\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = TFConv(c1, c_, 1, 1, w=w.cv1)\n        self.cv2 = TFConv2d(c1, c_, 1, 1, bias=False, w=w.cv2)\n        self.cv3 = TFConv2d(c_, c_, 1, 1, bias=False, w=w.cv3)\n        self.cv4 = TFConv(2 * c_, c2, 1, 1, w=w.cv4)\n        self.bn = TFBN(w.bn)\n        self.act = lambda x: keras.activations.swish(x)\n        self.m = keras.Sequential([TFBottleneck(c_, c_, shortcut, g, e=1.0, w=w.m[j]) for j in range(n)])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        y1 = self.cv3(self.m(self.cv1(inputs)))\n        y2 = self.cv2(inputs)\n        return self.cv4(self.act(self.bn(tf.concat((y1, y2), axis=3))))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5, w=None):\n        # ch_in, ch_out, number, shortcut, groups, expansion\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = TFConv(c1, c_, 1, 1, w=w.cv1)\n        self.cv2 = TFConv(c1, c_, 1, 1, w=w.cv2)\n        self.cv3 = TFConv(2 * c_, c2, 1, 1, w=w.cv3)\n        self.m = keras.Sequential([TFBottleneck(c_, c_, shortcut, g, e=1.0, w=w.m[j]) for j in range(n)])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        return self.cv3(tf.concat((self.m(self.cv1(inputs)), self.cv2(inputs)), axis=3))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5, w=None):\n        # ch_in, ch_out, number, shortcut, groups, expansion\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = TFConv(c1, c_, 1, 1, w=w.cv1)\n        self.cv2 = TFConv(c1, c_, 1, 1, w=w.cv2)\n        self.cv3 = TFConv(2 * c_, c2, 1, 1, w=w.cv3)\n        self.m = keras.Sequential([\n            TFCrossConv(c_, c_, k=3, s=1, g=g, e=1.0, shortcut=shortcut, w=w.m[j]) for j in range(n)])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        return self.cv3(tf.concat((self.m(self.cv1(inputs)), self.cv2(inputs)), axis=3))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=(5, 9, 13), w=None):\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = TFConv(c1, c_, 1, 1, w=w.cv1)\n        self.cv2 = TFConv(c_ * (len(k) + 1), c2, 1, 1, w=w.cv2)\n        self.m = [keras.layers.MaxPool2D(pool_size=x, strides=1, padding='SAME') for x in k]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        x = self.cv1(inputs)\n        return self.cv2(tf.concat([x] + [m(x) for m in self.m], 3))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=5, w=None):\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = TFConv(c1, c_, 1, 1, w=w.cv1)\n        self.cv2 = TFConv(c_ * 4, c2, 1, 1, w=w.cv2)\n        self.m = keras.layers.MaxPool2D(pool_size=k, strides=1, padding='SAME')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        x = self.cv1(inputs)\n        y1 = self.m(x)\n        y2 = self.m(y1)\n        return self.cv2(tf.concat([x, y1, y2, self.m(y2)], 3))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, nc=80, anchors=(), ch=(), imgsz=(640, 640), w=None):  # detection layer\n        super().__init__()\n        self.stride = tf.convert_to_tensor(w.stride.numpy(), dtype=tf.float32)\n        self.nc = nc  # number of classes\n        self.no = nc + 5  # number of outputs per anchor\n        self.nl = len(anchors)  # number of detection layers\n        self.na = len(anchors[0]) // 2  # number of anchors\n        self.grid = [tf.zeros(1)] * self.nl  # init grid\n        self.anchors = tf.convert_to_tensor(w.anchors.numpy(), dtype=tf.float32)\n        self.anchor_grid = tf.reshape(self.anchors * tf.reshape(self.stride, [self.nl, 1, 1]), [self.nl, 1, -1, 1, 2])\n        self.m = [TFConv2d(x, self.no * self.na, 1, w=w.m[i]) for i, x in enumerate(ch)]\n        self.training = False  # set to False after building model\n        self.imgsz = imgsz\n        for i in range(self.nl):\n            ny, nx = self.imgsz[0] // self.stride[i], self.imgsz[1] // self.stride[i]\n            self.grid[i] = self._make_grid(nx, ny)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        z = []  # inference output\n        x = []\n        for i in range(self.nl):\n            x.append(self.m[i](inputs[i]))\n            # x(bs,20,20,255) to x(bs,3,20,20,85)\n            ny, nx = self.imgsz[0] // self.stride[i], self.imgsz[1] // self.stride[i]\n            x[i] = tf.reshape(x[i], [-1, ny * nx, self.na, self.no])\n\n            if not self.training:  # inference\n                y = x[i]\n                grid = tf.transpose(self.grid[i], [0, 2, 1, 3]) - 0.5\n                anchor_grid = tf.transpose(self.anchor_grid[i], [0, 2, 1, 3]) * 4\n                xy = (tf.sigmoid(y[..., 0:2]) * 2 + grid) * self.stride[i]  # xy\n                wh = tf.sigmoid(y[..., 2:4]) ** 2 * anchor_grid\n                # Normalize xywh to 0-1 to reduce calibration error\n                xy /= tf.constant([[self.imgsz[1], self.imgsz[0]]], dtype=tf.float32)\n                wh /= tf.constant([[self.imgsz[1], self.imgsz[0]]], dtype=tf.float32)\n                y = tf.concat([xy, wh, tf.sigmoid(y[..., 4:5 + self.nc]), y[..., 5 + self.nc:]], -1)\n                z.append(tf.reshape(y, [-1, self.na * ny * nx, self.no]))\n\n        return tf.transpose(x, [0, 2, 1, 3]) if self.training else (tf.concat(z, 1),)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _make_grid(nx=20, ny=20):\n        # yv, xv = torch.meshgrid([torch.arange(ny), torch.arange(nx)])\n        # return torch.stack((xv, yv), 2).view((1, 1, ny, nx, 2)).float()\n        xv, yv = tf.meshgrid(tf.range(nx), tf.range(ny))\n        return tf.cast(tf.reshape(tf.stack([xv, yv], 2), [1, 1, ny * nx, 2]), dtype=tf.float32)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, nc=80, anchors=(), nm=32, npr=256, ch=(), imgsz=(640, 640), w=None):\n        super().__init__(nc, anchors, ch, imgsz, w)\n        self.nm = nm  # number of masks\n        self.npr = npr  # number of protos\n        self.no = 5 + nc + self.nm  # number of outputs per anchor\n        self.m = [TFConv2d(x, self.no * self.na, 1, w=w.m[i]) for i, x in enumerate(ch)]  # output conv\n        self.proto = TFProto(ch[0], self.npr, self.nm, w=w.proto)  # protos\n        self.detect = TFDetect.call", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, x):\n        p = self.proto(x[0])\n        # p = TFUpsample(None, scale_factor=4, mode='nearest')(self.proto(x[0]))  # (optional) full-size protos\n        p = tf.transpose(p, [0, 3, 1, 2])  # from shape(1,160,160,32) to shape(1,32,160,160)\n        x = self.detect(self, x)\n        return (x, p) if self.training else (x[0], p)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c_=256, c2=32, w=None):\n        super().__init__()\n        self.cv1 = TFConv(c1, c_, k=3, w=w.cv1)\n        self.upsample = TFUpsample(None, scale_factor=2, mode='nearest')\n        self.cv2 = TFConv(c_, c_, k=3, w=w.cv2)\n        self.cv3 = TFConv(c_, c2, w=w.cv3)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        return self.cv3(self.cv2(self.upsample(self.cv1(inputs))))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, size, scale_factor, mode, w=None):  # warning: all arguments needed including 'w'\n        super().__init__()\n        assert scale_factor % 2 == 0, \"scale_factor must be multiple of 2\"\n        self.upsample = lambda x: tf.image.resize(x, (x.shape[1] * scale_factor, x.shape[2] * scale_factor), mode)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        return self.upsample(inputs)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, dimension=1, w=None):\n        super().__init__()\n        assert dimension == 1, \"convert only NCHW to NHWC concat\"\n        self.d = 3", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, inputs):\n        return tf.concat(inputs, self.d)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, cfg='yolov5s.yaml', ch=3, nc=None, model=None, imgsz=(640, 640)):  # model, channels, classes\n        super().__init__()\n        if isinstance(cfg, dict):\n            self.yaml = cfg  # model dict\n        else:  # is *.yaml\n            import yaml  # for torch hub\n            self.yaml_file = Path(cfg).name\n            with open(cfg) as f:\n                self.yaml = yaml.load(f, Loader=yaml.FullLoader)  # model dict\n\n        # Define model\n        if nc and nc != self.yaml['nc']:\n            LOGGER.info(f\"Overriding {cfg} nc={self.yaml['nc']} with nc={nc}\")\n            self.yaml['nc'] = nc  # override yaml value\n        self.model, self.savelist = parse_model(deepcopy(self.yaml), ch=[ch], model=model, imgsz=imgsz)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def predict(self,\n                inputs,\n                tf_nms=False,\n                agnostic_nms=False,\n                topk_per_class=100,\n                topk_all=100,\n                iou_thres=0.45,\n                conf_thres=0.25):\n        y = []  # outputs\n        x = inputs\n        for m in self.model.layers:\n            if m.f != -1:  # if not from previous layer\n                x = y[m.f] if isinstance(m.f, int) else [x if j == -1 else y[j] for j in m.f]  # from earlier layers\n\n            x = m(x)  # run\n            y.append(x if m.i in self.savelist else None)  # save output\n\n        # Add TensorFlow NMS\n        if tf_nms:\n            boxes = self._xywh2xyxy(x[0][..., :4])\n            probs = x[0][:, :, 4:5]\n            classes = x[0][:, :, 5:]\n            scores = probs * classes\n            if agnostic_nms:\n                nms = AgnosticNMS()((boxes, classes, scores), topk_all, iou_thres, conf_thres)\n            else:\n                boxes = tf.expand_dims(boxes, 2)\n                nms = tf.image.combined_non_max_suppression(boxes,\n                                                            scores,\n                                                            topk_per_class,\n                                                            topk_all,\n                                                            iou_thres,\n                                                            conf_thres,\n                                                            clip_boxes=False)\n            return (nms,)\n        return x  # output [1,6300,85] = [xywh, conf, class0, class1, ...]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _xywh2xyxy(xywh):\n        # Convert nx4 boxes from [x, y, w, h] to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right\n        x, y, w, h = tf.split(xywh, num_or_size_splits=4, axis=-1)\n        return tf.concat([x - w / 2, y - h / 2, x + w / 2, y + h / 2], axis=-1)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def call(self, input, topk_all, iou_thres, conf_thres):\n        # wrap map_fn to avoid TypeSpec related error https://stackoverflow.com/a/65809989/3036450\n        return tf.map_fn(lambda x: self._nms(x, topk_all, iou_thres, conf_thres),\n                         input,\n                         fn_output_signature=(tf.float32, tf.float32, tf.float32, tf.int32),\n                         name='agnostic_nms')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _nms(x, topk_all=100, iou_thres=0.45, conf_thres=0.25):  # agnostic NMS\n        boxes, classes, scores = x\n        class_inds = tf.cast(tf.argmax(classes, axis=-1), tf.float32)\n        scores_inp = tf.reduce_max(scores, -1)\n        selected_inds = tf.image.non_max_suppression(boxes,\n                                                     scores_inp,\n                                                     max_output_size=topk_all,\n                                                     iou_threshold=iou_thres,\n                                                     score_threshold=conf_thres)\n        selected_boxes = tf.gather(boxes, selected_inds)\n        padded_boxes = tf.pad(selected_boxes,\n                              paddings=[[0, topk_all - tf.shape(selected_boxes)[0]], [0, 0]],\n                              mode=\"CONSTANT\",\n                              constant_values=0.0)\n        selected_scores = tf.gather(scores_inp, selected_inds)\n        padded_scores = tf.pad(selected_scores,\n                               paddings=[[0, topk_all - tf.shape(selected_boxes)[0]]],\n                               mode=\"CONSTANT\",\n                               constant_values=-1.0)\n        selected_classes = tf.gather(class_inds, selected_inds)\n        padded_classes = tf.pad(selected_classes,\n                                paddings=[[0, topk_all - tf.shape(selected_boxes)[0]]],\n                                mode=\"CONSTANT\",\n                                constant_values=-1.0)\n        valid_detections = tf.shape(selected_inds)[0]\n        return padded_boxes, padded_scores, padded_classes, valid_detections", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def autopad(k, p=None, d=1):  # kernel, padding, dilation\n    # Pad to 'same' shape outputs\n    if d > 1:\n        k = d * (k - 1) + 1 if isinstance(k, int) else [d * (x - 1) + 1 for x in k]  # actual kernel-size\n    if p is None:\n        p = k // 2 if isinstance(k, int) else [x // 2 for x in k]  # auto-pad\n    return p", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, d=1, act=True):\n        super().__init__()\n        self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p, d), groups=g, dilation=d, bias=False)\n        self.bn = nn.BatchNorm2d(c2)\n        self.act = self.default_act if act is True else act if isinstance(act, nn.Module) else nn.Identity()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        return self.act(self.bn(self.conv(x)))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward_fuse(self, x):\n        return self.act(self.conv(x))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=1, s=1, d=1, act=True):  # ch_in, ch_out, kernel, stride, dilation, activation\n        super().__init__(c1, c2, k, s, g=math.gcd(c1, c2), d=d, act=act)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=1, s=1, p1=0, p2=0):  # ch_in, ch_out, kernel, stride, padding, padding_out\n        super().__init__(c1, c2, k, s, p1, p2, groups=math.gcd(c1, c2))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c, num_heads):\n        super().__init__()\n        self.q = nn.Linear(c, c, bias=False)\n        self.k = nn.Linear(c, c, bias=False)\n        self.v = nn.Linear(c, c, bias=False)\n        self.ma = nn.MultiheadAttention(embed_dim=c, num_heads=num_heads)\n        self.fc1 = nn.Linear(c, c, bias=False)\n        self.fc2 = nn.Linear(c, c, bias=False)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        x = self.ma(self.q(x), self.k(x), self.v(x))[0] + x\n        x = self.fc2(self.fc1(x)) + x\n        return x", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, num_heads, num_layers):\n        super().__init__()\n        self.conv = None\n        if c1 != c2:\n            self.conv = Conv(c1, c2)\n        self.linear = nn.Linear(c2, c2)  # learnable position embedding\n        self.tr = nn.Sequential(*(TransformerLayer(c2, num_heads) for _ in range(num_layers)))\n        self.c2 = c2", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        if self.conv is not None:\n            x = self.conv(x)\n        b, _, w, h = x.shape\n        p = x.flatten(2).permute(2, 0, 1)\n        return self.tr(p + self.linear(p)).permute(1, 2, 0).reshape(b, self.c2, w, h)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, shortcut, groups, expansion\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c_, c2, 3, 1, g=g)\n        self.add = shortcut and c1 == c2", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        return x + self.cv2(self.cv1(x)) if self.add else self.cv2(self.cv1(x))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, number, shortcut, groups, expansion\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = nn.Conv2d(c1, c_, 1, 1, bias=False)\n        self.cv3 = nn.Conv2d(c_, c_, 1, 1, bias=False)\n        self.cv4 = Conv(2 * c_, c2, 1, 1)\n        self.bn = nn.BatchNorm2d(2 * c_)  # applied to cat(cv2, cv3)\n        self.act = nn.SiLU()\n        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        y1 = self.cv3(self.m(self.cv1(x)))\n        y2 = self.cv2(x)\n        return self.cv4(self.act(self.bn(torch.cat((y1, y2), 1))))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=3, s=1, g=1, e=1.0, shortcut=False):\n        # ch_in, ch_out, kernel, stride, groups, expansion, shortcut\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, (1, k), (1, s))\n        self.cv2 = Conv(c_, c2, (k, 1), (s, 1), g=g)\n        self.add = shortcut and c1 == c2", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        return x + self.cv2(self.cv1(x)) if self.add else self.cv2(self.cv1(x))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, number, shortcut, groups, expansion\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c1, c_, 1, 1)\n        self.cv3 = Conv(2 * c_, c2, 1)  # optional act=FReLU(c2)\n        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        return self.cv3(torch.cat((self.m(self.cv1(x)), self.cv2(x)), 1))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)\n        self.m = nn.Sequential(*(CrossConv(c_, c_, 3, 1, g, 1.0, shortcut) for _ in range(n)))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)\n        self.m = TransformerBlock(c_, c_, 4, n)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=(5, 9, 13), n=1, shortcut=True, g=1, e=0.5):\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)\n        self.m = SPP(c_, c_, k)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)  # hidden channels\n        self.m = nn.Sequential(*(GhostBottleneck(c_, c_) for _ in range(n)))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=(5, 9, 13)):\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c_ * (len(k) + 1), c2, 1, 1)\n        self.m = nn.ModuleList([nn.MaxPool2d(kernel_size=x, stride=1, padding=x // 2) for x in k])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        x = self.cv1(x)\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')  # suppress torch 1.9.0 max_pool2d() warning\n            return self.cv2(torch.cat([x] + [m(x) for m in self.m], 1))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=5):  # equivalent to SPP(k=(5, 9, 13))\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c_ * 4, c2, 1, 1)\n        self.m = nn.MaxPool2d(kernel_size=k, stride=1, padding=k // 2)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        x = self.cv1(x)\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')  # suppress torch 1.9.0 max_pool2d() warning\n            y1 = self.m(x)\n            y2 = self.m(y1)\n            return self.cv2(torch.cat((x, y1, y2, self.m(y2)), 1))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True):  # ch_in, ch_out, kernel, stride, padding, groups\n        super().__init__()\n        self.conv = Conv(c1 * 4, c2, k, s, p, g, act=act)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):  # x(b,c,w,h) -> y(b,4c,w/2,h/2)\n        return self.conv(torch.cat((x[..., ::2, ::2], x[..., 1::2, ::2], x[..., ::2, 1::2], x[..., 1::2, 1::2]), 1))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=1, s=1, g=1, act=True):  # ch_in, ch_out, kernel, stride, groups\n        super().__init__()\n        c_ = c2 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, k, s, None, g, act=act)\n        self.cv2 = Conv(c_, c_, 5, 1, None, c_, act=act)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        y = self.cv1(x)\n        return torch.cat((y, self.cv2(y)), 1)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=3, s=1):  # ch_in, ch_out, kernel, stride\n        super().__init__()\n        c_ = c2 // 2\n        self.conv = nn.Sequential(\n            GhostConv(c1, c_, 1, 1),  # pw\n            DWConv(c_, c_, k, s, act=False) if s == 2 else nn.Identity(),  # dw\n            GhostConv(c_, c2, 1, 1, act=False))  # pw-linear\n        self.shortcut = nn.Sequential(DWConv(c1, c1, k, s, act=False), Conv(c1, c2, 1, 1,\n                                                                            act=False)) if s == 2 else nn.Identity()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        return self.conv(x) + self.shortcut(x)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, gain=2):\n        super().__init__()\n        self.gain = gain", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        b, c, h, w = x.size()  # assert (h / s == 0) and (W / s == 0), 'Indivisible gain'\n        s = self.gain\n        x = x.view(b, c, h // s, s, w // s, s)  # x(1,64,40,2,40,2)\n        x = x.permute(0, 3, 5, 1, 2, 4).contiguous()  # x(1,2,2,64,40,40)\n        return x.view(b, c * s * s, h // s, w // s)  # x(1,256,40,40)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, gain=2):\n        super().__init__()\n        self.gain = gain", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        b, c, h, w = x.size()  # assert C / s ** 2 == 0, 'Indivisible gain'\n        s = self.gain\n        x = x.view(b, s, s, c // s ** 2, h, w)  # x(1,2,2,16,80,80)\n        x = x.permute(0, 3, 4, 1, 5, 2).contiguous()  # x(1,16,80,2,80,2)\n        return x.view(b, c // s ** 2, h * s, w * s)  # x(1,16,160,160)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, dimension=1):\n        super().__init__()\n        self.d = dimension", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        return torch.cat(x, self.d)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, weights='yolov5s.pt', device=torch.device('cpu'), dnn=False, data=None, fp16=False, fuse=True):\n        # Usage:\n        #   PyTorch:              weights = *.pt\n        #   TorchScript:                    *.torchscript\n        #   ONNX Runtime:                   *.onnx\n        #   ONNX OpenCV DNN:                *.onnx --dnn\n        #   OpenVINO:                       *_openvino_model\n        #   CoreML:                         *.mlmodel\n        #   TensorRT:                       *.engine\n        #   TensorFlow SavedModel:          *_saved_model\n        #   TensorFlow GraphDef:            *.pb\n        #   TensorFlow Lite:                *.tflite\n        #   TensorFlow Edge TPU:            *_edgetpu.tflite\n        #   PaddlePaddle:                   *_paddle_model\n        from models.experimental import attempt_download, attempt_load  # scoped to avoid circular import\n\n        super().__init__()\n        w = str(weights[0] if isinstance(weights, list) else weights)\n        pt, jit, onnx, xml, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle, triton = self._model_type(w)\n        fp16 &= pt or jit or onnx or engine  # FP16\n        nhwc = coreml or saved_model or pb or tflite or edgetpu  # BHWC formats (vs torch BCWH)\n        stride = 32  # default stride\n        cuda = torch.cuda.is_available() and device.type != 'cpu'  # use CUDA\n        if not (pt or triton):\n            w = attempt_download(w)  # download if not local\n\n        if pt:  # PyTorch\n            model = attempt_load(weights if isinstance(weights, list) else w, device=device, inplace=True, fuse=fuse)\n            stride = max(int(model.stride.max()), 32)  # model stride\n            names = model.module.names if hasattr(model, 'module') else model.names  # get class names\n            model.half() if fp16 else model.float()\n            self.model = model  # explicitly assign for to(), cpu(), cuda(), half()\n        elif jit:  # TorchScript\n            LOGGER.info(f'Loading {w} for TorchScript inference...')\n            extra_files = {'config.txt': ''}  # model metadata\n            model = torch.jit.load(w, _extra_files=extra_files, map_location=device)\n            model.half() if fp16 else model.float()\n            if extra_files['config.txt']:  # load metadata dict\n                d = json.loads(extra_files['config.txt'],\n                               object_hook=lambda d: {int(k) if k.isdigit() else k: v\n                                                      for k, v in d.items()})\n                stride, names = int(d['stride']), d['names']\n        elif dnn:  # ONNX OpenCV DNN\n            LOGGER.info(f'Loading {w} for ONNX OpenCV DNN inference...')\n            check_requirements('opencv-python>=4.5.4')\n            net = cv2.dnn.readNetFromONNX(w)\n        elif onnx:  # ONNX Runtime\n            LOGGER.info(f'Loading {w} for ONNX Runtime inference...')\n            check_requirements(('onnx', 'onnxruntime-gpu' if cuda else 'onnxruntime'))\n            import onnxruntime\n            providers = ['CUDAExecutionProvider', 'CPUExecutionProvider'] if cuda else ['CPUExecutionProvider']\n            session = onnxruntime.InferenceSession(w, providers=providers)\n            output_names = [x.name for x in session.get_outputs()]\n            meta = session.get_modelmeta().custom_metadata_map  # metadata\n            if 'stride' in meta:\n                stride, names = int(meta['stride']), eval(meta['names'])\n        elif xml:  # OpenVINO\n            LOGGER.info(f'Loading {w} for OpenVINO inference...')\n            check_requirements('openvino')  # requires openvino-dev: https://pypi.org/project/openvino-dev/\n            from openvino.runtime import Core, Layout, get_batch\n            ie = Core()\n            if not Path(w).is_file():  # if not *.xml\n                w = next(Path(w).glob('*.xml'))  # get *.xml file from *_openvino_model dir\n            network = ie.read_model(model=w, weights=Path(w).with_suffix('.bin'))\n            if network.get_parameters()[0].get_layout().empty:\n                network.get_parameters()[0].set_layout(Layout(\"NCHW\"))\n            batch_dim = get_batch(network)\n            if batch_dim.is_static:\n                batch_size = batch_dim.get_length()\n            executable_network = ie.compile_model(network, device_name=\"CPU\")  # device_name=\"MYRIAD\" for Intel NCS2\n            stride, names = self._load_metadata(Path(w).with_suffix('.yaml'))  # load metadata\n        elif engine:  # TensorRT\n            LOGGER.info(f'Loading {w} for TensorRT inference...')\n            import tensorrt as trt  # https://developer.nvidia.com/nvidia-tensorrt-download\n            check_version(trt.__version__, '7.0.0', hard=True)  # require tensorrt>=7.0.0\n            if device.type == 'cpu':\n                device = torch.device('cuda:0')\n            Binding = namedtuple('Binding', ('name', 'dtype', 'shape', 'data', 'ptr'))\n            logger = trt.Logger(trt.Logger.INFO)\n            with open(w, 'rb') as f, trt.Runtime(logger) as runtime:\n                model = runtime.deserialize_cuda_engine(f.read())\n            context = model.create_execution_context()\n            bindings = OrderedDict()\n            output_names = []\n            fp16 = False  # default updated below\n            dynamic = False\n            for i in range(model.num_bindings):\n                name = model.get_binding_name(i)\n                dtype = trt.nptype(model.get_binding_dtype(i))\n                if model.binding_is_input(i):\n                    if -1 in tuple(model.get_binding_shape(i)):  # dynamic\n                        dynamic = True\n                        context.set_binding_shape(i, tuple(model.get_profile_shape(0, i)[2]))\n                    if dtype == np.float16:\n                        fp16 = True\n                else:  # output\n                    output_names.append(name)\n                shape = tuple(context.get_binding_shape(i))\n                im = torch.from_numpy(np.empty(shape, dtype=dtype)).to(device)\n                bindings[name] = Binding(name, dtype, shape, im, int(im.data_ptr()))\n            binding_addrs = OrderedDict((n, d.ptr) for n, d in bindings.items())\n            batch_size = bindings['images'].shape[0]  # if dynamic, this is instead max batch size\n        elif coreml:  # CoreML\n            LOGGER.info(f'Loading {w} for CoreML inference...')\n            import coremltools as ct\n            model = ct.models.MLModel(w)\n        elif saved_model:  # TF SavedModel\n            LOGGER.info(f'Loading {w} for TensorFlow SavedModel inference...')\n            import tensorflow as tf\n            keras = False  # assume TF1 saved_model\n            model = tf.keras.models.load_model(w) if keras else tf.saved_model.load(w)\n        elif pb:  # GraphDef https://www.tensorflow.org/guide/migrate#a_graphpb_or_graphpbtxt\n            LOGGER.info(f'Loading {w} for TensorFlow GraphDef inference...')\n            import tensorflow as tf\n\n            def wrap_frozen_graph(gd, inputs, outputs):\n                x = tf.compat.v1.wrap_function(lambda: tf.compat.v1.import_graph_def(gd, name=\"\"), [])  # wrapped\n                ge = x.graph.as_graph_element\n                return x.prune(tf.nest.map_structure(ge, inputs), tf.nest.map_structure(ge, outputs))\n\n            def gd_outputs(gd):\n                name_list, input_list = [], []\n                for node in gd.node:  # tensorflow.core.framework.node_def_pb2.NodeDef\n                    name_list.append(node.name)\n                    input_list.extend(node.input)\n                return sorted(f'{x}:0' for x in list(set(name_list) - set(input_list)) if not x.startswith('NoOp'))\n\n            gd = tf.Graph().as_graph_def()  # TF GraphDef\n            with open(w, 'rb') as f:\n                gd.ParseFromString(f.read())\n            frozen_func = wrap_frozen_graph(gd, inputs=\"x:0\", outputs=gd_outputs(gd))\n        elif tflite or edgetpu:  # https://www.tensorflow.org/lite/guide/python#install_tensorflow_lite_for_python\n            try:  # https://coral.ai/docs/edgetpu/tflite-python/#update-existing-tf-lite-code-for-the-edge-tpu\n                from tflite_runtime.interpreter import Interpreter, load_delegate\n            except ImportError:\n                import tensorflow as tf\n                Interpreter, load_delegate = tf.lite.Interpreter, tf.lite.experimental.load_delegate,\n            if edgetpu:  # TF Edge TPU https://coral.ai/software/#edgetpu-runtime\n                LOGGER.info(f'Loading {w} for TensorFlow Lite Edge TPU inference...')\n                delegate = {\n                    'Linux': 'libedgetpu.so.1',\n                    'Darwin': 'libedgetpu.1.dylib',\n                    'Windows': 'edgetpu.dll'}[platform.system()]\n                interpreter = Interpreter(model_path=w, experimental_delegates=[load_delegate(delegate)])\n            else:  # TFLite\n                LOGGER.info(f'Loading {w} for TensorFlow Lite inference...')\n                interpreter = Interpreter(model_path=w)  # load TFLite model\n            interpreter.allocate_tensors()  # allocate\n            input_details = interpreter.get_input_details()  # inputs\n            output_details = interpreter.get_output_details()  # outputs\n            # load metadata\n            with contextlib.suppress(zipfile.BadZipFile):\n                with zipfile.ZipFile(w, \"r\") as model:\n                    meta_file = model.namelist()[0]\n                    meta = ast.literal_eval(model.read(meta_file).decode(\"utf-8\"))\n                    stride, names = int(meta['stride']), meta['names']\n        elif tfjs:  # TF.js\n            raise NotImplementedError('ERROR: YOLOv5 TF.js inference is not supported')\n        elif paddle:  # PaddlePaddle\n            LOGGER.info(f'Loading {w} for PaddlePaddle inference...')\n            check_requirements('paddlepaddle-gpu' if cuda else 'paddlepaddle')\n            import paddle.inference as pdi\n            if not Path(w).is_file():  # if not *.pdmodel\n                w = next(Path(w).rglob('*.pdmodel'))  # get *.pdmodel file from *_paddle_model dir\n            weights = Path(w).with_suffix('.pdiparams')\n            config = pdi.Config(str(w), str(weights))\n            if cuda:\n                config.enable_use_gpu(memory_pool_init_size_mb=2048, device_id=0)\n            predictor = pdi.create_predictor(config)\n            input_handle = predictor.get_input_handle(predictor.get_input_names()[0])\n            output_names = predictor.get_output_names()\n        elif triton:  # NVIDIA Triton Inference Server\n            LOGGER.info(f'Using {w} as Triton Inference Server...')\n            check_requirements('tritonclient[all]')\n            from utils.triton import TritonRemoteModel\n            model = TritonRemoteModel(url=w)\n            nhwc = model.runtime.startswith(\"tensorflow\")\n        else:\n            raise NotImplementedError(f'ERROR: {w} is not a supported format')\n\n        # class names\n        if 'names' not in locals():\n            names = yaml_load(data)['names'] if data else {i: f'class{i}' for i in range(999)}\n        if names[0] == 'n01440764' and len(names) == 1000:  # ImageNet\n            names = yaml_load(ROOT / 'data/ImageNet.yaml')['names']  # human-readable names\n\n        self.__dict__.update(locals())  # assign all variables to self", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, im, augment=False, visualize=False):\n        # YOLOv5 MultiBackend inference\n        b, ch, h, w = im.shape  # batch, channel, height, width\n        if self.fp16 and im.dtype != torch.float16:\n            im = im.half()  # to FP16\n        if self.nhwc:\n            im = im.permute(0, 2, 3, 1)  # torch BCHW to numpy BHWC shape(1,320,192,3)\n\n        if self.pt:  # PyTorch\n            y = self.model(im, augment=augment, visualize=visualize) if augment or visualize else self.model(im)\n        elif self.jit:  # TorchScript\n            y = self.model(im)\n        elif self.dnn:  # ONNX OpenCV DNN\n            im = im.cpu().numpy()  # torch to numpy\n            self.net.setInput(im)\n            y = self.net.forward()\n        elif self.onnx:  # ONNX Runtime\n            im = im.cpu().numpy()  # torch to numpy\n            y = self.session.run(self.output_names, {self.session.get_inputs()[0].name: im})\n        elif self.xml:  # OpenVINO\n            im = im.cpu().numpy()  # FP32\n            y = list(self.executable_network([im]).values())\n        elif self.engine:  # TensorRT\n            if self.dynamic and im.shape != self.bindings['images'].shape:\n                i = self.model.get_binding_index('images')\n                self.context.set_binding_shape(i, im.shape)  # reshape if dynamic\n                self.bindings['images'] = self.bindings['images']._replace(shape=im.shape)\n                for name in self.output_names:\n                    i = self.model.get_binding_index(name)\n                    self.bindings[name].data.resize_(tuple(self.context.get_binding_shape(i)))\n            s = self.bindings['images'].shape\n            assert im.shape == s, f\"input size {im.shape} {'>' if self.dynamic else 'not equal to'} max model size {s}\"\n            self.binding_addrs['images'] = int(im.data_ptr())\n            self.context.execute_v2(list(self.binding_addrs.values()))\n            y = [self.bindings[x].data for x in sorted(self.output_names)]\n        elif self.coreml:  # CoreML\n            im = im.cpu().numpy()\n            im = Image.fromarray((im[0] * 255).astype('uint8'))\n            # im = im.resize((192, 320), Image.ANTIALIAS)\n            y = self.model.predict({'image': im})  # coordinates are xywh normalized\n            if 'confidence' in y:\n                box = xywh2xyxy(y['coordinates'] * [[w, h, w, h]])  # xyxy pixels\n                conf, cls = y['confidence'].max(1), y['confidence'].argmax(1).astype(np.float)\n                y = np.concatenate((box, conf.reshape(-1, 1), cls.reshape(-1, 1)), 1)\n            else:\n                y = list(reversed(y.values()))  # reversed for segmentation models (pred, proto)\n        elif self.paddle:  # PaddlePaddle\n            im = im.cpu().numpy().astype(np.float32)\n            self.input_handle.copy_from_cpu(im)\n            self.predictor.run()\n            y = [self.predictor.get_output_handle(x).copy_to_cpu() for x in self.output_names]\n        elif self.triton:  # NVIDIA Triton Inference Server\n            y = self.model(im)\n        else:  # TensorFlow (SavedModel, GraphDef, Lite, Edge TPU)\n            im = im.cpu().numpy()\n            if self.saved_model:  # SavedModel\n                y = self.model(im, training=False) if self.keras else self.model(im)\n            elif self.pb:  # GraphDef\n                y = self.frozen_func(x=self.tf.constant(im))\n            else:  # Lite or Edge TPU\n                input = self.input_details[0]\n                int8 = input['dtype'] == np.uint8  # is TFLite quantized uint8 model\n                if int8:\n                    scale, zero_point = input['quantization']\n                    im = (im / scale + zero_point).astype(np.uint8)  # de-scale\n                self.interpreter.set_tensor(input['index'], im)\n                self.interpreter.invoke()\n                y = []\n                for output in self.output_details:\n                    x = self.interpreter.get_tensor(output['index'])\n                    if int8:\n                        scale, zero_point = output['quantization']\n                        x = (x.astype(np.float32) - zero_point) * scale  # re-scale\n                    y.append(x)\n            y = [x if isinstance(x, np.ndarray) else x.numpy() for x in y]\n            y[0][..., :4] *= [w, h, w, h]  # xywh normalized to pixels\n\n        if isinstance(y, (list, tuple)):\n            return self.from_numpy(y[0]) if len(y) == 1 else [self.from_numpy(x) for x in y]\n        else:\n            return self.from_numpy(y)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def from_numpy(self, x):\n        return torch.from_numpy(x).to(self.device) if isinstance(x, np.ndarray) else x", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def warmup(self, imgsz=(1, 3, 640, 640)):\n        # Warmup model by running inference once\n        warmup_types = self.pt, self.jit, self.onnx, self.engine, self.saved_model, self.pb, self.triton\n        if any(warmup_types) and (self.device.type != 'cpu' or self.triton):\n            im = torch.empty(*imgsz, dtype=torch.half if self.fp16 else torch.float, device=self.device)  # input\n            for _ in range(2 if self.jit else 1):  #\n                self.forward(im)  # warmup", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _model_type(p='path/to/model.pt'):\n        # Return model type from model path, i.e. path='path/to/model.onnx' -> type=onnx\n        # types = [pt, jit, onnx, xml, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle]\n        from export import export_formats\n        from utils.downloads import is_url\n        sf = list(export_formats().Suffix)  # export suffixes\n        if not is_url(p, check=False):\n            check_suffix(p, sf)  # checks\n        url = urlparse(p)  # if url may be Triton inference server\n        types = [s in Path(p).name for s in sf]\n        types[8] &= not types[9]  # tflite &= not edgetpu\n        triton = not any(types) and all([any(s in url.scheme for s in [\"http\", \"grpc\"]), url.netloc])\n        return types + [triton]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _load_metadata(f=Path('path/to/meta.yaml')):\n        # Load metadata from meta.yaml if it exists\n        if f.exists():\n            d = yaml_load(f)\n            return d['stride'], d['names']  # assign stride, names\n        return None, None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, model, verbose=True):\n        super().__init__()\n        if verbose:\n            LOGGER.info('Adding AutoShape... ')\n        copy_attr(self, model, include=('yaml', 'nc', 'hyp', 'names', 'stride', 'abc'), exclude=())  # copy attributes\n        self.dmb = isinstance(model, DetectMultiBackend)  # DetectMultiBackend() instance\n        self.pt = not self.dmb or model.pt  # PyTorch model\n        self.model = model.eval()\n        if self.pt:\n            m = self.model.model.model[-1] if self.dmb else self.model.model[-1]  # Detect()\n            m.inplace = False  # Detect.inplace=False for safe multithread inference\n            m.export = True  # do not output loss values", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _apply(self, fn):\n        # Apply to(), cpu(), cuda(), half() to model tensors that are not parameters or registered buffers\n        self = super()._apply(fn)\n        if self.pt:\n            m = self.model.model.model[-1] if self.dmb else self.model.model[-1]  # Detect()\n            m.stride = fn(m.stride)\n            m.grid = list(map(fn, m.grid))\n            if isinstance(m.anchor_grid, list):\n                m.anchor_grid = list(map(fn, m.anchor_grid))\n        return self", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, ims, size=640, augment=False, profile=False):\n        # Inference from various sources. For size(height=640, width=1280), RGB images example inputs are:\n        #   file:        ims = 'data/images/zidane.jpg'  # str or PosixPath\n        #   URI:             = 'https://ultralytics.com/images/zidane.jpg'\n        #   OpenCV:          = cv2.imread('image.jpg')[:,:,::-1]  # HWC BGR to RGB x(640,1280,3)\n        #   PIL:             = Image.open('image.jpg') or ImageGrab.grab()  # HWC x(640,1280,3)\n        #   numpy:           = np.zeros((640,1280,3))  # HWC\n        #   torch:           = torch.zeros(16,3,320,640)  # BCHW (scaled to size=640, 0-1 values)\n        #   multiple:        = [Image.open('image1.jpg'), Image.open('image2.jpg'), ...]  # list of images\n\n        dt = (Profile(), Profile(), Profile())\n        with dt[0]:\n            if isinstance(size, int):  # expand\n                size = (size, size)\n            p = next(self.model.parameters()) if self.pt else torch.empty(1, device=self.model.device)  # param\n            autocast = self.amp and (p.device.type != 'cpu')  # Automatic Mixed Precision (AMP) inference\n            if isinstance(ims, torch.Tensor):  # torch\n                with amp.autocast(autocast):\n                    return self.model(ims.to(p.device).type_as(p), augment=augment)  # inference\n\n            # Pre-process\n            n, ims = (len(ims), list(ims)) if isinstance(ims, (list, tuple)) else (1, [ims])  # number, list of images\n            shape0, shape1, files = [], [], []  # image and inference shapes, filenames\n            for i, im in enumerate(ims):\n                f = f'image{i}'  # filename\n                if isinstance(im, (str, Path)):  # filename or uri\n                    im, f = Image.open(requests.get(im, stream=True).raw if str(im).startswith('http') else im), im\n                    im = np.asarray(exif_transpose(im))\n                elif isinstance(im, Image.Image):  # PIL Image\n                    im, f = np.asarray(exif_transpose(im)), getattr(im, 'filename', f) or f\n                files.append(Path(f).with_suffix('.jpg').name)\n                if im.shape[0] < 5:  # image in CHW\n                    im = im.transpose((1, 2, 0))  # reverse dataloader .transpose(2, 0, 1)\n                im = im[..., :3] if im.ndim == 3 else cv2.cvtColor(im, cv2.COLOR_GRAY2BGR)  # enforce 3ch input\n                s = im.shape[:2]  # HWC\n                shape0.append(s)  # image shape\n                g = max(size) / max(s)  # gain\n                shape1.append([int(y * g) for y in s])\n                ims[i] = im if im.data.contiguous else np.ascontiguousarray(im)  # update\n            shape1 = [make_divisible(x, self.stride) for x in np.array(shape1).max(0)]  # inf shape\n            x = [letterbox(im, shape1, auto=False)[0] for im in ims]  # pad\n            x = np.ascontiguousarray(np.array(x).transpose((0, 3, 1, 2)))  # stack and BHWC to BCHW\n            x = torch.from_numpy(x).to(p.device).type_as(p) / 255  # uint8 to fp16/32\n\n        with amp.autocast(autocast):\n            # Inference\n            with dt[1]:\n                y = self.model(x, augment=augment)  # forward\n\n            # Post-process\n            with dt[2]:\n                y = non_max_suppression(y if self.dmb else y[0],\n                                        self.conf,\n                                        self.iou,\n                                        self.classes,\n                                        self.agnostic,\n                                        self.multi_label,\n                                        max_det=self.max_det)  # NMS\n                for i in range(n):\n                    scale_boxes(shape1, y[i][:, :4], shape0[i])\n\n            return Detections(ims, y, files, dt, self.names, x.shape)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, ims, pred, files, times=(0, 0, 0), names=None, shape=None):\n        super().__init__()\n        d = pred[0].device  # device\n        gn = [torch.tensor([*(im.shape[i] for i in [1, 0, 1, 0]), 1, 1], device=d) for im in ims]  # normalizations\n        self.ims = ims  # list of images as numpy arrays\n        self.pred = pred  # list of tensors pred[0] = (xyxy, conf, cls)\n        self.names = names  # class names\n        self.files = files  # image filenames\n        self.times = times  # profiling times\n        self.xyxy = pred  # xyxy pixels\n        self.xywh = [xyxy2xywh(x) for x in pred]  # xywh pixels\n        self.xyxyn = [x / g for x, g in zip(self.xyxy, gn)]  # xyxy normalized\n        self.xywhn = [x / g for x, g in zip(self.xywh, gn)]  # xywh normalized\n        self.n = len(self.pred)  # number of images (batch size)\n        self.t = tuple(x.t / self.n * 1E3 for x in times)  # timestamps (ms)\n        self.s = tuple(shape)  # inference BCHW shape", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _run(self, pprint=False, show=False, save=False, crop=False, render=False, labels=True, save_dir=Path('')):\n        s, crops = '', []\n        for i, (im, pred) in enumerate(zip(self.ims, self.pred)):\n            s += f'\\nimage {i + 1}/{len(self.pred)}: {im.shape[0]}x{im.shape[1]} '  # string\n            if pred.shape[0]:\n                for c in pred[:, -1].unique():\n                    n = (pred[:, -1] == c).sum()  # detections per class\n                    s += f\"{n} {self.names[int(c)]}{'s' * (n > 1)}, \"  # add to string\n                s = s.rstrip(', ')\n                if show or save or render or crop:\n                    annotator = Annotator(im, example=str(self.names))\n                    for *box, conf, cls in reversed(pred):  # xyxy, confidence, class\n                        label = f'{self.names[int(cls)]} {conf:.2f}'\n                        if crop:\n                            file = save_dir / 'crops' / self.names[int(cls)] / self.files[i] if save else None\n                            crops.append({\n                                'box': box,\n                                'conf': conf,\n                                'cls': cls,\n                                'label': label,\n                                'im': save_one_box(box, im, file=file, save=save)})\n                        else:  # all others\n                            annotator.box_label(box, label if labels else '', color=colors(cls))\n                    im = annotator.im\n            else:\n                s += '(no detections)'\n\n            im = Image.fromarray(im.astype(np.uint8)) if isinstance(im, np.ndarray) else im  # from np\n            if show:\n                display(im) if is_notebook() else im.show(self.files[i])\n            if save:\n                f = self.files[i]\n                im.save(save_dir / f)  # save\n                if i == self.n - 1:\n                    LOGGER.info(f\"Saved {self.n} image{'s' * (self.n > 1)} to {colorstr('bold', save_dir)}\")\n            if render:\n                self.ims[i] = np.asarray(im)\n        if pprint:\n            s = s.lstrip('\\n')\n            return f'{s}\\nSpeed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {self.s}' % self.t\n        if crop:\n            if save:\n                LOGGER.info(f'Saved results to {save_dir}\\n')\n            return crops", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def show(self, labels=True):\n        self._run(show=True, labels=labels)  # show results", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def save(self, labels=True, save_dir='runs/detect/exp', exist_ok=False):\n        save_dir = increment_path(save_dir, exist_ok, mkdir=True)  # increment save_dir\n        self._run(save=True, labels=labels, save_dir=save_dir)  # save results", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def crop(self, save=True, save_dir='runs/detect/exp', exist_ok=False):\n        save_dir = increment_path(save_dir, exist_ok, mkdir=True) if save else None\n        return self._run(crop=True, save=save, save_dir=save_dir)  # crop results", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def render(self, labels=True):\n        self._run(render=True, labels=labels)  # render results\n        return self.ims", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def pandas(self):\n        # return detections as pandas DataFrames, i.e. print(results.pandas().xyxy[0])\n        new = copy(self)  # return copy\n        ca = 'xmin', 'ymin', 'xmax', 'ymax', 'confidence', 'class', 'name'  # xyxy columns\n        cb = 'xcenter', 'ycenter', 'width', 'height', 'confidence', 'class', 'name'  # xywh columns\n        for k, c in zip(['xyxy', 'xyxyn', 'xywh', 'xywhn'], [ca, ca, cb, cb]):\n            a = [[x[:5] + [int(x[5]), self.names[int(x[5])]] for x in x.tolist()] for x in getattr(self, k)]  # update\n            setattr(new, k, [pd.DataFrame(x, columns=c) for x in a])\n        return new", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def tolist(self):\n        # return a list of Detections objects, i.e. 'for result in results.tolist():'\n        r = range(self.n)  # iterable\n        x = [Detections([self.ims[i]], [self.pred[i]], [self.files[i]], self.times, self.names, self.s) for i in r]\n        # for d in x:\n        #    for k in ['ims', 'pred', 'xyxy', 'xyxyn', 'xywh', 'xywhn']:\n        #        setattr(d, k, getattr(d, k)[0])  # pop out of list\n        return x", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def print(self):\n        LOGGER.info(self.__str__())", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __len__(self):  # override len(results)\n        return self.n", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __str__(self):  # override print(results)\n        return self._run(pprint=True)  # print results", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __repr__(self):\n        return f'YOLOv5 {self.__class__} instance\\n' + self.__str__()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c_=256, c2=32):  # ch_in, number of protos, number of masks\n        super().__init__()\n        self.cv1 = Conv(c1, c_, k=3)\n        self.upsample = nn.Upsample(scale_factor=2, mode='nearest')\n        self.cv2 = Conv(c_, c_, k=3)\n        self.cv3 = Conv(c_, c2)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        return self.cv3(self.cv2(self.upsample(self.cv1(x))))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, c1, c2, k=1, s=1, p=None, g=1):  # ch_in, ch_out, kernel, stride, padding, groups\n        super().__init__()\n        c_ = 1280  # efficientnet_b0 size\n        self.conv = Conv(c1, c_, k, s, autopad(k, p), g)\n        self.pool = nn.AdaptiveAvgPool2d(1)  # to x(b,c_,1,1)\n        self.drop = nn.Dropout(p=0.0, inplace=True)\n        self.linear = nn.Linear(c_, c2)  # to x(b,c2)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        if isinstance(x, list):\n            x = torch.cat(x, 1)\n        return self.linear(self.drop(self.pool(self.conv(x)).flatten(1)))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "            def wrap_frozen_graph(gd, inputs, outputs):\n                x = tf.compat.v1.wrap_function(lambda: tf.compat.v1.import_graph_def(gd, name=\"\"), [])  # wrapped\n                ge = x.graph.as_graph_element\n                return x.prune(tf.nest.map_structure(ge, inputs), tf.nest.map_structure(ge, outputs))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "            def gd_outputs(gd):\n                name_list, input_list = [], []\n                for node in gd.node:  # tensorflow.core.framework.node_def_pb2.NodeDef\n                    name_list.append(node.name)\n                    input_list.extend(node.input)\n                return sorted(f'{x}:0' for x in list(set(name_list) - set(input_list)) if not x.startswith('NoOp'))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_model(d, ch):  # model_dict, input_channels(3)\n    # Parse a YOLOv5 model.yaml dictionary\n    LOGGER.info(f\"\\n{'':>3}{'from':>18}{'n':>3}{'params':>10}  {'module':<40}{'arguments':<30}\")\n    anchors, nc, gd, gw, act = d['anchors'], d['nc'], d['depth_multiple'], d['width_multiple'], d.get('activation')\n    if act:\n        Conv.default_act = eval(act)  # redefine default activation, i.e. Conv.default_act = nn.SiLU()\n        LOGGER.info(f\"{colorstr('activation:')} {act}\")  # print\n    na = (len(anchors[0]) // 2) if isinstance(anchors, list) else anchors  # number of anchors\n    no = na * (nc + 5)  # number of outputs = anchors * (classes + 5)\n\n    layers, save, c2 = [], [], ch[-1]  # layers, savelist, ch out\n    for i, (f, n, m, args) in enumerate(d['backbone'] + d['head']):  # from, number, module, args\n        m = eval(m) if isinstance(m, str) else m  # eval strings\n        for j, a in enumerate(args):\n            with contextlib.suppress(NameError):\n                args[j] = eval(a) if isinstance(a, str) else a  # eval strings\n\n        n = n_ = max(round(n * gd), 1) if n > 1 else n  # depth gain\n        if m in {\n                Conv, GhostConv, Bottleneck, GhostBottleneck, SPP, SPPF, DWConv, MixConv2d, Focus, CrossConv,\n                BottleneckCSP, C3, C3TR, C3SPP, C3Ghost, nn.ConvTranspose2d, DWConvTranspose2d, C3x}:\n            c1, c2 = ch[f], args[0]\n            if c2 != no:  # if not output\n                c2 = make_divisible(c2 * gw, 8)\n\n            args = [c1, c2, *args[1:]]\n            if m in {BottleneckCSP, C3, C3TR, C3Ghost, C3x}:\n                args.insert(2, n)  # number of repeats\n                n = 1\n        elif m is nn.BatchNorm2d:\n            args = [ch[f]]\n        elif m is Concat:\n            c2 = sum(ch[x] for x in f)\n        # TODO: channel, gw, gd\n        elif m in {Detect, Segment}:\n            args.append([ch[x] for x in f])\n            if isinstance(args[1], int):  # number of anchors\n                args[1] = [list(range(args[1] * 2))] * len(f)\n            if m is Segment:\n                args[3] = make_divisible(args[3] * gw, 8)\n        elif m is Contract:\n            c2 = ch[f] * args[0] ** 2\n        elif m is Expand:\n            c2 = ch[f] // args[0] ** 2\n        else:\n            c2 = ch[f]\n\n        m_ = nn.Sequential(*(m(*args) for _ in range(n))) if n > 1 else m(*args)  # module\n        t = str(m)[8:-2].replace('__main__.', '')  # module type\n        np = sum(x.numel() for x in m_.parameters())  # number params\n        m_.i, m_.f, m_.type, m_.np = i, f, t, np  # attach index, 'from' index, type, number params\n        LOGGER.info(f'{i:>3}{str(f):>18}{n_:>3}{np:10.0f}  {t:<40}{str(args):<30}')  # print\n        save.extend(x % i for x in ([f] if isinstance(f, int) else f) if x != -1)  # append to savelist\n        layers.append(m_)\n        if i == 0:\n            ch = []\n        ch.append(c2)\n    return nn.Sequential(*layers), sorted(save)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, nc=80, anchors=(), ch=(), inplace=True):  # detection layer\n        super().__init__()\n        self.nc = nc  # number of classes\n        self.no = nc + 5  # number of outputs per anchor\n        self.nl = len(anchors)  # number of detection layers\n        self.na = len(anchors[0]) // 2  # number of anchors\n        self.grid = [torch.empty(0) for _ in range(self.nl)]  # init grid\n        self.anchor_grid = [torch.empty(0) for _ in range(self.nl)]  # init anchor grid\n        self.register_buffer('anchors', torch.tensor(anchors).float().view(self.nl, -1, 2))  # shape(nl,na,2)\n        self.m = nn.ModuleList(nn.Conv2d(x, self.no * self.na, 1) for x in ch)  # output conv\n        self.inplace = inplace  # use inplace ops (e.g. slice assignment)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        z = []  # inference output\n        for i in range(self.nl):\n            x[i] = self.m[i](x[i])  # conv\n            bs, _, ny, nx = x[i].shape  # x(bs,255,20,20) to x(bs,3,20,20,85)\n            x[i] = x[i].view(bs, self.na, self.no, ny, nx).permute(0, 1, 3, 4, 2).contiguous()\n\n            if not self.training:  # inference\n                if self.dynamic or self.grid[i].shape[2:4] != x[i].shape[2:4]:\n                    self.grid[i], self.anchor_grid[i] = self._make_grid(nx, ny, i)\n\n                if isinstance(self, Segment):  # (boxes + masks)\n                    xy, wh, conf, mask = x[i].split((2, 2, self.nc + 1, self.no - self.nc - 5), 4)\n                    xy = (xy.sigmoid() * 2 + self.grid[i]) * self.stride[i]  # xy\n                    wh = (wh.sigmoid() * 2) ** 2 * self.anchor_grid[i]  # wh\n                    y = torch.cat((xy, wh, conf.sigmoid(), mask), 4)\n                else:  # Detect (boxes only)\n                    xy, wh, conf = x[i].sigmoid().split((2, 2, self.nc + 1), 4)\n                    xy = (xy * 2 + self.grid[i]) * self.stride[i]  # xy\n                    wh = (wh * 2) ** 2 * self.anchor_grid[i]  # wh\n                    y = torch.cat((xy, wh, conf), 4)\n                z.append(y.view(bs, self.na * nx * ny, self.no))\n\n        return x if self.training else (torch.cat(z, 1),) if self.export else (torch.cat(z, 1), x)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _make_grid(self, nx=20, ny=20, i=0, torch_1_10=check_version(torch.__version__, '1.10.0')):\n        d = self.anchors[i].device\n        t = self.anchors[i].dtype\n        shape = 1, self.na, ny, nx, 2  # grid shape\n        y, x = torch.arange(ny, device=d, dtype=t), torch.arange(nx, device=d, dtype=t)\n        yv, xv = torch.meshgrid(y, x, indexing='ij') if torch_1_10 else torch.meshgrid(y, x)  # torch>=0.7 compatibility\n        grid = torch.stack((xv, yv), 2).expand(shape) - 0.5  # add grid offset, i.e. y = 2.0 * x - 0.5\n        anchor_grid = (self.anchors[i] * self.stride[i]).view((1, self.na, 1, 1, 2)).expand(shape)\n        return grid, anchor_grid", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, nc=80, anchors=(), nm=32, npr=256, ch=(), inplace=True):\n        super().__init__(nc, anchors, ch, inplace)\n        self.nm = nm  # number of masks\n        self.npr = npr  # number of protos\n        self.no = 5 + nc + self.nm  # number of outputs per anchor\n        self.m = nn.ModuleList(nn.Conv2d(x, self.no * self.na, 1) for x in ch)  # output conv\n        self.proto = Proto(ch[0], self.npr, self.nm)  # protos\n        self.detect = Detect.forward", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x):\n        p = self.proto(x[0])\n        x = self.detect(self, x)\n        return (x, p) if self.training else (x[0], p) if self.export else (x[0], p, x[1])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x, profile=False, visualize=False):\n        return self._forward_once(x, profile, visualize)  # single-scale inference, train", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _forward_once(self, x, profile=False, visualize=False):\n        y, dt = [], []  # outputs\n        for m in self.model:\n            if m.f != -1:  # if not from previous layer\n                x = y[m.f] if isinstance(m.f, int) else [x if j == -1 else y[j] for j in m.f]  # from earlier layers\n            if profile:\n                self._profile_one_layer(m, x, dt)\n            x = m(x)  # run\n            y.append(x if m.i in self.save else None)  # save output\n            if visualize:\n                feature_visualization(x, m.type, m.i, save_dir=visualize)\n        return x", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _profile_one_layer(self, m, x, dt):\n        c = m == self.model[-1]  # is final layer, copy input as inplace fix\n        o = thop.profile(m, inputs=(x.copy() if c else x,), verbose=False)[0] / 1E9 * 2 if thop else 0  # FLOPs\n        t = time_sync()\n        for _ in range(10):\n            m(x.copy() if c else x)\n        dt.append((time_sync() - t) * 100)\n        if m == self.model[0]:\n            LOGGER.info(f\"{'time (ms)':>10s} {'GFLOPs':>10s} {'params':>10s}  module\")\n        LOGGER.info(f'{dt[-1]:10.2f} {o:10.2f} {m.np:10.0f}  {m.type}')\n        if c:\n            LOGGER.info(f\"{sum(dt):10.2f} {'-':>10s} {'-':>10s}  Total\")", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def fuse(self):  # fuse model Conv2d() + BatchNorm2d() layers\n        LOGGER.info('Fusing layers... ')\n        for m in self.model.modules():\n            if isinstance(m, (Conv, DWConv)) and hasattr(m, 'bn'):\n                m.conv = fuse_conv_and_bn(m.conv, m.bn)  # update conv\n                delattr(m, 'bn')  # remove batchnorm\n                m.forward = m.forward_fuse  # update forward\n        self.info()\n        return self", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def info(self, verbose=False, img_size=640):  # print model information\n        model_info(self, verbose, img_size)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _apply(self, fn):\n        # Apply to(), cpu(), cuda(), half() to model tensors that are not parameters or registered buffers\n        self = super()._apply(fn)\n        m = self.model[-1]  # Detect()\n        if isinstance(m, (Detect, Segment)):\n            m.stride = fn(m.stride)\n            m.grid = list(map(fn, m.grid))\n            if isinstance(m.anchor_grid, list):\n                m.anchor_grid = list(map(fn, m.anchor_grid))\n        return self", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, cfg='yolov5s.yaml', ch=3, nc=None, anchors=None):  # model, input channels, number of classes\n        super().__init__()\n        if isinstance(cfg, dict):\n            self.yaml = cfg  # model dict\n        else:  # is *.yaml\n            import yaml  # for torch hub\n            self.yaml_file = Path(cfg).name\n            with open(cfg, encoding='ascii', errors='ignore') as f:\n                self.yaml = yaml.safe_load(f)  # model dict\n\n        # Define model\n        ch = self.yaml['ch'] = self.yaml.get('ch', ch)  # input channels\n        if nc and nc != self.yaml['nc']:\n            LOGGER.info(f\"Overriding model.yaml nc={self.yaml['nc']} with nc={nc}\")\n            self.yaml['nc'] = nc  # override yaml value\n        if anchors:\n            LOGGER.info(f'Overriding model.yaml anchors with anchors={anchors}')\n            self.yaml['anchors'] = round(anchors)  # override yaml value\n        self.model, self.save = parse_model(deepcopy(self.yaml), ch=[ch])  # model, savelist\n        self.names = [str(i) for i in range(self.yaml['nc'])]  # default names\n        self.inplace = self.yaml.get('inplace', True)\n\n        # Build strides, anchors\n        m = self.model[-1]  # Detect()\n        if isinstance(m, (Detect, Segment)):\n            s = 256  # 2x min stride\n            m.inplace = self.inplace\n            forward = lambda x: self.forward(x)[0] if isinstance(m, Segment) else self.forward(x)\n            m.stride = torch.tensor([s / x.shape[-2] for x in forward(torch.zeros(1, ch, s, s))])  # forward\n            check_anchor_order(m)\n            m.anchors /= m.stride.view(-1, 1, 1)\n            self.stride = m.stride\n            self._initialize_biases()  # only run once\n\n        # Init weights, biases\n        initialize_weights(self)\n        self.info()\n        LOGGER.info('')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x, augment=False, profile=False, visualize=False):\n        if augment:\n            return self._forward_augment(x)  # augmented inference, None\n        return self._forward_once(x, profile, visualize)  # single-scale inference, train", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _forward_augment(self, x):\n        img_size = x.shape[-2:]  # height, width\n        s = [1, 0.83, 0.67]  # scales\n        f = [None, 3, None]  # flips (2-ud, 3-lr)\n        y = []  # outputs\n        for si, fi in zip(s, f):\n            xi = scale_img(x.flip(fi) if fi else x, si, gs=int(self.stride.max()))\n            yi = self._forward_once(xi)[0]  # forward\n            # cv2.imwrite(f'img_{si}.jpg', 255 * xi[0].cpu().numpy().transpose((1, 2, 0))[:, :, ::-1])  # save\n            yi = self._descale_pred(yi, fi, si, img_size)\n            y.append(yi)\n        y = self._clip_augmented(y)  # clip augmented tails\n        return torch.cat(y, 1), None  # augmented inference, train", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _descale_pred(self, p, flips, scale, img_size):\n        # de-scale predictions following augmented inference (inverse operation)\n        if self.inplace:\n            p[..., :4] /= scale  # de-scale\n            if flips == 2:\n                p[..., 1] = img_size[0] - p[..., 1]  # de-flip ud\n            elif flips == 3:\n                p[..., 0] = img_size[1] - p[..., 0]  # de-flip lr\n        else:\n            x, y, wh = p[..., 0:1] / scale, p[..., 1:2] / scale, p[..., 2:4] / scale  # de-scale\n            if flips == 2:\n                y = img_size[0] - y  # de-flip ud\n            elif flips == 3:\n                x = img_size[1] - x  # de-flip lr\n            p = torch.cat((x, y, wh, p[..., 4:]), -1)\n        return p", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _clip_augmented(self, y):\n        # Clip YOLOv5 augmented inference tails\n        nl = self.model[-1].nl  # number of detection layers (P3-P5)\n        g = sum(4 ** x for x in range(nl))  # grid points\n        e = 1  # exclude layer count\n        i = (y[0].shape[1] // g) * sum(4 ** x for x in range(e))  # indices\n        y[0] = y[0][:, :-i]  # large\n        i = (y[-1].shape[1] // g) * sum(4 ** (nl - 1 - x) for x in range(e))  # indices\n        y[-1] = y[-1][:, i:]  # small\n        return y", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _initialize_biases(self, cf=None):  # initialize biases into Detect(), cf is class frequency\n        # https://arxiv.org/abs/1708.02002 section 3.3\n        # cf = torch.bincount(torch.tensor(np.concatenate(dataset.labels, 0)[:, 0]).long(), minlength=nc) + 1.\n        m = self.model[-1]  # Detect() module\n        for mi, s in zip(m.m, m.stride):  # from\n            b = mi.bias.view(m.na, -1)  # conv.bias(255) to (3,85)\n            b.data[:, 4] += math.log(8 / (640 / s) ** 2)  # obj (8 objects per 640 image)\n            b.data[:, 5:5 + m.nc] += math.log(0.6 / (m.nc - 0.99999)) if cf is None else torch.log(cf / cf.sum())  # cls\n            mi.bias = torch.nn.Parameter(b.view(-1), requires_grad=True)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, cfg='yolov5s-seg.yaml', ch=3, nc=None, anchors=None):\n        super().__init__(cfg, ch, nc, anchors)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, cfg=None, model=None, nc=1000, cutoff=10):  # yaml, model, number of classes, cutoff index\n        super().__init__()\n        self._from_detection_model(model, nc, cutoff) if model is not None else self._from_yaml(cfg)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _from_detection_model(self, model, nc=1000, cutoff=10):\n        # Create a YOLOv5 classification model from a YOLOv5 detection model\n        if isinstance(model, DetectMultiBackend):\n            model = model.model  # unwrap DetectMultiBackend\n        model.model = model.model[:cutoff]  # backbone\n        m = model.model[-1]  # last layer\n        ch = m.conv.in_channels if hasattr(m, 'conv') else m.cv1.conv.in_channels  # ch into module\n        c = Classify(ch, nc)  # Classify()\n        c.i, c.f, c.type = m.i, m.f, 'models.common.Classify'  # index, from, type\n        model.model[-1] = c  # replace\n        self.model = model.model\n        self.stride = model.stride\n        self.save = []\n        self.nc = nc", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def _from_yaml(self, cfg):\n        # Create a YOLOv5 classification model from a *.yaml file\n        self.model = None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def export_formats():\n    # YOLOv5 export formats\n    x = [\n        ['PyTorch', '-', '.pt', True, True],\n        ['TorchScript', 'torchscript', '.torchscript', True, True],\n        ['ONNX', 'onnx', '.onnx', True, True],\n        ['OpenVINO', 'openvino', '_openvino_model', True, False],\n        ['TensorRT', 'engine', '.engine', False, True],\n        ['CoreML', 'coreml', '.mlmodel', True, False],\n        ['TensorFlow SavedModel', 'saved_model', '_saved_model', True, True],\n        ['TensorFlow GraphDef', 'pb', '.pb', True, True],\n        ['TensorFlow Lite', 'tflite', '.tflite', True, False],\n        ['TensorFlow Edge TPU', 'edgetpu', '_edgetpu.tflite', False, False],\n        ['TensorFlow.js', 'tfjs', '_web_model', False, False],\n        ['PaddlePaddle', 'paddle', '_paddle_model', True, True],]\n    return pd.DataFrame(x, columns=['Format', 'Argument', 'Suffix', 'CPU', 'GPU'])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def try_export(inner_func):\n    # YOLOv5 export decorator, i..e @try_export\n    inner_args = get_default_args(inner_func)\n\n    def outer_func(*args, **kwargs):\n        prefix = inner_args['prefix']\n        try:\n            with Profile() as dt:\n                f, model = inner_func(*args, **kwargs)\n            LOGGER.info(f'{prefix} export success \u2705 {dt.t:.1f}s, saved as {f} ({file_size(f):.1f} MB)')\n            return f, model\n        except Exception as e:\n            LOGGER.info(f'{prefix} export failure \u274c {dt.t:.1f}s: {e}')\n            return None, None\n\n    return outer_func", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def export_torchscript(model, im, file, optimize, prefix=colorstr('TorchScript:')):\n    # YOLOv5 TorchScript model export\n    LOGGER.info(f'\\n{prefix} starting export with torch {torch.__version__}...')\n    f = file.with_suffix('.torchscript')\n\n    ts = torch.jit.trace(model, im, strict=False)\n    d = {\"shape\": im.shape, \"stride\": int(max(model.stride)), \"names\": model.names}\n    extra_files = {'config.txt': json.dumps(d)}  # torch._C.ExtraFilesMap()\n    if optimize:  # https://pytorch.org/tutorials/recipes/mobile_interpreter.html\n        optimize_for_mobile(ts)._save_for_lite_interpreter(str(f), _extra_files=extra_files)\n    else:\n        ts.save(str(f), _extra_files=extra_files)\n    return f, None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def export_onnx(model, im, file, opset, dynamic, simplify, prefix=colorstr('ONNX:')):\n    # YOLOv5 ONNX export\n    check_requirements('onnx')\n    import onnx\n\n    LOGGER.info(f'\\n{prefix} starting export with onnx {onnx.__version__}...')\n    f = file.with_suffix('.onnx')\n\n    output_names = ['output0', 'output1'] if isinstance(model, SegmentationModel) else ['output0']\n    if dynamic:\n        dynamic = {'images': {0: 'batch', 2: 'height', 3: 'width'}}  # shape(1,3,640,640)\n        if isinstance(model, SegmentationModel):\n            dynamic['output0'] = {0: 'batch', 1: 'anchors'}  # shape(1,25200,85)\n            dynamic['output1'] = {0: 'batch', 2: 'mask_height', 3: 'mask_width'}  # shape(1,32,160,160)\n        elif isinstance(model, DetectionModel):\n            dynamic['output0'] = {0: 'batch', 1: 'anchors'}  # shape(1,25200,85)\n\n    torch.onnx.export(\n        model.cpu() if dynamic else model,  # --dynamic only compatible with cpu\n        im.cpu() if dynamic else im,\n        f,\n        verbose=False,\n        opset_version=opset,\n        do_constant_folding=True,\n        input_names=['images'],\n        output_names=output_names,\n        dynamic_axes=dynamic or None)\n\n    # Checks\n    model_onnx = onnx.load(f)  # load onnx model\n    onnx.checker.check_model(model_onnx)  # check onnx model\n\n    # Metadata\n    d = {'stride': int(max(model.stride)), 'names': model.names}\n    for k, v in d.items():\n        meta = model_onnx.metadata_props.add()\n        meta.key, meta.value = k, str(v)\n    onnx.save(model_onnx, f)\n\n    # Simplify\n    if simplify:\n        try:\n            cuda = torch.cuda.is_available()\n            check_requirements(('onnxruntime-gpu' if cuda else 'onnxruntime', 'onnx-simplifier>=0.4.1'))\n            import onnxsim\n\n            LOGGER.info(f'{prefix} simplifying with onnx-simplifier {onnxsim.__version__}...')\n            model_onnx, check = onnxsim.simplify(model_onnx)\n            assert check, 'assert check failed'\n            onnx.save(model_onnx, f)\n        except Exception as e:\n            LOGGER.info(f'{prefix} simplifier failure: {e}')\n    return f, model_onnx", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def export_openvino(file, metadata, half, prefix=colorstr('OpenVINO:')):\n    # YOLOv5 OpenVINO export\n    check_requirements('openvino-dev')  # requires openvino-dev: https://pypi.org/project/openvino-dev/\n    import openvino.inference_engine as ie\n\n    LOGGER.info(f'\\n{prefix} starting export with openvino {ie.__version__}...')\n    f = str(file).replace('.pt', f'_openvino_model{os.sep}')\n\n    cmd = f\"mo --input_model {file.with_suffix('.onnx')} --output_dir {f} --data_type {'FP16' if half else 'FP32'}\"\n    subprocess.run(cmd.split(), check=True, env=os.environ)  # export\n    yaml_save(Path(f) / file.with_suffix('.yaml').name, metadata)  # add metadata.yaml\n    return f, None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def export_paddle(model, im, file, metadata, prefix=colorstr('PaddlePaddle:')):\n    # YOLOv5 Paddle export\n    check_requirements(('paddlepaddle', 'x2paddle'))\n    import x2paddle\n    from x2paddle.convert import pytorch2paddle\n\n    LOGGER.info(f'\\n{prefix} starting export with X2Paddle {x2paddle.__version__}...')\n    f = str(file).replace('.pt', f'_paddle_model{os.sep}')\n\n    pytorch2paddle(module=model, save_dir=f, jit_type='trace', input_examples=[im])  # export\n    yaml_save(Path(f) / file.with_suffix('.yaml').name, metadata)  # add metadata.yaml\n    return f, None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def export_coreml(model, im, file, int8, half, prefix=colorstr('CoreML:')):\n    # YOLOv5 CoreML export\n    check_requirements('coremltools')\n    import coremltools as ct\n\n    LOGGER.info(f'\\n{prefix} starting export with coremltools {ct.__version__}...')\n    f = file.with_suffix('.mlmodel')\n\n    ts = torch.jit.trace(model, im, strict=False)  # TorchScript model\n    ct_model = ct.convert(ts, inputs=[ct.ImageType('image', shape=im.shape, scale=1 / 255, bias=[0, 0, 0])])\n    bits, mode = (8, 'kmeans_lut') if int8 else (16, 'linear') if half else (32, None)\n    if bits < 32:\n        if MACOS:  # quantization only supported on macOS\n            with warnings.catch_warnings():\n                warnings.filterwarnings(\"ignore\", category=DeprecationWarning)  # suppress numpy==1.20 float warning\n                ct_model = ct.models.neural_network.quantization_utils.quantize_weights(ct_model, bits, mode)\n        else:\n            print(f'{prefix} quantization only supported on macOS, skipping...')\n    ct_model.save(f)\n    return f, ct_model", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def export_engine(model, im, file, half, dynamic, simplify, workspace=4, verbose=False, prefix=colorstr('TensorRT:')):\n    # YOLOv5 TensorRT export https://developer.nvidia.com/tensorrt\n    assert im.device.type != 'cpu', 'export running on CPU but must be on GPU, i.e. `python export.py --device 0`'\n    try:\n        import tensorrt as trt\n    except Exception:\n        if platform.system() == 'Linux':\n            check_requirements('nvidia-tensorrt', cmds='-U --index-url https://pypi.ngc.nvidia.com')\n        import tensorrt as trt\n\n    if trt.__version__[0] == '7':  # TensorRT 7 handling https://github.com/ultralytics/yolov5/issues/6012\n        grid = model.model[-1].anchor_grid\n        model.model[-1].anchor_grid = [a[..., :1, :1, :] for a in grid]\n        export_onnx(model, im, file, 12, dynamic, simplify)  # opset 12\n        model.model[-1].anchor_grid = grid\n    else:  # TensorRT >= 8\n        check_version(trt.__version__, '8.0.0', hard=True)  # require tensorrt>=8.0.0\n        export_onnx(model, im, file, 12, dynamic, simplify)  # opset 12\n    onnx = file.with_suffix('.onnx')\n\n    LOGGER.info(f'\\n{prefix} starting export with TensorRT {trt.__version__}...')\n    assert onnx.exists(), f'failed to export ONNX file: {onnx}'\n    f = file.with_suffix('.engine')  # TensorRT engine file\n    logger = trt.Logger(trt.Logger.INFO)\n    if verbose:\n        logger.min_severity = trt.Logger.Severity.VERBOSE\n\n    builder = trt.Builder(logger)\n    config = builder.create_builder_config()\n    config.max_workspace_size = workspace * 1 << 30\n    # config.set_memory_pool_limit(trt.MemoryPoolType.WORKSPACE, workspace << 30)  # fix TRT 8.4 deprecation notice\n\n    flag = (1 << int(trt.NetworkDefinitionCreationFlag.EXPLICIT_BATCH))\n    network = builder.create_network(flag)\n    parser = trt.OnnxParser(network, logger)\n    if not parser.parse_from_file(str(onnx)):\n        raise RuntimeError(f'failed to load ONNX file: {onnx}')\n\n    inputs = [network.get_input(i) for i in range(network.num_inputs)]\n    outputs = [network.get_output(i) for i in range(network.num_outputs)]\n    for inp in inputs:\n        LOGGER.info(f'{prefix} input \"{inp.name}\" with shape{inp.shape} {inp.dtype}')\n    for out in outputs:\n        LOGGER.info(f'{prefix} output \"{out.name}\" with shape{out.shape} {out.dtype}')\n\n    if dynamic:\n        if im.shape[0] <= 1:\n            LOGGER.warning(f\"{prefix} WARNING \u26a0\ufe0f --dynamic model requires maximum --batch-size argument\")\n        profile = builder.create_optimization_profile()\n        for inp in inputs:\n            profile.set_shape(inp.name, (1, *im.shape[1:]), (max(1, im.shape[0] // 2), *im.shape[1:]), im.shape)\n        config.add_optimization_profile(profile)\n\n    LOGGER.info(f'{prefix} building FP{16 if builder.platform_has_fast_fp16 and half else 32} engine as {f}')\n    if builder.platform_has_fast_fp16 and half:\n        config.set_flag(trt.BuilderFlag.FP16)\n    with builder.build_engine(network, config) as engine, open(f, 'wb') as t:\n        t.write(engine.serialize())\n    return f, None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def export_saved_model(model,\n                       im,\n                       file,\n                       dynamic,\n                       tf_nms=False,\n                       agnostic_nms=False,\n                       topk_per_class=100,\n                       topk_all=100,\n                       iou_thres=0.45,\n                       conf_thres=0.25,\n                       keras=False,\n                       prefix=colorstr('TensorFlow SavedModel:')):\n    # YOLOv5 TensorFlow SavedModel export\n    try:\n        import tensorflow as tf\n    except Exception:\n        check_requirements(f\"tensorflow{'' if torch.cuda.is_available() else '-macos' if MACOS else '-cpu'}\")\n        import tensorflow as tf\n    from tensorflow.python.framework.convert_to_constants import convert_variables_to_constants_v2\n\n    from models.tf import TFModel\n\n    LOGGER.info(f'\\n{prefix} starting export with tensorflow {tf.__version__}...')\n    f = str(file).replace('.pt', '_saved_model')\n    batch_size, ch, *imgsz = list(im.shape)  # BCHW\n\n    tf_model = TFModel(cfg=model.yaml, model=model, nc=model.nc, imgsz=imgsz)\n    im = tf.zeros((batch_size, *imgsz, ch))  # BHWC order for TensorFlow\n    _ = tf_model.predict(im, tf_nms, agnostic_nms, topk_per_class, topk_all, iou_thres, conf_thres)\n    inputs = tf.keras.Input(shape=(*imgsz, ch), batch_size=None if dynamic else batch_size)\n    outputs = tf_model.predict(inputs, tf_nms, agnostic_nms, topk_per_class, topk_all, iou_thres, conf_thres)\n    keras_model = tf.keras.Model(inputs=inputs, outputs=outputs)\n    keras_model.trainable = False\n    keras_model.summary()\n    if keras:\n        keras_model.save(f, save_format='tf')\n    else:\n        spec = tf.TensorSpec(keras_model.inputs[0].shape, keras_model.inputs[0].dtype)\n        m = tf.function(lambda x: keras_model(x))  # full model\n        m = m.get_concrete_function(spec)\n        frozen_func = convert_variables_to_constants_v2(m)\n        tfm = tf.Module()\n        tfm.__call__ = tf.function(lambda x: frozen_func(x)[:4] if tf_nms else frozen_func(x), [spec])\n        tfm.__call__(im)\n        tf.saved_model.save(tfm,\n                            f,\n                            options=tf.saved_model.SaveOptions(experimental_custom_gradients=False) if check_version(\n                                tf.__version__, '2.6') else tf.saved_model.SaveOptions())\n    return f, keras_model", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def export_pb(keras_model, file, prefix=colorstr('TensorFlow GraphDef:')):\n    # YOLOv5 TensorFlow GraphDef *.pb export https://github.com/leimao/Frozen_Graph_TensorFlow\n    import tensorflow as tf\n    from tensorflow.python.framework.convert_to_constants import convert_variables_to_constants_v2\n\n    LOGGER.info(f'\\n{prefix} starting export with tensorflow {tf.__version__}...')\n    f = file.with_suffix('.pb')\n\n    m = tf.function(lambda x: keras_model(x))  # full model\n    m = m.get_concrete_function(tf.TensorSpec(keras_model.inputs[0].shape, keras_model.inputs[0].dtype))\n    frozen_func = convert_variables_to_constants_v2(m)\n    frozen_func.graph.as_graph_def()\n    tf.io.write_graph(graph_or_graph_def=frozen_func.graph, logdir=str(f.parent), name=f.name, as_text=False)\n    return f, None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def export_tflite(keras_model, im, file, int8, data, nms, agnostic_nms, prefix=colorstr('TensorFlow Lite:')):\n    # YOLOv5 TensorFlow Lite export\n    import tensorflow as tf\n\n    LOGGER.info(f'\\n{prefix} starting export with tensorflow {tf.__version__}...')\n    batch_size, ch, *imgsz = list(im.shape)  # BCHW\n    f = str(file).replace('.pt', '-fp16.tflite')\n\n    converter = tf.lite.TFLiteConverter.from_keras_model(keras_model)\n    converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS]\n    converter.target_spec.supported_types = [tf.float16]\n    converter.optimizations = [tf.lite.Optimize.DEFAULT]\n    if int8:\n        from models.tf import representative_dataset_gen\n        dataset = LoadImages(check_dataset(check_yaml(data))['train'], img_size=imgsz, auto=False)\n        converter.representative_dataset = lambda: representative_dataset_gen(dataset, ncalib=100)\n        converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS_INT8]\n        converter.target_spec.supported_types = []\n        converter.inference_input_type = tf.uint8  # or tf.int8\n        converter.inference_output_type = tf.uint8  # or tf.int8\n        converter.experimental_new_quantizer = True\n        f = str(file).replace('.pt', '-int8.tflite')\n    if nms or agnostic_nms:\n        converter.target_spec.supported_ops.append(tf.lite.OpsSet.SELECT_TF_OPS)\n\n    tflite_model = converter.convert()\n    open(f, \"wb\").write(tflite_model)\n    return f, None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def export_edgetpu(file, prefix=colorstr('Edge TPU:')):\n    # YOLOv5 Edge TPU export https://coral.ai/docs/edgetpu/models-intro/\n    cmd = 'edgetpu_compiler --version'\n    help_url = 'https://coral.ai/docs/edgetpu/compiler/'\n    assert platform.system() == 'Linux', f'export only supported on Linux. See {help_url}'\n    if subprocess.run(f'{cmd} >/dev/null', shell=True).returncode != 0:\n        LOGGER.info(f'\\n{prefix} export requires Edge TPU compiler. Attempting install from {help_url}')\n        sudo = subprocess.run('sudo --version >/dev/null', shell=True).returncode == 0  # sudo installed on system\n        for c in (\n                'curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -',\n                'echo \"deb https://packages.cloud.google.com/apt coral-edgetpu-stable main\" | sudo tee /etc/apt/sources.list.d/coral-edgetpu.list',\n                'sudo apt-get update', 'sudo apt-get install edgetpu-compiler'):\n            subprocess.run(c if sudo else c.replace('sudo ', ''), shell=True, check=True)\n    ver = subprocess.run(cmd, shell=True, capture_output=True, check=True).stdout.decode().split()[-1]\n\n    LOGGER.info(f'\\n{prefix} starting export with Edge TPU compiler {ver}...')\n    f = str(file).replace('.pt', '-int8_edgetpu.tflite')  # Edge TPU model\n    f_tfl = str(file).replace('.pt', '-int8.tflite')  # TFLite model\n\n    cmd = f\"edgetpu_compiler -s -d -k 10 --out_dir {file.parent} {f_tfl}\"\n    subprocess.run(cmd.split(), check=True)\n    return f, None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def export_tfjs(file, prefix=colorstr('TensorFlow.js:')):\n    # YOLOv5 TensorFlow.js export\n    check_requirements('tensorflowjs')\n    import tensorflowjs as tfjs\n\n    LOGGER.info(f'\\n{prefix} starting export with tensorflowjs {tfjs.__version__}...')\n    f = str(file).replace('.pt', '_web_model')  # js dir\n    f_pb = file.with_suffix('.pb')  # *.pb path\n    f_json = f'{f}/model.json'  # *.json path\n\n    cmd = f'tensorflowjs_converter --input_format=tf_frozen_model ' \\\n          f'--output_node_names=Identity,Identity_1,Identity_2,Identity_3 {f_pb} {f}'\n    subprocess.run(cmd.split())\n\n    json = Path(f_json).read_text()\n    with open(f_json, 'w') as j:  # sort JSON Identity_* in ascending order\n        subst = re.sub(\n            r'{\"outputs\": {\"Identity.?.?\": {\"name\": \"Identity.?.?\"}, '\n            r'\"Identity.?.?\": {\"name\": \"Identity.?.?\"}, '\n            r'\"Identity.?.?\": {\"name\": \"Identity.?.?\"}, '\n            r'\"Identity.?.?\": {\"name\": \"Identity.?.?\"}}}', r'{\"outputs\": {\"Identity\": {\"name\": \"Identity\"}, '\n            r'\"Identity_1\": {\"name\": \"Identity_1\"}, '\n            r'\"Identity_2\": {\"name\": \"Identity_2\"}, '\n            r'\"Identity_3\": {\"name\": \"Identity_3\"}}}', json)\n        j.write(subst)\n    return f, None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def add_tflite_metadata(file, metadata, num_outputs):\n    # Add metadata to *.tflite models per https://www.tensorflow.org/lite/models/convert/metadata\n    with contextlib.suppress(ImportError):\n        # check_requirements('tflite_support')\n        from tflite_support import flatbuffers\n        from tflite_support import metadata as _metadata\n        from tflite_support import metadata_schema_py_generated as _metadata_fb\n\n        tmp_file = Path('/tmp/meta.txt')\n        with open(tmp_file, 'w') as meta_f:\n            meta_f.write(str(metadata))\n\n        model_meta = _metadata_fb.ModelMetadataT()\n        label_file = _metadata_fb.AssociatedFileT()\n        label_file.name = tmp_file.name\n        model_meta.associatedFiles = [label_file]\n\n        subgraph = _metadata_fb.SubGraphMetadataT()\n        subgraph.inputTensorMetadata = [_metadata_fb.TensorMetadataT()]\n        subgraph.outputTensorMetadata = [_metadata_fb.TensorMetadataT()] * num_outputs\n        model_meta.subgraphMetadata = [subgraph]\n\n        b = flatbuffers.Builder(0)\n        b.Finish(model_meta.Pack(b), _metadata.MetadataPopulator.METADATA_FILE_IDENTIFIER)\n        metadata_buf = b.Output()\n\n        populator = _metadata.MetadataPopulator.with_model_file(file)\n        populator.load_metadata_buffer(metadata_buf)\n        populator.load_associated_files([str(tmp_file)])\n        populator.populate()\n        tmp_file.unlink()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run(\n        data=ROOT / 'data/coco128.yaml',  # 'dataset.yaml path'\n        weights=ROOT / 'yolov5s.pt',  # weights path\n        imgsz=(640, 640),  # image (height, width)\n        batch_size=1,  # batch size\n        device='cpu',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n        include=('torchscript', 'onnx'),  # include formats\n        half=False,  # FP16 half-precision export\n        inplace=False,  # set YOLOv5 Detect() inplace=True\n        keras=False,  # use Keras\n        optimize=False,  # TorchScript: optimize for mobile\n        int8=False,  # CoreML/TF INT8 quantization\n        dynamic=False,  # ONNX/TF/TensorRT: dynamic axes\n        simplify=False,  # ONNX: simplify model\n        opset=12,  # ONNX: opset version\n        verbose=False,  # TensorRT: verbose log\n        workspace=4,  # TensorRT: workspace size (GB)\n        nms=False,  # TF: add NMS to model\n        agnostic_nms=False,  # TF: add agnostic NMS to model\n        topk_per_class=100,  # TF.js NMS: topk per class to keep\n        topk_all=100,  # TF.js NMS: topk for all classes to keep\n        iou_thres=0.45,  # TF.js NMS: IoU threshold\n        conf_thres=0.25,  # TF.js NMS: confidence threshold\n):\n    t = time.time()\n    include = [x.lower() for x in include]  # to lowercase\n    fmts = tuple(export_formats()['Argument'][1:])  # --include arguments\n    flags = [x in include for x in fmts]\n    assert sum(flags) == len(include), f'ERROR: Invalid --include {include}, valid --include arguments are {fmts}'\n    jit, onnx, xml, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle = flags  # export booleans\n    file = Path(url2file(weights) if str(weights).startswith(('http:/', 'https:/')) else weights)  # PyTorch weights\n\n    # Load PyTorch model\n    device = select_device(device)\n    if half:\n        assert device.type != 'cpu' or coreml, '--half only compatible with GPU export, i.e. use --device 0'\n        assert not dynamic, '--half not compatible with --dynamic, i.e. use either --half or --dynamic but not both'\n    model = attempt_load(weights, device=device, inplace=True, fuse=True)  # load FP32 model\n\n    # Checks\n    imgsz *= 2 if len(imgsz) == 1 else 1  # expand\n    if optimize:\n        assert device.type == 'cpu', '--optimize not compatible with cuda devices, i.e. use --device cpu'\n\n    # Input\n    gs = int(max(model.stride))  # grid size (max stride)\n    imgsz = [check_img_size(x, gs) for x in imgsz]  # verify img_size are gs-multiples\n    im = torch.zeros(batch_size, 3, *imgsz).to(device)  # image size(1,3,320,192) BCHW iDetection\n\n    # Update model\n    model.eval()\n    for k, m in model.named_modules():\n        if isinstance(m, Detect):\n            m.inplace = inplace\n            m.dynamic = dynamic\n            m.export = True\n\n    for _ in range(2):\n        y = model(im)  # dry runs\n    if half and not coreml:\n        im, model = im.half(), model.half()  # to FP16\n    shape = tuple((y[0] if isinstance(y, tuple) else y).shape)  # model output shape\n    metadata = {'stride': int(max(model.stride)), 'names': model.names}  # model metadata\n    LOGGER.info(f\"\\n{colorstr('PyTorch:')} starting from {file} with output shape {shape} ({file_size(file):.1f} MB)\")\n\n    # Exports\n    f = [''] * len(fmts)  # exported filenames\n    warnings.filterwarnings(action='ignore', category=torch.jit.TracerWarning)  # suppress TracerWarning\n    if jit:  # TorchScript\n        f[0], _ = export_torchscript(model, im, file, optimize)\n    if engine:  # TensorRT required before ONNX\n        f[1], _ = export_engine(model, im, file, half, dynamic, simplify, workspace, verbose)\n    if onnx or xml:  # OpenVINO requires ONNX\n        f[2], _ = export_onnx(model, im, file, opset, dynamic, simplify)\n    if xml:  # OpenVINO\n        f[3], _ = export_openvino(file, metadata, half)\n    if coreml:  # CoreML\n        f[4], _ = export_coreml(model, im, file, int8, half)\n    if any((saved_model, pb, tflite, edgetpu, tfjs)):  # TensorFlow formats\n        assert not tflite or not tfjs, 'TFLite and TF.js models must be exported separately, please pass only one type.'\n        assert not isinstance(model, ClassificationModel), 'ClassificationModel export to TF formats not yet supported.'\n        f[5], s_model = export_saved_model(model.cpu(),\n                                           im,\n                                           file,\n                                           dynamic,\n                                           tf_nms=nms or agnostic_nms or tfjs,\n                                           agnostic_nms=agnostic_nms or tfjs,\n                                           topk_per_class=topk_per_class,\n                                           topk_all=topk_all,\n                                           iou_thres=iou_thres,\n                                           conf_thres=conf_thres,\n                                           keras=keras)\n        if pb or tfjs:  # pb prerequisite to tfjs\n            f[6], _ = export_pb(s_model, file)\n        if tflite or edgetpu:\n            f[7], _ = export_tflite(s_model, im, file, int8 or edgetpu, data=data, nms=nms, agnostic_nms=agnostic_nms)\n            if edgetpu:\n                f[8], _ = export_edgetpu(file)\n            add_tflite_metadata(f[8] or f[7], metadata, num_outputs=len(s_model.outputs))\n        if tfjs:\n            f[9], _ = export_tfjs(file)\n    if paddle:  # PaddlePaddle\n        f[10], _ = export_paddle(model, im, file, metadata)\n\n    # Finish\n    f = [str(x) for x in f if x]  # filter out '' and None\n    if any(f):\n        cls, det, seg = (isinstance(model, x) for x in (ClassificationModel, DetectionModel, SegmentationModel))  # type\n        det &= not seg  # segmentation models inherit from SegmentationModel(DetectionModel)\n        dir = Path('segment' if seg else 'classify' if cls else '')\n        h = '--half' if half else ''  # --half FP16 inference arg\n        s = \"# WARNING \u26a0\ufe0f ClassificationModel not yet supported for PyTorch Hub AutoShape inference\" if cls else \\\n            \"# WARNING \u26a0\ufe0f SegmentationModel not yet supported for PyTorch Hub AutoShape inference\" if seg else ''\n        LOGGER.info(f'\\nExport complete ({time.time() - t:.1f}s)'\n                    f\"\\nResults saved to {colorstr('bold', file.parent.resolve())}\"\n                    f\"\\nDetect:          python {dir / ('detect.py' if det else 'predict.py')} --weights {f[-1]} {h}\"\n                    f\"\\nValidate:        python {dir / 'val.py'} --weights {f[-1]} {h}\"\n                    f\"\\nPyTorch Hub:     model = torch.hub.load('ultralytics/yolov5', 'custom', '{f[-1]}')  {s}\"\n                    f\"\\nVisualize:       https://netron.app\")\n    return f  # return list of exported files/dirs", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_opt():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128.yaml', help='dataset.yaml path')\n    parser.add_argument('--weights', nargs='+', type=str, default=ROOT / 'yolov5s.pt', help='model.pt path(s)')\n    parser.add_argument('--imgsz', '--img', '--img-size', nargs='+', type=int, default=[640, 640], help='image (h, w)')\n    parser.add_argument('--batch-size', type=int, default=1, help='batch size')\n    parser.add_argument('--device', default='cpu', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--half', action='store_true', help='FP16 half-precision export')\n    parser.add_argument('--inplace', action='store_true', help='set YOLOv5 Detect() inplace=True')\n    parser.add_argument('--keras', action='store_true', help='TF: use Keras')\n    parser.add_argument('--optimize', action='store_true', help='TorchScript: optimize for mobile')\n    parser.add_argument('--int8', action='store_true', help='CoreML/TF INT8 quantization')\n    parser.add_argument('--dynamic', action='store_true', help='ONNX/TF/TensorRT: dynamic axes')\n    parser.add_argument('--simplify', action='store_true', help='ONNX: simplify model')\n    parser.add_argument('--opset', type=int, default=12, help='ONNX: opset version')\n    parser.add_argument('--verbose', action='store_true', help='TensorRT: verbose log')\n    parser.add_argument('--workspace', type=int, default=4, help='TensorRT: workspace size (GB)')\n    parser.add_argument('--nms', action='store_true', help='TF: add NMS to model')\n    parser.add_argument('--agnostic-nms', action='store_true', help='TF: add agnostic NMS to model')\n    parser.add_argument('--topk-per-class', type=int, default=100, help='TF.js NMS: topk per class to keep')\n    parser.add_argument('--topk-all', type=int, default=100, help='TF.js NMS: topk for all classes to keep')\n    parser.add_argument('--iou-thres', type=float, default=0.45, help='TF.js NMS: IoU threshold')\n    parser.add_argument('--conf-thres', type=float, default=0.25, help='TF.js NMS: confidence threshold')\n    parser.add_argument(\n        '--include',\n        nargs='+',\n        default=['torchscript'],\n        help='torchscript, onnx, openvino, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle')\n    opt = parser.parse_args()\n    print_args(vars(opt))\n    return opt", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(opt):\n    for opt.weights in (opt.weights if isinstance(opt.weights, list) else [opt.weights]):\n        run(**vars(opt))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def outer_func(*args, **kwargs):\n        prefix = inner_args['prefix']\n        try:\n            with Profile() as dt:\n                f, model = inner_func(*args, **kwargs)\n            LOGGER.info(f'{prefix} export success \u2705 {dt.t:.1f}s, saved as {f} ({file_size(f):.1f} MB)')\n            return f, model\n        except Exception as e:\n            LOGGER.info(f'{prefix} export failure \u274c {dt.t:.1f}s: {e}')\n            return None, None", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def train(hyp, opt, device, callbacks):  # hyp is path/to/hyp.yaml or hyp dictionary\n    save_dir, epochs, batch_size, weights, single_cls, evolve, data, cfg, resume, noval, nosave, workers, freeze = \\\n        Path(opt.save_dir), opt.epochs, opt.batch_size, opt.weights, opt.single_cls, opt.evolve, opt.data, opt.cfg, \\\n        opt.resume, opt.noval, opt.nosave, opt.workers, opt.freeze\n    callbacks.run('on_pretrain_routine_start')\n\n    # Directories\n    w = save_dir / 'weights'  # weights dir\n    (w.parent if evolve else w).mkdir(parents=True, exist_ok=True)  # make dir\n    last, best = w / 'last.pt', w / 'best.pt'\n\n    # Hyperparameters\n    if isinstance(hyp, str):\n        with open(hyp, errors='ignore') as f:\n            hyp = yaml.safe_load(f)  # load hyps dict\n    LOGGER.info(colorstr('hyperparameters: ') + ', '.join(f'{k}={v}' for k, v in hyp.items()))\n    opt.hyp = hyp.copy()  # for saving hyps to checkpoints\n\n    # Save run settings\n    if not evolve:\n        yaml_save(save_dir / 'hyp.yaml', hyp)\n        yaml_save(save_dir / 'opt.yaml', vars(opt))\n\n    # Loggers\n    data_dict = None\n    if RANK in {-1, 0}:\n        loggers = Loggers(save_dir, weights, opt, hyp, LOGGER)  # loggers instance\n\n        # Register actions\n        for k in methods(loggers):\n            callbacks.register_action(k, callback=getattr(loggers, k))\n\n        # Process custom dataset artifact link\n        data_dict = loggers.remote_dataset\n        if resume:  # If resuming runs from remote artifact\n            weights, epochs, hyp, batch_size = opt.weights, opt.epochs, opt.hyp, opt.batch_size\n\n    # Config\n    plots = not evolve and not opt.noplots  # create plots\n    cuda = device.type != 'cpu'\n    init_seeds(opt.seed + 1 + RANK, deterministic=True)\n    with torch_distributed_zero_first(LOCAL_RANK):\n        data_dict = data_dict or check_dataset(data)  # check if None\n    train_path, val_path = data_dict['train'], data_dict['val']\n    nc = 1 if single_cls else int(data_dict['nc'])  # number of classes\n    names = {0: 'item'} if single_cls and len(data_dict['names']) != 1 else data_dict['names']  # class names\n    is_coco = isinstance(val_path, str) and val_path.endswith('coco/val2017.txt')  # COCO dataset\n\n    # Model\n    check_suffix(weights, '.pt')  # check weights\n    pretrained = weights.endswith('.pt')\n    if pretrained:\n        with torch_distributed_zero_first(LOCAL_RANK):\n            weights = attempt_download(weights)  # download if not found locally\n        ckpt = torch.load(weights, map_location='cpu')  # load checkpoint to CPU to avoid CUDA memory leak\n        model = Model(cfg or ckpt['model'].yaml, ch=3, nc=nc, anchors=hyp.get('anchors')).to(device)  # create\n        exclude = ['anchor'] if (cfg or hyp.get('anchors')) and not resume else []  # exclude keys\n        csd = ckpt['model'].float().state_dict()  # checkpoint state_dict as FP32\n        csd = intersect_dicts(csd, model.state_dict(), exclude=exclude)  # intersect\n        model.load_state_dict(csd, strict=False)  # load\n        LOGGER.info(f'Transferred {len(csd)}/{len(model.state_dict())} items from {weights}')  # report\n    else:\n        model = Model(cfg, ch=3, nc=nc, anchors=hyp.get('anchors')).to(device)  # create\n    amp = check_amp(model)  # check AMP\n\n    # Freeze\n    freeze = [f'model.{x}.' for x in (freeze if len(freeze) > 1 else range(freeze[0]))]  # layers to freeze\n    for k, v in model.named_parameters():\n        v.requires_grad = True  # train all layers\n        # v.register_hook(lambda x: torch.nan_to_num(x))  # NaN to 0 (commented for erratic training results)\n        if any(x in k for x in freeze):\n            LOGGER.info(f'freezing {k}')\n            v.requires_grad = False\n\n    # Image size\n    gs = max(int(model.stride.max()), 32)  # grid size (max stride)\n    imgsz = check_img_size(opt.imgsz, gs, floor=gs * 2)  # verify imgsz is gs-multiple\n\n    # Batch size\n    if RANK == -1 and batch_size == -1:  # single-GPU only, estimate best batch size\n        batch_size = check_train_batch_size(model, imgsz, amp)\n        loggers.on_params_update({\"batch_size\": batch_size})\n\n    # Optimizer\n    nbs = 64  # nominal batch size\n    accumulate = max(round(nbs / batch_size), 1)  # accumulate loss before optimizing\n    hyp['weight_decay'] *= batch_size * accumulate / nbs  # scale weight_decay\n    optimizer = smart_optimizer(model, opt.optimizer, hyp['lr0'], hyp['momentum'], hyp['weight_decay'])\n\n    # Scheduler\n    if opt.cos_lr:\n        lf = one_cycle(1, hyp['lrf'], epochs)  # cosine 1->hyp['lrf']\n    else:\n        lf = lambda x: (1 - x / epochs) * (1.0 - hyp['lrf']) + hyp['lrf']  # linear\n    scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf)  # plot_lr_scheduler(optimizer, scheduler, epochs)\n\n    # EMA\n    ema = ModelEMA(model) if RANK in {-1, 0} else None\n\n    # Resume\n    best_fitness, start_epoch = 0.0, 0\n    if pretrained:\n        if resume:\n            best_fitness, start_epoch, epochs = smart_resume(ckpt, optimizer, ema, weights, epochs, resume)\n        del ckpt, csd\n\n    # DP mode\n    if cuda and RANK == -1 and torch.cuda.device_count() > 1:\n        LOGGER.warning('WARNING \u26a0\ufe0f DP not recommended, use torch.distributed.run for best DDP Multi-GPU results.\\n'\n                       'See Multi-GPU Tutorial at https://github.com/ultralytics/yolov5/issues/475 to get started.')\n        model = torch.nn.DataParallel(model)\n\n    # SyncBatchNorm\n    if opt.sync_bn and cuda and RANK != -1:\n        model = torch.nn.SyncBatchNorm.convert_sync_batchnorm(model).to(device)\n        LOGGER.info('Using SyncBatchNorm()')\n\n    # Trainloader\n    train_loader, dataset = create_dataloader(train_path,\n                                              imgsz,\n                                              batch_size // WORLD_SIZE,\n                                              gs,\n                                              single_cls,\n                                              hyp=hyp,\n                                              augment=True,\n                                              cache=None if opt.cache == 'val' else opt.cache,\n                                              rect=opt.rect,\n                                              rank=LOCAL_RANK,\n                                              workers=workers,\n                                              image_weights=opt.image_weights,\n                                              quad=opt.quad,\n                                              prefix=colorstr('train: '),\n                                              shuffle=True)\n    labels = np.concatenate(dataset.labels, 0)\n    mlc = int(labels[:, 0].max())  # max label class\n    assert mlc < nc, f'Label class {mlc} exceeds nc={nc} in {data}. Possible class labels are 0-{nc - 1}'\n\n    # Process 0\n    if RANK in {-1, 0}:\n        val_loader = create_dataloader(val_path,\n                                       imgsz,\n                                       batch_size // WORLD_SIZE * 2,\n                                       gs,\n                                       single_cls,\n                                       hyp=hyp,\n                                       cache=None if noval else opt.cache,\n                                       rect=True,\n                                       rank=-1,\n                                       workers=workers * 2,\n                                       pad=0.5,\n                                       prefix=colorstr('val: '))[0]\n\n        if not resume:\n            if not opt.noautoanchor:\n                check_anchors(dataset, model=model, thr=hyp['anchor_t'], imgsz=imgsz)  # run AutoAnchor\n            model.half().float()  # pre-reduce anchor precision\n\n        callbacks.run('on_pretrain_routine_end', labels, names)\n\n    # DDP mode\n    if cuda and RANK != -1:\n        model = smart_DDP(model)\n\n    # Model attributes\n    nl = de_parallel(model).model[-1].nl  # number of detection layers (to scale hyps)\n    hyp['box'] *= 3 / nl  # scale to layers\n    hyp['cls'] *= nc / 80 * 3 / nl  # scale to classes and layers\n    hyp['obj'] *= (imgsz / 640) ** 2 * 3 / nl  # scale to image size and layers\n    hyp['label_smoothing'] = opt.label_smoothing\n    model.nc = nc  # attach number of classes to model\n    model.hyp = hyp  # attach hyperparameters to model\n    model.class_weights = labels_to_class_weights(dataset.labels, nc).to(device) * nc  # attach class weights\n    model.names = names\n\n    # Start training\n    t0 = time.time()\n    nb = len(train_loader)  # number of batches\n    nw = max(round(hyp['warmup_epochs'] * nb), 100)  # number of warmup iterations, max(3 epochs, 100 iterations)\n    # nw = min(nw, (epochs - start_epoch) / 2 * nb)  # limit warmup to < 1/2 of training\n    last_opt_step = -1\n    maps = np.zeros(nc)  # mAP per class\n    results = (0, 0, 0, 0, 0, 0, 0)  # P, R, mAP@.5, mAP@.5-.95, val_loss(box, obj, cls)\n    scheduler.last_epoch = start_epoch - 1  # do not move\n    scaler = torch.cuda.amp.GradScaler(enabled=amp)\n    stopper, stop = EarlyStopping(patience=opt.patience), False\n    compute_loss = ComputeLoss(model)  # init loss class\n    callbacks.run('on_train_start')\n    LOGGER.info(f'Image sizes {imgsz} train, {imgsz} val\\n'\n                f'Using {train_loader.num_workers * WORLD_SIZE} dataloader workers\\n'\n                f\"Logging results to {colorstr('bold', save_dir)}\\n\"\n                f'Starting training for {epochs} epochs...')\n    for epoch in range(start_epoch, epochs):  # epoch ------------------------------------------------------------------\n        callbacks.run('on_train_epoch_start')\n        model.train()\n\n        # Update image weights (optional, single-GPU only)\n        if opt.image_weights:\n            cw = model.class_weights.cpu().numpy() * (1 - maps) ** 2 / nc  # class weights\n            iw = labels_to_image_weights(dataset.labels, nc=nc, class_weights=cw)  # image weights\n            dataset.indices = random.choices(range(dataset.n), weights=iw, k=dataset.n)  # rand weighted idx\n\n        # Update mosaic border (optional)\n        # b = int(random.uniform(0.25 * imgsz, 0.75 * imgsz + gs) // gs * gs)\n        # dataset.mosaic_border = [b - imgsz, -b]  # height, width borders\n\n        mloss = torch.zeros(3, device=device)  # mean losses\n        if RANK != -1:\n            train_loader.sampler.set_epoch(epoch)\n        pbar = enumerate(train_loader)\n        LOGGER.info(('\\n' + '%11s' * 7) % ('Epoch', 'GPU_mem', 'box_loss', 'obj_loss', 'cls_loss', 'Instances', 'Size'))\n        if RANK in {-1, 0}:\n            pbar = tqdm(pbar, total=nb, bar_format=TQDM_BAR_FORMAT)  # progress bar\n        optimizer.zero_grad()\n        for i, (imgs, targets, paths, _) in pbar:  # batch -------------------------------------------------------------\n            callbacks.run('on_train_batch_start')\n            ni = i + nb * epoch  # number integrated batches (since train start)\n            imgs = imgs.to(device, non_blocking=True).float() / 255  # uint8 to float32, 0-255 to 0.0-1.0\n\n            # Warmup\n            if ni <= nw:\n                xi = [0, nw]  # x interp\n                # compute_loss.gr = np.interp(ni, xi, [0.0, 1.0])  # iou loss ratio (obj_loss = 1.0 or iou)\n                accumulate = max(1, np.interp(ni, xi, [1, nbs / batch_size]).round())\n                for j, x in enumerate(optimizer.param_groups):\n                    # bias lr falls from 0.1 to lr0, all other lrs rise from 0.0 to lr0\n                    x['lr'] = np.interp(ni, xi, [hyp['warmup_bias_lr'] if j == 0 else 0.0, x['initial_lr'] * lf(epoch)])\n                    if 'momentum' in x:\n                        x['momentum'] = np.interp(ni, xi, [hyp['warmup_momentum'], hyp['momentum']])\n\n            # Multi-scale\n            if opt.multi_scale:\n                sz = random.randrange(imgsz * 0.5, imgsz * 1.5 + gs) // gs * gs  # size\n                sf = sz / max(imgs.shape[2:])  # scale factor\n                if sf != 1:\n                    ns = [math.ceil(x * sf / gs) * gs for x in imgs.shape[2:]]  # new shape (stretched to gs-multiple)\n                    imgs = nn.functional.interpolate(imgs, size=ns, mode='bilinear', align_corners=False)\n\n            # Forward\n            with torch.cuda.amp.autocast(amp):\n                pred = model(imgs)  # forward\n                loss, loss_items = compute_loss(pred, targets.to(device))  # loss scaled by batch_size\n                if RANK != -1:\n                    loss *= WORLD_SIZE  # gradient averaged between devices in DDP mode\n                if opt.quad:\n                    loss *= 4.\n\n            # Backward\n            scaler.scale(loss).backward()\n\n            # Optimize - https://pytorch.org/docs/master/notes/amp_examples.html\n            if ni - last_opt_step >= accumulate:\n                scaler.unscale_(optimizer)  # unscale gradients\n                torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=10.0)  # clip gradients\n                scaler.step(optimizer)  # optimizer.step\n                scaler.update()\n                optimizer.zero_grad()\n                if ema:\n                    ema.update(model)\n                last_opt_step = ni\n\n            # Log\n            if RANK in {-1, 0}:\n                mloss = (mloss * i + loss_items) / (i + 1)  # update mean losses\n                mem = f'{torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0:.3g}G'  # (GB)\n                pbar.set_description(('%11s' * 2 + '%11.4g' * 5) %\n                                     (f'{epoch}/{epochs - 1}', mem, *mloss, targets.shape[0], imgs.shape[-1]))\n                callbacks.run('on_train_batch_end', model, ni, imgs, targets, paths, list(mloss))\n                if callbacks.stop_training:\n                    return\n            # end batch ------------------------------------------------------------------------------------------------\n\n        # Scheduler\n        lr = [x['lr'] for x in optimizer.param_groups]  # for loggers\n        scheduler.step()\n\n        if RANK in {-1, 0}:\n            # mAP\n            callbacks.run('on_train_epoch_end', epoch=epoch)\n            ema.update_attr(model, include=['yaml', 'nc', 'hyp', 'names', 'stride', 'class_weights'])\n            final_epoch = (epoch + 1 == epochs) or stopper.possible_stop\n            if not noval or final_epoch:  # Calculate mAP\n                results, maps, _ = validate.run(data_dict,\n                                                batch_size=batch_size // WORLD_SIZE * 2,\n                                                imgsz=imgsz,\n                                                half=amp,\n                                                model=ema.ema,\n                                                single_cls=single_cls,\n                                                dataloader=val_loader,\n                                                save_dir=save_dir,\n                                                plots=False,\n                                                callbacks=callbacks,\n                                                compute_loss=compute_loss)\n\n            # Update best mAP\n            fi = fitness(np.array(results).reshape(1, -1))  # weighted combination of [P, R, mAP@.5, mAP@.5-.95]\n            stop = stopper(epoch=epoch, fitness=fi)  # early stop check\n            if fi > best_fitness:\n                best_fitness = fi\n            log_vals = list(mloss) + list(results) + lr\n            callbacks.run('on_fit_epoch_end', log_vals, epoch, best_fitness, fi)\n\n            # Save model\n            if (not nosave) or (final_epoch and not evolve):  # if save\n                ckpt = {\n                    'epoch': epoch,\n                    'best_fitness': best_fitness,\n                    'model': deepcopy(de_parallel(model)).half(),\n                    'ema': deepcopy(ema.ema).half(),\n                    'updates': ema.updates,\n                    'optimizer': optimizer.state_dict(),\n                    'opt': vars(opt),\n                    'git': GIT_INFO,  # {remote, branch, commit} if a git repo\n                    'date': datetime.now().isoformat()}\n\n                # Save last, best and delete\n                torch.save(ckpt, last)\n                if best_fitness == fi:\n                    torch.save(ckpt, best)\n                if opt.save_period > 0 and epoch % opt.save_period == 0:\n                    torch.save(ckpt, w / f'epoch{epoch}.pt')\n                del ckpt\n                callbacks.run('on_model_save', last, epoch, final_epoch, best_fitness, fi)\n\n        # EarlyStopping\n        if RANK != -1:  # if DDP training\n            broadcast_list = [stop if RANK == 0 else None]\n            dist.broadcast_object_list(broadcast_list, 0)  # broadcast 'stop' to all ranks\n            if RANK != 0:\n                stop = broadcast_list[0]\n        if stop:\n            break  # must break all DDP ranks\n\n        # end epoch ----------------------------------------------------------------------------------------------------\n    # end training -----------------------------------------------------------------------------------------------------\n    if RANK in {-1, 0}:\n        LOGGER.info(f'\\n{epoch - start_epoch + 1} epochs completed in {(time.time() - t0) / 3600:.3f} hours.')\n        for f in last, best:\n            if f.exists():\n                strip_optimizer(f)  # strip optimizers\n                if f is best:\n                    LOGGER.info(f'\\nValidating {f}...')\n                    results, _, _ = validate.run(\n                        data_dict,\n                        batch_size=batch_size // WORLD_SIZE * 2,\n                        imgsz=imgsz,\n                        model=attempt_load(f, device).half(),\n                        iou_thres=0.65 if is_coco else 0.60,  # best pycocotools at iou 0.65\n                        single_cls=single_cls,\n                        dataloader=val_loader,\n                        save_dir=save_dir,\n                        save_json=is_coco,\n                        verbose=True,\n                        plots=plots,\n                        callbacks=callbacks,\n                        compute_loss=compute_loss)  # val best model with plots\n                    if is_coco:\n                        callbacks.run('on_fit_epoch_end', list(mloss) + list(results) + lr, epoch, best_fitness, fi)\n\n        callbacks.run('on_train_end', last, best, epoch, results)\n\n    torch.cuda.empty_cache()\n    return results", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_opt(known=False):\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--weights', type=str, default=ROOT / 'yolov5s.pt', help='initial weights path')\n    parser.add_argument('--cfg', type=str, default='', help='model.yaml path')\n    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128.yaml', help='dataset.yaml path')\n    parser.add_argument('--hyp', type=str, default=ROOT / 'data/hyps/hyp.scratch-low.yaml', help='hyperparameters path')\n    parser.add_argument('--epochs', type=int, default=100, help='total training epochs')\n    parser.add_argument('--batch-size', type=int, default=16, help='total batch size for all GPUs, -1 for autobatch')\n    parser.add_argument('--imgsz', '--img', '--img-size', type=int, default=640, help='train, val image size (pixels)')\n    parser.add_argument('--rect', action='store_true', help='rectangular training')\n    parser.add_argument('--resume', nargs='?', const=True, default=False, help='resume most recent training')\n    parser.add_argument('--nosave', action='store_true', help='only save final checkpoint')\n    parser.add_argument('--noval', action='store_true', help='only validate final epoch')\n    parser.add_argument('--noautoanchor', action='store_true', help='disable AutoAnchor')\n    parser.add_argument('--noplots', action='store_true', help='save no plot files')\n    parser.add_argument('--evolve', type=int, nargs='?', const=300, help='evolve hyperparameters for x generations')\n    parser.add_argument('--bucket', type=str, default='', help='gsutil bucket')\n    parser.add_argument('--cache', type=str, nargs='?', const='ram', help='image --cache ram/disk')\n    parser.add_argument('--image-weights', action='store_true', help='use weighted image selection for training')\n    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--multi-scale', action='store_true', help='vary img-size +/- 50%%')\n    parser.add_argument('--single-cls', action='store_true', help='train multi-class data as single-class')\n    parser.add_argument('--optimizer', type=str, choices=['SGD', 'Adam', 'AdamW'], default='SGD', help='optimizer')\n    parser.add_argument('--sync-bn', action='store_true', help='use SyncBatchNorm, only available in DDP mode')\n    parser.add_argument('--workers', type=int, default=8, help='max dataloader workers (per RANK in DDP mode)')\n    parser.add_argument('--project', default=ROOT / 'runs/train', help='save to project/name')\n    parser.add_argument('--name', default='exp', help='save to project/name')\n    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n    parser.add_argument('--quad', action='store_true', help='quad dataloader')\n    parser.add_argument('--cos-lr', action='store_true', help='cosine LR scheduler')\n    parser.add_argument('--label-smoothing', type=float, default=0.0, help='Label smoothing epsilon')\n    parser.add_argument('--patience', type=int, default=100, help='EarlyStopping patience (epochs without improvement)')\n    parser.add_argument('--freeze', nargs='+', type=int, default=[0], help='Freeze layers: backbone=10, first3=0 1 2')\n    parser.add_argument('--save-period', type=int, default=-1, help='Save checkpoint every x epochs (disabled if < 1)')\n    parser.add_argument('--seed', type=int, default=0, help='Global training seed')\n    parser.add_argument('--local_rank', type=int, default=-1, help='Automatic DDP Multi-GPU argument, do not modify')\n\n    # Logger arguments\n    parser.add_argument('--entity', default=None, help='Entity')\n    parser.add_argument('--upload_dataset', nargs='?', const=True, default=False, help='Upload data, \"val\" option')\n    parser.add_argument('--bbox_interval', type=int, default=-1, help='Set bounding-box image logging interval')\n    parser.add_argument('--artifact_alias', type=str, default='latest', help='Version of dataset artifact to use')\n\n    return parser.parse_known_args()[0] if known else parser.parse_args()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(opt, callbacks=Callbacks()):\n    # Checks\n    if RANK in {-1, 0}:\n        print_args(vars(opt))\n        check_git_status()\n        check_requirements()\n\n    # Resume (from specified or most recent last.pt)\n    if opt.resume and not check_comet_resume(opt) and not opt.evolve:\n        last = Path(check_file(opt.resume) if isinstance(opt.resume, str) else get_latest_run())\n        opt_yaml = last.parent.parent / 'opt.yaml'  # train options yaml\n        opt_data = opt.data  # original dataset\n        if opt_yaml.is_file():\n            with open(opt_yaml, errors='ignore') as f:\n                d = yaml.safe_load(f)\n        else:\n            d = torch.load(last, map_location='cpu')['opt']\n        opt = argparse.Namespace(**d)  # replace\n        opt.cfg, opt.weights, opt.resume = '', str(last), True  # reinstate\n        if is_url(opt_data):\n            opt.data = check_file(opt_data)  # avoid HUB resume auth timeout\n    else:\n        opt.data, opt.cfg, opt.hyp, opt.weights, opt.project = \\\n            check_file(opt.data), check_yaml(opt.cfg), check_yaml(opt.hyp), str(opt.weights), str(opt.project)  # checks\n        assert len(opt.cfg) or len(opt.weights), 'either --cfg or --weights must be specified'\n        if opt.evolve:\n            if opt.project == str(ROOT / 'runs/train'):  # if default project name, rename to runs/evolve\n                opt.project = str(ROOT / 'runs/evolve')\n            opt.exist_ok, opt.resume = opt.resume, False  # pass resume to exist_ok and disable resume\n        if opt.name == 'cfg':\n            opt.name = Path(opt.cfg).stem  # use model.yaml as name\n        opt.save_dir = str(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok))\n\n    # DDP mode\n    device = select_device(opt.device, batch_size=opt.batch_size)\n    if LOCAL_RANK != -1:\n        msg = 'is not compatible with YOLOv5 Multi-GPU DDP training'\n        assert not opt.image_weights, f'--image-weights {msg}'\n        assert not opt.evolve, f'--evolve {msg}'\n        assert opt.batch_size != -1, f'AutoBatch with --batch-size -1 {msg}, please pass a valid --batch-size'\n        assert opt.batch_size % WORLD_SIZE == 0, f'--batch-size {opt.batch_size} must be multiple of WORLD_SIZE'\n        assert torch.cuda.device_count() > LOCAL_RANK, 'insufficient CUDA devices for DDP command'\n        torch.cuda.set_device(LOCAL_RANK)\n        device = torch.device('cuda', LOCAL_RANK)\n        dist.init_process_group(backend=\"nccl\" if dist.is_nccl_available() else \"gloo\")\n\n    # Train\n    if not opt.evolve:\n        train(opt.hyp, opt, device, callbacks)\n\n    # Evolve hyperparameters (optional)\n    else:\n        # Hyperparameter evolution metadata (mutation scale 0-1, lower_limit, upper_limit)\n        meta = {\n            'lr0': (1, 1e-5, 1e-1),  # initial learning rate (SGD=1E-2, Adam=1E-3)\n            'lrf': (1, 0.01, 1.0),  # final OneCycleLR learning rate (lr0 * lrf)\n            'momentum': (0.3, 0.6, 0.98),  # SGD momentum/Adam beta1\n            'weight_decay': (1, 0.0, 0.001),  # optimizer weight decay\n            'warmup_epochs': (1, 0.0, 5.0),  # warmup epochs (fractions ok)\n            'warmup_momentum': (1, 0.0, 0.95),  # warmup initial momentum\n            'warmup_bias_lr': (1, 0.0, 0.2),  # warmup initial bias lr\n            'box': (1, 0.02, 0.2),  # box loss gain\n            'cls': (1, 0.2, 4.0),  # cls loss gain\n            'cls_pw': (1, 0.5, 2.0),  # cls BCELoss positive_weight\n            'obj': (1, 0.2, 4.0),  # obj loss gain (scale with pixels)\n            'obj_pw': (1, 0.5, 2.0),  # obj BCELoss positive_weight\n            'iou_t': (0, 0.1, 0.7),  # IoU training threshold\n            'anchor_t': (1, 2.0, 8.0),  # anchor-multiple threshold\n            'anchors': (2, 2.0, 10.0),  # anchors per output grid (0 to ignore)\n            'fl_gamma': (0, 0.0, 2.0),  # focal loss gamma (efficientDet default gamma=1.5)\n            'hsv_h': (1, 0.0, 0.1),  # image HSV-Hue augmentation (fraction)\n            'hsv_s': (1, 0.0, 0.9),  # image HSV-Saturation augmentation (fraction)\n            'hsv_v': (1, 0.0, 0.9),  # image HSV-Value augmentation (fraction)\n            'degrees': (1, 0.0, 45.0),  # image rotation (+/- deg)\n            'translate': (1, 0.0, 0.9),  # image translation (+/- fraction)\n            'scale': (1, 0.0, 0.9),  # image scale (+/- gain)\n            'shear': (1, 0.0, 10.0),  # image shear (+/- deg)\n            'perspective': (0, 0.0, 0.001),  # image perspective (+/- fraction), range 0-0.001\n            'flipud': (1, 0.0, 1.0),  # image flip up-down (probability)\n            'fliplr': (0, 0.0, 1.0),  # image flip left-right (probability)\n            'mosaic': (1, 0.0, 1.0),  # image mixup (probability)\n            'mixup': (1, 0.0, 1.0),  # image mixup (probability)\n            'copy_paste': (1, 0.0, 1.0)}  # segment copy-paste (probability)\n\n        with open(opt.hyp, errors='ignore') as f:\n            hyp = yaml.safe_load(f)  # load hyps dict\n            if 'anchors' not in hyp:  # anchors commented in hyp.yaml\n                hyp['anchors'] = 3\n        if opt.noautoanchor:\n            del hyp['anchors'], meta['anchors']\n        opt.noval, opt.nosave, save_dir = True, True, Path(opt.save_dir)  # only val/save final epoch\n        # ei = [isinstance(x, (int, float)) for x in hyp.values()]  # evolvable indices\n        evolve_yaml, evolve_csv = save_dir / 'hyp_evolve.yaml', save_dir / 'evolve.csv'\n        if opt.bucket:\n            os.system(f'gsutil cp gs://{opt.bucket}/evolve.csv {evolve_csv}')  # download evolve.csv if exists\n\n        for _ in range(opt.evolve):  # generations to evolve\n            if evolve_csv.exists():  # if evolve.csv exists: select best hyps and mutate\n                # Select parent(s)\n                parent = 'single'  # parent selection method: 'single' or 'weighted'\n                x = np.loadtxt(evolve_csv, ndmin=2, delimiter=',', skiprows=1)\n                n = min(5, len(x))  # number of previous results to consider\n                x = x[np.argsort(-fitness(x))][:n]  # top n mutations\n                w = fitness(x) - fitness(x).min() + 1E-6  # weights (sum > 0)\n                if parent == 'single' or len(x) == 1:\n                    # x = x[random.randint(0, n - 1)]  # random selection\n                    x = x[random.choices(range(n), weights=w)[0]]  # weighted selection\n                elif parent == 'weighted':\n                    x = (x * w.reshape(n, 1)).sum(0) / w.sum()  # weighted combination\n\n                # Mutate\n                mp, s = 0.8, 0.2  # mutation probability, sigma\n                npr = np.random\n                npr.seed(int(time.time()))\n                g = np.array([meta[k][0] for k in hyp.keys()])  # gains 0-1\n                ng = len(meta)\n                v = np.ones(ng)\n                while all(v == 1):  # mutate until a change occurs (prevent duplicates)\n                    v = (g * (npr.random(ng) < mp) * npr.randn(ng) * npr.random() * s + 1).clip(0.3, 3.0)\n                for i, k in enumerate(hyp.keys()):  # plt.hist(v.ravel(), 300)\n                    hyp[k] = float(x[i + 7] * v[i])  # mutate\n\n            # Constrain to limits\n            for k, v in meta.items():\n                hyp[k] = max(hyp[k], v[1])  # lower limit\n                hyp[k] = min(hyp[k], v[2])  # upper limit\n                hyp[k] = round(hyp[k], 5)  # significant digits\n\n            # Train mutation\n            results = train(hyp.copy(), opt, device, callbacks)\n            callbacks = Callbacks()\n            # Write mutation results\n            keys = ('metrics/precision', 'metrics/recall', 'metrics/mAP_0.5', 'metrics/mAP_0.5:0.95', 'val/box_loss',\n                    'val/obj_loss', 'val/cls_loss')\n            print_mutation(keys, results, hyp.copy(), save_dir, opt.bucket)\n\n        # Plot results\n        plot_evolve(evolve_csv)\n        LOGGER.info(f'Hyperparameter evolution finished {opt.evolve} generations\\n'\n                    f\"Results saved to {colorstr('bold', save_dir)}\\n\"\n                    f'Usage example: $ python train.py --hyp {evolve_yaml}')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run(**kwargs):\n    # Usage: import train; train.run(data='coco128.yaml', imgsz=320, weights='yolov5m.pt')\n    opt = parse_opt(True)\n    for k, v in kwargs.items():\n        setattr(opt, k, v)\n    main(opt)\n    return opt", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def _create(name, pretrained=True, channels=3, classes=80, autoshape=True, verbose=True, device=None):\n    \"\"\"Creates or loads a YOLOv5 model\n\n    Arguments:\n        name (str): model name 'yolov5s' or path 'path/to/best.pt'\n        pretrained (bool): load pretrained weights into the model\n        channels (int): number of input channels\n        classes (int): number of model classes\n        autoshape (bool): apply YOLOv5 .autoshape() wrapper to model\n        verbose (bool): print all information to screen\n        device (str, torch.device, None): device to use for model parameters\n\n    Returns:\n        YOLOv5 model\n    \"\"\"\n    from pathlib import Path\n\n    from models.common import AutoShape, DetectMultiBackend\n    from models.experimental import attempt_load\n    from models.yolo import ClassificationModel, DetectionModel, SegmentationModel\n    from utils.downloads import attempt_download\n    from utils.general import LOGGER, check_requirements, intersect_dicts, logging\n    from utils.torch_utils import select_device\n\n    if not verbose:\n        LOGGER.setLevel(logging.WARNING)\n    check_requirements(exclude=('opencv-python', 'tensorboard', 'thop'))\n    name = Path(name)\n    path = name.with_suffix('.pt') if name.suffix == '' and not name.is_dir() else name  # checkpoint path\n    try:\n        device = select_device(device)\n        if pretrained and channels == 3 and classes == 80:\n            try:\n                model = DetectMultiBackend(path, device=device, fuse=autoshape)  # detection model\n                if autoshape:\n                    if model.pt and isinstance(model.model, ClassificationModel):\n                        LOGGER.warning('WARNING \u26a0\ufe0f YOLOv5 ClassificationModel is not yet AutoShape compatible. '\n                                       'You must pass torch tensors in BCHW to this model, i.e. shape(1,3,224,224).')\n                    elif model.pt and isinstance(model.model, SegmentationModel):\n                        LOGGER.warning('WARNING \u26a0\ufe0f YOLOv5 SegmentationModel is not yet AutoShape compatible. '\n                                       'You will not be able to run inference with this model.')\n                    else:\n                        model = AutoShape(model)  # for file/URI/PIL/cv2/np inputs and NMS\n            except Exception:\n                model = attempt_load(path, device=device, fuse=False)  # arbitrary model\n        else:\n            cfg = list((Path(__file__).parent / 'models').rglob(f'{path.stem}.yaml'))[0]  # model.yaml path\n            model = DetectionModel(cfg, channels, classes)  # create model\n            if pretrained:\n                ckpt = torch.load(attempt_download(path), map_location=device)  # load\n                csd = ckpt['model'].float().state_dict()  # checkpoint state_dict as FP32\n                csd = intersect_dicts(csd, model.state_dict(), exclude=['anchors'])  # intersect\n                model.load_state_dict(csd, strict=False)  # load\n                if len(ckpt['model'].names) == classes:\n                    model.names = ckpt['model'].names  # set class names attribute\n        if not verbose:\n            LOGGER.setLevel(logging.INFO)  # reset to default\n        return model.to(device)\n\n    except Exception as e:\n        help_url = 'https://github.com/ultralytics/yolov5/issues/36'\n        s = f'{e}. Cache may be out of date, try `force_reload=True` or see {help_url} for help.'\n        raise Exception(s) from e", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def custom(path='path/to/model.pt', autoshape=True, _verbose=True, device=None):\n    # YOLOv5 custom or local model\n    return _create(path, autoshape=autoshape, verbose=_verbose, device=device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def yolov5n(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    # YOLOv5-nano model https://github.com/ultralytics/yolov5\n    return _create('yolov5n', pretrained, channels, classes, autoshape, _verbose, device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def yolov5s(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    # YOLOv5-small model https://github.com/ultralytics/yolov5\n    return _create('yolov5s', pretrained, channels, classes, autoshape, _verbose, device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def yolov5m(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    # YOLOv5-medium model https://github.com/ultralytics/yolov5\n    return _create('yolov5m', pretrained, channels, classes, autoshape, _verbose, device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def yolov5l(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    # YOLOv5-large model https://github.com/ultralytics/yolov5\n    return _create('yolov5l', pretrained, channels, classes, autoshape, _verbose, device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def yolov5x(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    # YOLOv5-xlarge model https://github.com/ultralytics/yolov5\n    return _create('yolov5x', pretrained, channels, classes, autoshape, _verbose, device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def yolov5n6(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    # YOLOv5-nano-P6 model https://github.com/ultralytics/yolov5\n    return _create('yolov5n6', pretrained, channels, classes, autoshape, _verbose, device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def yolov5s6(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    # YOLOv5-small-P6 model https://github.com/ultralytics/yolov5\n    return _create('yolov5s6', pretrained, channels, classes, autoshape, _verbose, device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def yolov5m6(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    # YOLOv5-medium-P6 model https://github.com/ultralytics/yolov5\n    return _create('yolov5m6', pretrained, channels, classes, autoshape, _verbose, device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def yolov5l6(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    # YOLOv5-large-P6 model https://github.com/ultralytics/yolov5\n    return _create('yolov5l6', pretrained, channels, classes, autoshape, _verbose, device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def yolov5x6(pretrained=True, channels=3, classes=80, autoshape=True, _verbose=True, device=None):\n    # YOLOv5-xlarge-P6 model https://github.com/ultralytics/yolov5\n    return _create('yolov5x6', pretrained, channels, classes, autoshape, _verbose, device)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(pdf_image_prefix,local_target):\n    \"\"\"\n    target_file_name: str of name of file we are looking for.\n    Assumption: input_images/ has been updated with the latest images. \n    \"\"\"\n    print(\"running yolov5/main.py...\")\n\n    os.chdir(\"/home/ubuntu/MathSearch/ml-model/yolov5\")\n    target_file_name = local_target\n\n    # Dataset contains output of YOLO model \n    # Clear folder to reset working directory \n    dataset_path = \"ranking/dataset\"\n    if(os.path.isdir(dataset_path)):\n      shutil.rmtree(dataset_path)\n\n    # Call YOLO model. \n    # Uses best.torchscript weights \n    # Input data: input_data/\n    # Writing output to ranking/dataset\n    run('conda run -n pytorch python detect.py --weights best.torchscript --source input_data/{} --save-txt --save-crop --project ranking/dataset/'.format(sys.argv[1]), shell=True)\n\n    # Get list of files written to YOLO output, except for target_file_name\n    dir_list = os.listdir(os.path.join(dataset_path,\"exp\" ,\"crops\", \"equation\"))\n    dir_list = [x for x in dir_list if x != target_file_name]\n\n    # Construct tbl of generated crops for similarity detection model \n    img_database = pd.DataFrame(columns = ['image_name', 'image_source', 'coo_1', 'coo_2', 'coo_3', 'coo_4'])\n    for f in dir_list:\n      img_source, rem  = f.split(\"__\")\n      df = pd.read_csv(os.path.join(dataset_path,\"exp\" ,\"labels/\") + img_source + \".txt\", delim_whitespace=True, header=None)\n      new_row = {'image_name': f, 'image_source': img_source, 'coo_1':df.iloc[0, 1], \n          'coo_2':df.iloc[0, 2], 'coo_3': df.iloc[0, 3], \n          'coo_4': df.iloc[0, 4]} \n      img_database = img_database.append(new_row, ignore_index = True) \n    img_database.to_csv(\"ranking/img_database.csv\") \n\n    # Call similarity detection model \n    # Writes final output to top5.csv\n    run('conda run -n pytorch python ./ranking/ImageMatching.py',shell=True )", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def send_result_to_frontend(pdf_name):\n    result_coords = \"\"\n    result_csv = \"/home/ubuntu/MathSearch/ml-model/yolov5/ranking/top5.csv\"\n    with open(result_csv, 'r') as f:\n        reader = csv.reader(f, delimiter=',')\n        for row in reader:\n            # adding page number and coords for each re-rank\n            # # result_coords += str(int(row[0])+1) + \" \"\n            result_coords += row[0] + \" \"\n            result_coords += row[3] + \" \"\n            result_coords += row[4] + \" \"\n            result_coords += row[5] + \" \"\n            result_coords += row[6] + \" \"\n    frontend_url = \"http://3.94.25.91/api/result\"\n    json = {\n        \"file\":pdf_name,\n        \"coords\":result_coords\n    }\n    print(pdf_name)\n    print(result_coords)\n    res = requests.get(frontend_url, json=json)\n    res = print(res) # OK = 200", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def remove_files():\n    global DATA_FOLDER\n    for f in os.listdir(DATA_FOLDER):\n        try:\n            os.remove(os.path.join(DATA_FOLDER, f))\n        except:\n            shutil.rmtree(os.path.join(DATA_FOLDER, f)) ", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def download_files(pdf_name, target_name):\n    global DATA_FOLDER\n    global PREPROCESS_FOLDER\n    s3 = boto3.client(\"s3\")\n    MATHSEARCH_BUCKET='mathsearch-intermediary'\n    local_pdf = PREPROCESS_FOLDER + pdf_name\n    local_target = DATA_FOLDER + target_name[:-5] + \"target.png\"\n    print(\"local_pdf\",local_pdf)\n    print(\"pdf_name\",pdf_name)\n\n    # download and preprocess pdf to png\n    s3.download_file(\n        Bucket=MATHSEARCH_BUCKET, Key=\"inputs/\"+pdf_name, Filename=local_pdf\n    )\n    images = pdf2image.convert_from_path(local_pdf)\n    print(local_pdf)\n    os.mkdir(DATA_FOLDER + pdf_name)\n    for i in range(len(images)):\n        pdf_image = DATA_FOLDER + pdf_name + \"/\"+ str(i) + \".png\"\n        print(pdf_image)\n        images[i].save(pdf_image)\n    \n    # download target png\n    s3.download_file(\n        Bucket=MATHSEARCH_BUCKET, Key=\"inputs/\"+target_name, Filename=local_target\n    )", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run(\n        weights=ROOT / 'yolov5s.pt',  # model path or triton URL\n        source=ROOT / 'data/images',  # file/dir/URL/glob/screen/0(webcam)\n        data=ROOT / 'data/coco128.yaml',  # dataset.yaml path\n        imgsz=(640, 640),  # inference size (height, width)\n        conf_thres=0.25,  # confidence threshold\n        iou_thres=0.45,  # NMS IOU threshold\n        max_det=1000,  # maximum detections per image\n        device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n        view_img=False,  # show results\n        save_txt=False,  # save results to *.txt\n        save_conf=False,  # save confidences in --save-txt labels\n        save_crop=False,  # save cropped prediction boxes\n        nosave=False,  # do not save images/videos\n        classes=None,  # filter by class: --class 0, or --class 0 2 3\n        agnostic_nms=False,  # class-agnostic NMS\n        augment=False,  # augmented inference\n        visualize=False,  # visualize features\n        update=False,  # update all models\n        project=ROOT / 'runs/detect',  # save results to project/name\n        name='exp',  # save results to project/name\n        exist_ok=False,  # existing project/name ok, do not increment\n        line_thickness=3,  # bounding box thickness (pixels)\n        hide_labels=False,  # hide labels\n        hide_conf=False,  # hide confidences\n        half=False,  # use FP16 half-precision inference\n        dnn=False,  # use OpenCV DNN for ONNX inference\n        vid_stride=1,  # video frame-rate stride\n):\n    source = str(source)\n    save_img = not nosave and not source.endswith('.txt')  # save inference images\n    is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)\n    is_url = source.lower().startswith(('rtsp://', 'rtmp://', 'http://', 'https://'))\n    webcam = source.isnumeric() or source.endswith('.txt') or (is_url and not is_file)\n    screenshot = source.lower().startswith('screen')\n    if is_url and is_file:\n        source = check_file(source)  # download\n\n    # Directories\n    save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n    (save_dir / 'labels' if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # make dir\n\n    # Load model\n    device = select_device(device)\n    model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)\n    stride, names, pt = model.stride, model.names, model.pt\n    imgsz = check_img_size(imgsz, s=stride)  # check image size\n\n    # Dataloader\n    bs = 1  # batch_size\n    if webcam:\n        view_img = check_imshow(warn=True)\n        dataset = LoadStreams(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n        bs = len(dataset)\n    elif screenshot:\n        dataset = LoadScreenshots(source, img_size=imgsz, stride=stride, auto=pt)\n    else:\n        dataset = LoadImages(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n    vid_path, vid_writer = [None] * bs, [None] * bs\n\n    # Run inference\n    model.warmup(imgsz=(1 if pt or model.triton else bs, 3, *imgsz))  # warmup\n    seen, windows, dt = 0, [], (Profile(), Profile(), Profile())\n    for path, im, im0s, vid_cap, s in dataset:\n        # print(im.shape, im)\n\n        with dt[0]:\n            im = torch.from_numpy(im).to(model.device)\n            im = im.half() if model.fp16 else im.float()  # uint8 to fp16/32\n            im /= 255  # 0 - 255 to 0.0 - 1.0\n            if len(im.shape) == 3:\n                im = im[None]  # expand for batch dim\n        \n        # Inference\n        with dt[1]:\n            visualize = increment_path(save_dir / Path(path).stem, mkdir=True) if visualize else False\n            pred = model(im, augment=augment, visualize=visualize)\n\n        # NMS\n        with dt[2]:\n            pred = non_max_suppression(pred, conf_thres, iou_thres, classes, agnostic_nms, max_det=max_det)\n\n        # Second-stage classifier (optional)\n        # pred = utils.general.apply_classifier(pred, classifier_model, im, im0s)\n\n        # Process predictions\n        for i, det in enumerate(pred):  # per image\n            seen += 1\n            if webcam:  # batch_size >= 1\n                p, im0, frame = path[i], im0s[i].copy(), dataset.count\n                s += f'{i}: '\n            else:\n                p, im0, frame = path, im0s.copy(), getattr(dataset, 'frame', 0)\n\n            p = Path(p)  # to Path\n            save_path = str(save_dir / p.name)  # im.jpg\n            txt_path = str(save_dir / 'labels' / p.stem) + ('' if dataset.mode == 'image' else f'_{frame}')  # im.txt\n            s += '%gx%g ' % im.shape[2:]  # print string\n            gn = torch.tensor(im0.shape)[[1, 0, 1, 0]]  # normalization gain whwh\n            imc = im0.copy() if save_crop else im0  # for save_crop\n            annotator = Annotator(im0, line_width=line_thickness, example=str(names))\n            if len(det):\n                # Rescale boxes from img_size to im0 size\n                det[:, :4] = scale_boxes(im.shape[2:], det[:, :4], im0.shape).round()\n\n                # Print results\n                for c in det[:, 5].unique():\n                    n = (det[:, 5] == c).sum()  # detections per class\n                    s += f\"{n} {names[int(c)]}{'s' * (n > 1)}, \"  # add to string\n\n                # Write results\n                for *xyxy, conf, cls in reversed(det):\n                    if save_txt:  # Write to file\n                        xywh = (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh\n                        line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format\n                        with open(f'{txt_path}.txt', 'a') as f:\n                            f.write(('%g ' * len(line)).rstrip() % line + '\\n')\n\n                    if save_img or save_crop or view_img:  # Add bbox to image\n                        c = int(cls)  # integer class\n                        label = None if hide_labels else (names[c] if hide_conf else f'{names[c]} {conf:.2f}')\n                        annotator.box_label(xyxy, label, color=colors(c, True))\n                    if save_crop:\n                        save_one_box(xyxy, imc, file=save_dir / 'crops' / names[c] / f'{p.stem}__.jpg', BGR=True)\n\n            # Stream results\n            im0 = annotator.result()\n            if view_img:\n                if platform.system() == 'Linux' and p not in windows:\n                    windows.append(p)\n                    cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # allow window resize (Linux)\n                    cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])\n                cv2.imshow(str(p), im0)\n                cv2.waitKey(1)  # 1 millisecond\n\n            # Save results (image with detections)\n            if save_img:\n                if dataset.mode == 'image':\n                    cv2.imwrite(save_path, im0)\n                else:  # 'video' or 'stream'\n                    if vid_path[i] != save_path:  # new video\n                        vid_path[i] = save_path\n                        if isinstance(vid_writer[i], cv2.VideoWriter):\n                            vid_writer[i].release()  # release previous video writer\n                        if vid_cap:  # video\n                            fps = vid_cap.get(cv2.CAP_PROP_FPS)\n                            w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n                            h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n                        else:  # stream\n                            fps, w, h = 30, im0.shape[1], im0.shape[0]\n                        save_path = str(Path(save_path).with_suffix('.mp4'))  # force *.mp4 suffix on results videos\n                        vid_writer[i] = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*'mp4v'), fps, (w, h))\n                    vid_writer[i].write(im0)\n\n        # Print time (inference-only)\n        LOGGER.info(f\"{s}{'' if len(det) else '(no detections), '}{dt[1].dt * 1E3:.1f}ms\")\n\n    # Print results\n    t = tuple(x.t / seen * 1E3 for x in dt)  # speeds per image\n    LOGGER.info(f'Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {(1, 3, *imgsz)}' % t)\n    if save_txt or save_img:\n        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else ''\n        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n    if update:\n        strip_optimizer(weights[0])  # update model (to fix SourceChangeWarning)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_opt():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--weights', nargs='+', type=str, default=ROOT / 'yolov5s.pt', help='model path or triton URL')\n    parser.add_argument('--source', type=str, default=ROOT / 'data/images', help='file/dir/URL/glob/screen/0(webcam)')\n    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128.yaml', help='(optional) dataset.yaml path')\n    parser.add_argument('--imgsz', '--img', '--img-size', nargs='+', type=int, default=[640], help='inference size h,w')\n    parser.add_argument('--conf-thres', type=float, default=0.50, help='confidence threshold')\n    parser.add_argument('--iou-thres', type=float, default=0.45, help='NMS IoU threshold')\n    parser.add_argument('--max-det', type=int, default=1000, help='maximum detections per image')\n    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--view-img', action='store_true', help='show results')\n    parser.add_argument('--save-txt', action='store_true', help='save results to *.txt')\n    parser.add_argument('--save-conf', action='store_true', help='save confidences in --save-txt labels')\n    parser.add_argument('--save-crop', action='store_true', help='save cropped prediction boxes')\n    parser.add_argument('--nosave', action='store_true', help='do not save images/videos')\n    parser.add_argument('--classes', nargs='+', type=int, help='filter by class: --classes 0, or --classes 0 2 3')\n    parser.add_argument('--agnostic-nms', action='store_true', help='class-agnostic NMS')\n    parser.add_argument('--augment', action='store_true', help='augmented inference')\n    parser.add_argument('--visualize', action='store_true', help='visualize features')\n    parser.add_argument('--update', action='store_true', help='update all models')\n    parser.add_argument('--project', default=ROOT / 'runs/detect', help='save results to project/name')\n    parser.add_argument('--name', default='exp', help='save results to project/name')\n    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n    parser.add_argument('--line-thickness', default=3, type=int, help='bounding box thickness (pixels)')\n    parser.add_argument('--hide-labels', default=False, action='store_true', help='hide labels')\n    parser.add_argument('--hide-conf', default=False, action='store_true', help='hide confidences')\n    parser.add_argument('--half', action='store_true', help='use FP16 half-precision inference')\n    parser.add_argument('--dnn', action='store_true', help='use OpenCV DNN for ONNX inference')\n    parser.add_argument('--vid-stride', type=int, default=1, help='video frame-rate stride')\n    opt = parser.parse_args()\n    opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # expand\n    print_args(vars(opt))\n    return opt", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(opt):\n    check_requirements(exclude=('tensorboard', 'thop'))\n    run(**vars(opt))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def run(\n        weights=ROOT / 'yolov5s.pt',  # weights path\n        imgsz=640,  # inference size (pixels)\n        batch_size=1,  # batch size\n        data=ROOT / 'data/coco128.yaml',  # dataset.yaml path\n        device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n        half=False,  # use FP16 half-precision inference\n        test=False,  # test exports only\n        pt_only=False,  # test PyTorch only\n        hard_fail=False,  # throw error on benchmark failure\n):\n    y, t = [], time.time()\n    device = select_device(device)\n    model_type = type(attempt_load(weights, fuse=False))  # DetectionModel, SegmentationModel, etc.\n    for i, (name, f, suffix, cpu, gpu) in export.export_formats().iterrows():  # index, (name, file, suffix, CPU, GPU)\n        try:\n            assert i not in (9, 10), 'inference not supported'  # Edge TPU and TF.js are unsupported\n            assert i != 5 or platform.system() == 'Darwin', 'inference only supported on macOS>=10.13'  # CoreML\n            if 'cpu' in device.type:\n                assert cpu, 'inference not supported on CPU'\n            if 'cuda' in device.type:\n                assert gpu, 'inference not supported on GPU'\n\n            # Export\n            if f == '-':\n                w = weights  # PyTorch format\n            else:\n                w = export.run(weights=weights, imgsz=[imgsz], include=[f], device=device, half=half)[-1]  # all others\n            assert suffix in str(w), 'export failed'\n\n            # Validate\n            if model_type == SegmentationModel:\n                result = val_seg(data, w, batch_size, imgsz, plots=False, device=device, task='speed', half=half)\n                metric = result[0][7]  # (box(p, r, map50, map), mask(p, r, map50, map), *loss(box, obj, cls))\n            else:  # DetectionModel:\n                result = val_det(data, w, batch_size, imgsz, plots=False, device=device, task='speed', half=half)\n                metric = result[0][3]  # (p, r, map50, map, *loss(box, obj, cls))\n            speed = result[2][1]  # times (preprocess, inference, postprocess)\n            y.append([name, round(file_size(w), 1), round(metric, 4), round(speed, 2)])  # MB, mAP, t_inference\n        except Exception as e:\n            if hard_fail:\n                assert type(e) is AssertionError, f'Benchmark --hard-fail for {name}: {e}'\n            LOGGER.warning(f'WARNING \u26a0\ufe0f Benchmark failure for {name}: {e}')\n            y.append([name, None, None, None])  # mAP, t_inference\n        if pt_only and i == 0:\n            break  # break after PyTorch\n\n    # Print results\n    LOGGER.info('\\n')\n    parse_opt()\n    notebook_init()  # print system info\n    c = ['Format', 'Size (MB)', 'mAP50-95', 'Inference time (ms)'] if map else ['Format', 'Export', '', '']\n    py = pd.DataFrame(y, columns=c)\n    LOGGER.info(f'\\nBenchmarks complete ({time.time() - t:.2f}s)')\n    LOGGER.info(str(py if map else py.iloc[:, :2]))\n    if hard_fail and isinstance(hard_fail, str):\n        metrics = py['mAP50-95'].array  # values to compare to floor\n        floor = eval(hard_fail)  # minimum metric floor to pass, i.e. = 0.29 mAP for YOLOv5n\n        assert all(x > floor for x in metrics if pd.notna(x)), f'HARD FAIL: mAP50-95 < floor {floor}'\n    return py", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def test(\n        weights=ROOT / 'yolov5s.pt',  # weights path\n        imgsz=640,  # inference size (pixels)\n        batch_size=1,  # batch size\n        data=ROOT / 'data/coco128.yaml',  # dataset.yaml path\n        device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n        half=False,  # use FP16 half-precision inference\n        test=False,  # test exports only\n        pt_only=False,  # test PyTorch only\n        hard_fail=False,  # throw error on benchmark failure\n):\n    y, t = [], time.time()\n    device = select_device(device)\n    for i, (name, f, suffix, gpu) in export.export_formats().iterrows():  # index, (name, file, suffix, gpu-capable)\n        try:\n            w = weights if f == '-' else \\\n                export.run(weights=weights, imgsz=[imgsz], include=[f], device=device, half=half)[-1]  # weights\n            assert suffix in str(w), 'export failed'\n            y.append([name, True])\n        except Exception:\n            y.append([name, False])  # mAP, t_inference\n\n    # Print results\n    LOGGER.info('\\n')\n    parse_opt()\n    notebook_init()  # print system info\n    py = pd.DataFrame(y, columns=['Format', 'Export'])\n    LOGGER.info(f'\\nExports complete ({time.time() - t:.2f}s)')\n    LOGGER.info(str(py))\n    return py", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def parse_opt():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--weights', type=str, default=ROOT / 'yolov5s.pt', help='weights path')\n    parser.add_argument('--imgsz', '--img', '--img-size', type=int, default=640, help='inference size (pixels)')\n    parser.add_argument('--batch-size', type=int, default=1, help='batch size')\n    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128.yaml', help='dataset.yaml path')\n    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n    parser.add_argument('--half', action='store_true', help='use FP16 half-precision inference')\n    parser.add_argument('--test', action='store_true', help='test exports only')\n    parser.add_argument('--pt-only', action='store_true', help='test PyTorch only')\n    parser.add_argument('--hard-fail', nargs='?', const=True, default=False, help='Exception on error or < min metric')\n    opt = parser.parse_args()\n    opt.data = check_yaml(opt.data)  # check YAML\n    print_args(vars(opt))\n    return opt", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(opt):\n    test(**vars(opt)) if opt.test else run(**vars(opt))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def imshow(img, text=None, should_save=False):\n    npimg = img.numpy()\n    plt.axis(\"off\")\n    if text:\n        plt.text(\n            75,\n            8,\n            text,\n            style=\"italic\",\n            fontweight=\"bold\",\n            bbox={\"facecolor\": \"white\", \"alpha\": 0.8, \"pad\": 10},\n        )\n    plt.imshow(np.transpose(npimg, (1, 2, 0)))\n    plt.show()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def show_plot(iteration, loss):\n    plt.plot(iteration, loss)\n    plt.show()", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "  def __init__(self, model):\n    super(SiameseNetwork, self).__init__()\n\t\t# Extract VGG-16 Feature Layers\n    self.features = list(model.features)\n    self.features = nn.Sequential(*self.features)\n\t\t# Extract VGG-16 Average Pooling Layer\n    self.pooling = model.avgpool\n\t\t# Convert the image into one-dimensional vector\n    self.flatten = nn.Flatten()\n\t\t# Extract the first part of fully-connected layer from VGG16\n    self.fc = model.classifier[0]", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "  def forward_once(self, x):\n        # Forward pass \n        out = self.features(x)\n        out = self.pooling(out)\n        out = self.flatten(out)\n        out = self.fc(out) \n        return out", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "  def forward(self, input1, input2):\n        output1 = self.forward_once(input1)\n        output2 = self.forward_once(input2)\n        return output1, output2", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, margin=1.0):\n        super(ContrastiveLoss, self).__init__()\n        self.margin = margin", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, x0, x1, y):\n        # euclidian distance\n        diff = x0 - x1\n        dist_sq = torch.sum(torch.pow(diff, 2), 1)\n        dist = torch.sqrt(dist_sq)\n\n        mdist = self.margin - dist\n        dist = torch.clamp(mdist, min=0.0)\n        loss = y * dist_sq + (1 - y) * torch.pow(dist, 2)\n        loss = torch.sum(loss) / 2.0 / x0.size()[0]\n        return loss", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, training_csv=None, training_dir=None, transform=None):\n        # used to prepare the labels and images path\n        self.train_df = pd.read_csv(training_csv)\n        # self.train_df = pd.read_csv(training_csv)\n        # self.train_df.columns = [\"image1\", \"image2\", \"label\"]\n        self.train_dir = training_dir\n        self.transform = transform", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __getitem__(self, index):\n\n        # getting the image path\n        image1_path = os.path.join(self.train_dir, self.train_df.iat[index, 0])\n        image2_path = os.path.join(self.train_dir, self.train_df.iat[index, 1])\n\n        # Loading the image\n        img0 = Image.open(image1_path).convert(mode='RGB')\n        img1 = Image.open(image2_path).convert(mode='RGB')\n        # img0 = img0.convert(\"L\")\n        # img1 = img1.convert(\"L\")\n\n        # Apply image transformations\n        if self.transform is not None:\n            img0 = self.transform(img0)\n            img1 = self.transform(img1)\n\n        return (\n            img0,\n            img1,\n            torch.from_numpy(\n                np.array([int(self.train_df.iat[index, 2])], dtype=np.float32)\n            ),\n        )", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __len__(self):\n        return len(self.train_df)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def __init__(self, margin=2.0):\n        super(ContrastiveLoss, self).__init__()\n        self.margin = margin", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def forward(self, output1, output2, label):\n        euclidean_distance = F.pairwise_distance(output1, output2)\n        loss_contrastive = torch.mean(\n            (1 - label) * torch.pow(euclidean_distance, 2)\n            + (label)\n            * torch.pow(torch.clamp(self.margin - euclidean_distance, min=0.0), 2)\n        )\n\n        return loss_contrastive", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "    def train():\n        loss=[] \n        counter=[]\n        iteration_number = 0\n\n        k = 0\n        for epoch in range(1, 2):\n            for i, data in enumerate(test_dataloader,0):\n                k += 1\n                if k % 10 == 0: print(k)\n            # for i, data in enumerate(train_dataloader,0):\n                img0, img1 , label = data\n                # img0, img1 , label = img0.cuda(), img1.cuda() , label.cuda()\n                optimizer.zero_grad()\n                output1,output2 = net(img0,img1)\n                loss_contrastive = criterion(output1,output2,label)\n                loss_contrastive.backward()\n                optimizer.step()    \n            print(\"Epoch {}\\n Current loss {}\\n\".format(epoch,loss_contrastive.item()))\n            iteration_number += 10\n            counter.append(iteration_number)\n            loss.append(loss_contrastive.item())\n        show_plot(counter, loss)   \n        return net", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def show(imgs):\n    fix, axs = plt.subplots(ncols=len(imgs), squeeze=False)\n    for i, img in enumerate(imgs):\n        img = T.ToPILImage()(img.to('cpu'))\n        axs[0, i].imshow(np.asarray(img))\n        axs[0, i].set(xticklabels=[], yticklabels=[], xticks=[], yticks=[])", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def remove_files(data_dir):\n\tfor f in os.listdir(data_dir):\n\t\tos.remove(os.path.join(data_dir, f))", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def hello_world():\n    return 'Hello World! - emerald@mathsearch port:3000 temp:1'", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def allowed_file(filename):\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def upload_file():\n    if request.method == 'POST':\n        # check if the post request has the file part\n        if 'file' not in request.files:\n            flash('No file part')\n            return redirect(request.url)\n        file = request.files['file']\n        # If the user does not select a file, the browser submits an\n        # empty file without a filename.\n        if file.filename == '':\n            flash('No selected file')\n            return redirect(request.url)\n        if file and allowed_file(file.filename):\n            filename = secure_filename(file.filename)\n            # file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n            file.save(app.config['UPLOAD_FOLDER'], filename)\n            return redirect(url_for('download_file', name=filename))\n    return '''\n    <!doctype html>\n    <title>Upload new File</title>\n    <h1>Upload new File</h1>\n    <form method=post enctype=multipart/form-data>\n      <input type=file name=file>\n      <input type=submit value=Upload>\n    </form>\n    '''", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def hello_world():\n    return 'Warning: go to http://18.207.249.45/upload instead'", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def download():\n\n    # url = request.args.get('c')\n    # wget.download(url,app.config['UPLOAD_FOLDER']+\"/file.pdf\")\n\n\n    # url = request.args.get('c')\n    # print(url)\n    # r = requests.get(url,allow_redirects=True)\n    # print(r)\n    # open(UPLOAD_FOLDER+\"/file1.pdf\",\"wb\").write(r.content)\n\n\n    # with open(app.config['UPLOAD_FOLDER']+\"/file1.pdf\", \"wb\") as file:\n    #     response = requests.get(url)\n    #     file.write(response.content)\n\n    return \"success\"", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def upload_form():\n    return render_template('upload.html')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def upload_file():\n    if request.method == 'POST':\n        # check if the post request has the file part\n        if 'file' not in request.files:\n            flash('No file part')\n            return redirect(request.url)\n        file = request.files['file']\n        if file.filename == '':\n            flash('No file selected for uploading')\n            return redirect(request.url)\n        if file and allowed_file(file.filename):\n            filename = secure_filename(file.filename)\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n            flash('File successfully uploaded')\n            return redirect('/')\n        else:\n            flash('Allowed file types are txt, pdf, png, jpg, jpeg, gif')\n            return redirect(request.url)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def hello_world():\n    return 'Hello World! - emerald@mathsearch'", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def result():\n\tprint(\"getting result from backend!\")\n\t# start = time.time()\n\tdata = request.json\n\tfilename = data[\"file\"]\n\tcoords = data[\"coords\"]\n\tvenv_py = \"/home/ubuntu/MathSearch/front-end/venv/bin/python3\"\n\tpython_file = \"/home/ubuntu/MathSearch/front-end/web/render_result.py\"\n\tinfo = \"-f \" + filename + \" -c \" + coords\n\tcoords_lst = coords.split()\n\tpage_lst = []\n\n\tMATHSEARCH_BUCKET='mathsearch-intermediary'\n\tlocal_pdf = \"/home/ubuntu/MathSearch/front-end/web/pdf_in/\" + filename\n\ts3 = boto3.client(\"s3\")\n\ts3.download_file(\n        Bucket=MATHSEARCH_BUCKET, Key=\"inputs/\"+filename, Filename=local_pdf\n    )\n\tsubprocess.call([venv_py, python_file, info])\n\tfor i in range(0,len(coords_lst),5):\n\t\tpage_lst.append(int(coords_lst[i]))\n\t# json = {\n\t# \t\"pdf\":filename,\n\t# \t\"pages\":page_lst\n\t# }\n\t# end = time.time()\n\n\tinfo = {\n\t\t\"pdf\": \"/home/ubuntu/MathSearch/front-end/web/pdf_out/\"+filename[:-4]+\".pdf\",\n\t\t\"pages\": page_lst\n\t}\n\tINFO_PATH = \"/home/ubuntu/MathSearch/front-end/web/info/info.json\"\n\t# with open(INFO_PATH,\"w\") as json_file:\n\t# \tjson.dump(info, json_file, indent=4, separators=(\",\",\":\"))\n\tprint(\"got result from backend! saved to /home/ubuntu/MathSearch/front-end/web/info/info.json\")\n\treturn \"got result from backend! saved to /home/ubuntu/MathSearch/front-end/web/info/info.json\"", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def example_response():\n\tf = open ('info/info.json', \"r\")\n\tdata = json.loads(f.read())\n\tpdf_file = data['pdf']\n\treturn send_file(pdf_file, mimetype='application/pdf')\n\t# pdf_file = 'pdf_out/ex1.pdf'\n\t# with open('pdf_out/ex1.pdf', 'rb') as f:\n\t# \tpdf = f.read()\n\tpages = [1, 2, 56]\n\t# response_body = {\n\t# \t\"pdf\": pdf,\n\t# \t\"pages\": pages\n\t# }\n\t# response = make_response(response_body)\n\t# response.headers['Content-Type'] = 'application/json'\n\t# return response\n\t# response = make_response(send_file(pdf_file))\n\t# response.headers['pages'] = pages\n\t# return response\n\treturn send_file(pdf_file, mimetype='application/pdf')", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def response_pages():\n\tf = open ('info/info.json', \"r\")\n\tdata = json.loads(f.read())\n\tpages = data['pages']\n\treturn pages", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def result_error():\n\treturn \"Error occurred during running of the model\"", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def print_test_api():\n\treturn \"yesssssss the site is up - api/test\\n\"", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def print_test():\n\tprint(\"called test\")\n\treturn \"yesss! the site is up - update - debug - /test\\n\"", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def draw_bounding_box(image_path_in, bounding_box, image_path_out):\n\timage = cv2.imread(image_path_in)\n\theight, width, _ = image.shape\n\tx, y, w, h = bounding_box\n\tx1 = int((x - w/2) * width)\n\ty1 = int((y - h/2) * height)\n\tx2 = int((x + w/2) * width)\n\ty2 = int((y + h/2) * height)\n\tupper_left = (x1, y1)\n\tbottom_right = (x2, y2)\n\n\tRED = (0,0,255)\n\tBLUE = (255,0,0)\n\tGREEN = (0,255,0)\n\tSKYBLUE = (255,191,0)\n\n\t# note cv2 uses BGR color instead of RGB\n\tcv2.rectangle(image, upper_left, bottom_right, SKYBLUE, 3)\n\tcv2.imwrite(image_path_out, image)", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}, {"summary": "Error generating summary: can only concatenate str (not \"Context\") to str", "code": "def main(argv):\n\tif len(argv)==1:\n\t\targv = argv[0].split()\n\t# print(type(argv),type(argv[0]),argv)\n\tparser = argparse.ArgumentParser(\n\t\t\t\t\tprog='render_results.py',\n\t\t\t\t\tdescription='render yolov5 equation bonding box on image',\n\t\t\t\t\tepilog='Example usage: \\npython3 render_result.py -f ex1.pdf -c 0 0.3392857142857143 0.17142857142857146 0.30952380952380953 0.12698412698412698 1 0.32242063492063494 0.4380952380952381 0.26785714285714285 0.08888888888888889')\n\t\n\tparser.add_argument('-f','--file', help='pdf file name', required=True)\n\tparser.add_argument('-c','--coordinates', nargs='+', help='bounding box coordinates', required=True)\n\n\tIMG_IN_DIR = \"img_in/\"\n\tIMG_OUT_DIR = \"img_out/\"\n\tPDF_IN_DIR = \"pdf_in/\"\n\tPDF_OUT_DIR = \"pdf_out/\"\n\n\tpdf_name = parser.parse_args(argv).file\n\tpdf_in = PDF_IN_DIR + pdf_name\n\tpdf_out = PDF_OUT_DIR + pdf_name[:-4]+\".pdf\"\n\tpdf_no_ext = pdf_name[:-4]\n\n\tbounding_boxes = [float(x) for x in parser.parse_args(argv).coordinates]\n\t\n\tif(len(bounding_boxes) % 5 != 0):\n\t\tprint(\"Invalid number of coordinates, must be multiple of 5\")\n\t\treturn\n\t\n\ttable = {}\n\tfor i in range(0, len(bounding_boxes), 5):\n\t\ttable[int(bounding_boxes[i])] = bounding_boxes[i+1:i+5]\n\tresult_pages = list(table.keys())\n\n\t# Done 1: get result list, convert need box page in the pdf to png, save to /img_in\n\t# Done 2: call draw_bounding_boxes for each png, save to /img_out\n\timages = pdf2image.convert_from_path(pdf_in)\n\tfor i in result_pages:\n\t\timage_path_in = IMG_IN_DIR + pdf_no_ext + \"_\"+ str(i) + \".png\"\n\t\timages[i].save(image_path_in)\n\t\timage_path_out = IMG_OUT_DIR + pdf_no_ext + \"_\"+ str(i) + \".png\"\n\t\tdraw_bounding_box(image_path_in,table[i],image_path_out)\n\t\t# save img as pdf\n\t\timage = Image.open(image_path_out).convert('RGB')\n\t\timage.save(image_path_out[:-4]+\".pdf\")\n\t\n\t# Done 3: merge the rendered images to the pdf, save to /pdf_out\n\twith open(pdf_in, 'rb') as file:\n\t\twith open(pdf_out, 'wb') as pdf_out:\n\t\t\tpdf = PyPDF2.PdfReader(file)\n\t\t\toutput = PyPDF2.PdfWriter()\n\t\t\tfor i, page in enumerate(pdf.pages):\n\t\t\t\tif i in result_pages:\n\t\t\t\t\tnew_page = PyPDF2.PdfReader(IMG_OUT_DIR + pdf_no_ext + \"_\"+ str(i) + \".pdf\").pages[0]\n\t\t\t\t\tnew_page.scale_by(0.36)\n\t\t\t\t\toutput.add_page(new_page)\n\t\t\t\telse:\n\t\t\t\t\toutput.add_page(page)\n\t\t\toutput.write(pdf_out)\n\t\n\t# Done 4: save the result list to json file\n\t# result_pages_json = PDF_OUT_DIR + pdf_no_ext+\".json\"\n\t# with open(result_pages_json,'w') as file:\n\t# \tjson.dump(result_pages, file, indent=4, separators=(\",\", \":\"))\n\t\n\twith open(\"/home/ubuntu/MathSearch/front-end/web/result_log\",\"a\") as file:\n\t\targv_str = \" \".join(str(x) for x in argv)\n\t\tprint(argv_str)\n\t\tfile.write(time.strftime(\"%H:%M:%S\", time.localtime()) + \"\\t\" + argv_str)\n\t\tfile.write(\"\\n\")", "metadata": {"context": {"location": "/front-end/mathsearch/src/components/pages/archive", "prompt_context": ""}, "error": "can only concatenate str (not \"Context\") to str"}}]